--
-- PostgreSQL database dump
--

\restrict uSfZdqbqhDLfdiWcebdf7bVHiHLTUWaNEc4mwTcw8d1fUIGlfaW5gx4fyH2JXE1

-- Dumped from database version 17.6
-- Dumped by pg_dump version 17.8

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: auth; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA auth;


ALTER SCHEMA auth OWNER TO supabase_admin;

--
-- Name: extensions; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA extensions;


ALTER SCHEMA extensions OWNER TO postgres;

--
-- Name: graphql; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA graphql;


ALTER SCHEMA graphql OWNER TO supabase_admin;

--
-- Name: graphql_public; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA graphql_public;


ALTER SCHEMA graphql_public OWNER TO supabase_admin;

--
-- Name: pg_net; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_net WITH SCHEMA public;


--
-- Name: EXTENSION pg_net; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_net IS 'Async HTTP';


--
-- Name: pgbouncer; Type: SCHEMA; Schema: -; Owner: pgbouncer
--

CREATE SCHEMA pgbouncer;


ALTER SCHEMA pgbouncer OWNER TO pgbouncer;

--
-- Name: realtime; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA realtime;


ALTER SCHEMA realtime OWNER TO supabase_admin;

--
-- Name: storage; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA storage;


ALTER SCHEMA storage OWNER TO supabase_admin;

--
-- Name: supabase_migrations; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA supabase_migrations;


ALTER SCHEMA supabase_migrations OWNER TO postgres;

--
-- Name: vault; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA vault;


ALTER SCHEMA vault OWNER TO supabase_admin;

--
-- Name: http; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS http WITH SCHEMA public;


--
-- Name: EXTENSION http; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION http IS 'HTTP client for PostgreSQL, allows web page retrieval inside the database.';


--
-- Name: pg_graphql; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_graphql WITH SCHEMA graphql;


--
-- Name: EXTENSION pg_graphql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_graphql IS 'pg_graphql: GraphQL support';


--
-- Name: pg_stat_statements; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_stat_statements WITH SCHEMA extensions;


--
-- Name: EXTENSION pg_stat_statements; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_stat_statements IS 'track planning and execution statistics of all SQL statements executed';


--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;


--
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- Name: postgis; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS postgis WITH SCHEMA public;


--
-- Name: EXTENSION postgis; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION postgis IS 'PostGIS geometry and geography spatial types and functions';


--
-- Name: supabase_vault; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS supabase_vault WITH SCHEMA vault;


--
-- Name: EXTENSION supabase_vault; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION supabase_vault IS 'Supabase Vault Extension';


--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;


--
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


--
-- Name: aal_level; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.aal_level AS ENUM (
    'aal1',
    'aal2',
    'aal3'
);


ALTER TYPE auth.aal_level OWNER TO supabase_auth_admin;

--
-- Name: code_challenge_method; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.code_challenge_method AS ENUM (
    's256',
    'plain'
);


ALTER TYPE auth.code_challenge_method OWNER TO supabase_auth_admin;

--
-- Name: factor_status; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.factor_status AS ENUM (
    'unverified',
    'verified'
);


ALTER TYPE auth.factor_status OWNER TO supabase_auth_admin;

--
-- Name: factor_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.factor_type AS ENUM (
    'totp',
    'webauthn',
    'phone'
);


ALTER TYPE auth.factor_type OWNER TO supabase_auth_admin;

--
-- Name: oauth_authorization_status; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_authorization_status AS ENUM (
    'pending',
    'approved',
    'denied',
    'expired'
);


ALTER TYPE auth.oauth_authorization_status OWNER TO supabase_auth_admin;

--
-- Name: oauth_client_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_client_type AS ENUM (
    'public',
    'confidential'
);


ALTER TYPE auth.oauth_client_type OWNER TO supabase_auth_admin;

--
-- Name: oauth_registration_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_registration_type AS ENUM (
    'dynamic',
    'manual'
);


ALTER TYPE auth.oauth_registration_type OWNER TO supabase_auth_admin;

--
-- Name: oauth_response_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_response_type AS ENUM (
    'code'
);


ALTER TYPE auth.oauth_response_type OWNER TO supabase_auth_admin;

--
-- Name: one_time_token_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.one_time_token_type AS ENUM (
    'confirmation_token',
    'reauthentication_token',
    'recovery_token',
    'email_change_token_new',
    'email_change_token_current',
    'phone_change_token'
);


ALTER TYPE auth.one_time_token_type OWNER TO supabase_auth_admin;

--
-- Name: action; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.action AS ENUM (
    'INSERT',
    'UPDATE',
    'DELETE',
    'TRUNCATE',
    'ERROR'
);


ALTER TYPE realtime.action OWNER TO supabase_admin;

--
-- Name: equality_op; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.equality_op AS ENUM (
    'eq',
    'neq',
    'lt',
    'lte',
    'gt',
    'gte',
    'in'
);


ALTER TYPE realtime.equality_op OWNER TO supabase_admin;

--
-- Name: user_defined_filter; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.user_defined_filter AS (
	column_name text,
	op realtime.equality_op,
	value text
);


ALTER TYPE realtime.user_defined_filter OWNER TO supabase_admin;

--
-- Name: wal_column; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.wal_column AS (
	name text,
	type_name text,
	type_oid oid,
	value jsonb,
	is_pkey boolean,
	is_selectable boolean
);


ALTER TYPE realtime.wal_column OWNER TO supabase_admin;

--
-- Name: wal_rls; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.wal_rls AS (
	wal jsonb,
	is_rls_enabled boolean,
	subscription_ids uuid[],
	errors text[]
);


ALTER TYPE realtime.wal_rls OWNER TO supabase_admin;

--
-- Name: buckettype; Type: TYPE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TYPE storage.buckettype AS ENUM (
    'STANDARD',
    'ANALYTICS',
    'VECTOR'
);


ALTER TYPE storage.buckettype OWNER TO supabase_storage_admin;

--
-- Name: email(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.email() RETURNS text
    LANGUAGE sql STABLE
    AS $$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$$;


ALTER FUNCTION auth.email() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION email(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.email() IS 'Deprecated. Use auth.jwt() -> ''email'' instead.';


--
-- Name: jwt(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.jwt() RETURNS jsonb
    LANGUAGE sql STABLE
    AS $$
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$$;


ALTER FUNCTION auth.jwt() OWNER TO supabase_auth_admin;

--
-- Name: role(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.role() RETURNS text
    LANGUAGE sql STABLE
    AS $$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$$;


ALTER FUNCTION auth.role() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION role(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.role() IS 'Deprecated. Use auth.jwt() -> ''role'' instead.';


--
-- Name: uid(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.uid() RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid
$$;


ALTER FUNCTION auth.uid() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION uid(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.uid() IS 'Deprecated. Use auth.jwt() -> ''sub'' instead.';


--
-- Name: grant_pg_cron_access(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.grant_pg_cron_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF EXISTS (
    SELECT
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_cron'
  )
  THEN
    grant usage on schema cron to postgres with grant option;

    alter default privileges in schema cron grant all on tables to postgres with grant option;
    alter default privileges in schema cron grant all on functions to postgres with grant option;
    alter default privileges in schema cron grant all on sequences to postgres with grant option;

    alter default privileges for user supabase_admin in schema cron grant all
        on sequences to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on tables to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on functions to postgres with grant option;

    grant all privileges on all tables in schema cron to postgres with grant option;
    revoke all on table cron.job from postgres;
    grant select on table cron.job to postgres with grant option;
  END IF;
END;
$$;


ALTER FUNCTION extensions.grant_pg_cron_access() OWNER TO supabase_admin;

--
-- Name: FUNCTION grant_pg_cron_access(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.grant_pg_cron_access() IS 'Grants access to pg_cron';


--
-- Name: grant_pg_graphql_access(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.grant_pg_graphql_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    func_is_graphql_resolve bool;
BEGIN
    func_is_graphql_resolve = (
        SELECT n.proname = 'resolve'
        FROM pg_event_trigger_ddl_commands() AS ev
        LEFT JOIN pg_catalog.pg_proc AS n
        ON ev.objid = n.oid
    );

    IF func_is_graphql_resolve
    THEN
        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
        DROP FUNCTION IF EXISTS graphql_public.graphql;
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language sql
        as $$
            select graphql.resolve(
                query := query,
                variables := coalesce(variables, '{}'),
                "operationName" := "operationName",
                extensions := extensions
            );
        $$;

        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
        -- function in the extension so we need to grant permissions on existing entities AND
        -- update default permissions to any others that are created after `graphql.resolve`
        grant usage on schema graphql to postgres, anon, authenticated, service_role;
        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;

        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles
        grant usage on schema graphql_public to postgres with grant option;
        grant usage on schema graphql to postgres with grant option;
    END IF;

END;
$_$;


ALTER FUNCTION extensions.grant_pg_graphql_access() OWNER TO supabase_admin;

--
-- Name: FUNCTION grant_pg_graphql_access(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.grant_pg_graphql_access() IS 'Grants access to pg_graphql';


--
-- Name: grant_pg_net_access(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.grant_pg_net_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_net'
  )
  THEN
    IF NOT EXISTS (
      SELECT 1
      FROM pg_roles
      WHERE rolname = 'supabase_functions_admin'
    )
    THEN
      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
    END IF;

    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;

    IF EXISTS (
      SELECT FROM pg_extension
      WHERE extname = 'pg_net'
      -- all versions in use on existing projects as of 2025-02-20
      -- version 0.12.0 onwards don't need these applied
      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')
    ) THEN
      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;

      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;

      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;

      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
    END IF;
  END IF;
END;
$$;


ALTER FUNCTION extensions.grant_pg_net_access() OWNER TO supabase_admin;

--
-- Name: FUNCTION grant_pg_net_access(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.grant_pg_net_access() IS 'Grants access to pg_net';


--
-- Name: pgrst_ddl_watch(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.pgrst_ddl_watch() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  cmd record;
BEGIN
  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
  LOOP
    IF cmd.command_tag IN (
      'CREATE SCHEMA', 'ALTER SCHEMA'
    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
    , 'CREATE VIEW', 'ALTER VIEW'
    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
    , 'CREATE FUNCTION', 'ALTER FUNCTION'
    , 'CREATE TRIGGER'
    , 'CREATE TYPE', 'ALTER TYPE'
    , 'CREATE RULE'
    , 'COMMENT'
    )
    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
    AND cmd.schema_name is distinct from 'pg_temp'
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $$;


ALTER FUNCTION extensions.pgrst_ddl_watch() OWNER TO supabase_admin;

--
-- Name: pgrst_drop_watch(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.pgrst_drop_watch() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  obj record;
BEGIN
  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
  LOOP
    IF obj.object_type IN (
      'schema'
    , 'table'
    , 'foreign table'
    , 'view'
    , 'materialized view'
    , 'function'
    , 'trigger'
    , 'type'
    , 'rule'
    )
    AND obj.is_temporary IS false -- no pg_temp objects
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $$;


ALTER FUNCTION extensions.pgrst_drop_watch() OWNER TO supabase_admin;

--
-- Name: set_graphql_placeholder(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.set_graphql_placeholder() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $_$
    DECLARE
    graphql_is_dropped bool;
    BEGIN
    graphql_is_dropped = (
        SELECT ev.schema_name = 'graphql_public'
        FROM pg_event_trigger_dropped_objects() AS ev
        WHERE ev.schema_name = 'graphql_public'
    );

    IF graphql_is_dropped
    THEN
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language plpgsql
        as $$
            DECLARE
                server_version float;
            BEGIN
                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

                IF server_version >= 14 THEN
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql extension is not enabled.'
                            )
                        )
                    );
                ELSE
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
                            )
                        )
                    );
                END IF;
            END;
        $$;
    END IF;

    END;
$_$;


ALTER FUNCTION extensions.set_graphql_placeholder() OWNER TO supabase_admin;

--
-- Name: FUNCTION set_graphql_placeholder(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.set_graphql_placeholder() IS 'Reintroduces placeholder function for graphql_public.graphql';


--
-- Name: get_auth(text); Type: FUNCTION; Schema: pgbouncer; Owner: supabase_admin
--

CREATE FUNCTION pgbouncer.get_auth(p_usename text) RETURNS TABLE(username text, password text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $_$
  BEGIN
      RAISE DEBUG 'PgBouncer auth request: %', p_usename;

      RETURN QUERY
      SELECT
          rolname::text,
          CASE WHEN rolvaliduntil < now()
              THEN null
              ELSE rolpassword::text
          END
      FROM pg_authid
      WHERE rolname=$1 and rolcanlogin;
  END;
  $_$;


ALTER FUNCTION pgbouncer.get_auth(p_usename text) OWNER TO supabase_admin;

--
-- Name: accept_contact_invitation(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.accept_contact_invitation(p_contact_id uuid, p_user_id uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_contact record;
  v_reverse_contact_id uuid;
  v_inviter_name text;
  v_inviter_email text;
  v_inviter_phone text;
BEGIN
  -- R√©cup√©rer l'invitation
  SELECT * INTO v_contact FROM contacts 
  WHERE id = p_contact_id 
  AND invited_user_id = p_user_id
  AND invitation_status = 'pending';

  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', false,
      'message', 'Invitation introuvable ou d√©j√† trait√©e'
    );
  END IF;

  -- Mettre √† jour le statut de l'invitation
  UPDATE contacts 
  SET 
    invitation_status = 'accepted',
    invitation_responded_at = now()
  WHERE id = p_contact_id;

  -- R√©cup√©rer les infos de l'exp√©diteur depuis profiles
  SELECT 
    COALESCE(full_name, first_name || ' ' || last_name, 'Utilisateur') as name,
    email,
    phone
  INTO v_inviter_name, v_inviter_email, v_inviter_phone
  FROM profiles 
  WHERE id = v_contact.invited_by;

  -- Cr√©er le contact inverse (relation bidirectionnelle)
  -- SANS la colonne company de profiles (on utilise company du contact original)
  INSERT INTO contacts (
    user_id,
    invited_by,
    invited_user_id,
    type,
    name,
    email,
    phone,
    company,
    invitation_status,
    invitation_sent_at,
    invitation_responded_at
  ) VALUES (
    p_user_id,
    v_contact.invited_by,
    v_contact.invited_by,
    v_contact.type,
    v_inviter_name,
    v_inviter_email,
    v_inviter_phone,
    COALESCE(v_contact.company, ''), -- Utiliser company du contact, pas de profiles
    'accepted',
    v_contact.invitation_sent_at,
    now()
  ) RETURNING id INTO v_reverse_contact_id;

  RETURN json_build_object(
    'success', true,
    'contact_id', p_contact_id,
    'reverse_contact_id', v_reverse_contact_id,
    'message', 'Invitation accept√©e avec succ√®s'
  );
END;
$$;


ALTER FUNCTION public.accept_contact_invitation(p_contact_id uuid, p_user_id uuid) OWNER TO postgres;

--
-- Name: accept_contact_request(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.accept_contact_request(p_request_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_requester_id uuid;
  v_target_email text;
  v_success boolean := false;
BEGIN
  -- R√©cup√©rer les infos de la demande
  SELECT requester_id, target_email
  INTO v_requester_id, v_target_email
  FROM public.contact_requests
  WHERE id = p_request_id AND status = 'pending';
  
  IF v_requester_id IS NULL THEN
    RETURN false;
  END IF;
  
  -- Mettre √† jour le statut
  UPDATE public.contact_requests
  SET 
    status = 'accepted',
    accepted_at = NOW(),
    updated_at = NOW()
  WHERE id = p_request_id;
  
  -- TODO: Cr√©er le contact dans la table contacts si besoin
  -- Cette partie peut √™tre g√©r√©e par le service TypeScript
  
  RETURN true;
END;
$$;


ALTER FUNCTION public.accept_contact_request(p_request_id uuid) OWNER TO postgres;

--
-- Name: add_credits(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_credits(p_user_id uuid, p_amount integer) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO user_credits (user_id, credits, created_at, updated_at)
  VALUES (p_user_id, p_amount, NOW(), NOW())
  ON CONFLICT (user_id) DO UPDATE
  SET 
    credits = user_credits.credits + p_amount,
    updated_at = NOW();
  
  RAISE NOTICE 'Ajout√© % cr√©dits pour user %', p_amount, p_user_id;
END;
$$;


ALTER FUNCTION public.add_credits(p_user_id uuid, p_amount integer) OWNER TO postgres;

--
-- Name: add_credits(uuid, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_credits(p_user_id uuid, p_amount integer, p_description text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_new_balance INTEGER;
BEGIN
    UPDATE profiles
    SET credits = credits + p_amount
    WHERE id = p_user_id
    RETURNING credits INTO v_new_balance;

    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'credit_transactions') THEN
        INSERT INTO credit_transactions (user_id, transaction_type, amount, balance_after, description, reference_id, reference_type, created_at)
        VALUES (p_user_id, 'addition', p_amount, v_new_balance, p_description, NULL, NULL, NOW());
    END IF;

    RETURN json_build_object(
        'success', true,
        'new_balance', v_new_balance,
        'added', p_amount
    );
END;
$$;


ALTER FUNCTION public.add_credits(p_user_id uuid, p_amount integer, p_description text) OWNER TO postgres;

--
-- Name: add_credits_atomic(uuid, integer, text, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_transaction_type text DEFAULT 'credit'::text, p_reference_type text DEFAULT NULL::text, p_reference_id text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_current_credits INTEGER;
  v_new_balance INTEGER;
BEGIN
  SELECT credits INTO v_current_credits
  FROM profiles
  WHERE id = p_user_id
  FOR UPDATE;

  IF v_current_credits IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Utilisateur non trouv√©');
  END IF;

  v_new_balance := v_current_credits + p_amount;

  UPDATE profiles
  SET credits = v_new_balance,
      updated_at = NOW()
  WHERE id = p_user_id;

  INSERT INTO credit_transactions (user_id, amount, transaction_type, description, reference_type, reference_id, balance_after)
  VALUES (p_user_id, p_amount, p_transaction_type, p_description, p_reference_type, p_reference_id::UUID, v_new_balance);

  RETURN json_build_object(
    'success', true,
    'new_balance', v_new_balance,
    'amount_added', p_amount
  );
END;
$$;


ALTER FUNCTION public.add_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_transaction_type text, p_reference_type text, p_reference_id text) OWNER TO postgres;

--
-- Name: add_credits_with_expiration(uuid, integer, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_credits_with_expiration(p_user_id uuid, p_credits integer, p_package_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_existing_credits integer;
  v_current_expiration timestamptz;
BEGIN
  -- R√©cup√©rer les cr√©dits existants et l'expiration actuelle
  SELECT credits_balance, subscription_expires_at
  INTO v_existing_credits, v_current_expiration
  FROM user_credits
  WHERE user_id = p_user_id;

  -- Si l'abonnement est expir√© ou n'existe pas, r√©initialiser les cr√©dits
  IF v_current_expiration IS NULL OR v_current_expiration < now() THEN
    v_existing_credits := 0;
  END IF;

  -- Les cr√©dits ne sont pas cumulables, on prend le nouveau montant
  UPDATE user_credits
  SET 
    credits_balance = p_credits,
    subscription_expires_at = now() + interval '30 days',
    last_subscription_package_id = p_package_id,
    updated_at = now()
  WHERE user_id = p_user_id;

  -- Si l'utilisateur n'existe pas encore, cr√©er l'entr√©e
  IF NOT FOUND THEN
    INSERT INTO user_credits (user_id, credits_balance, subscription_expires_at, last_subscription_package_id)
    VALUES (p_user_id, p_credits, now() + interval '30 days', p_package_id);
  END IF;
END;
$$;


ALTER FUNCTION public.add_credits_with_expiration(p_user_id uuid, p_credits integer, p_package_id uuid) OWNER TO postgres;

--
-- Name: admin_adjust_credits(text, integer, text, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.admin_adjust_credits(p_email text, p_delta integer, p_description text, p_reference_id uuid DEFAULT NULL::uuid, p_reference_type text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_user_id UUID;
    v_current INTEGER;
    v_new INTEGER;
    v_type TEXT;
BEGIN
    -- Recherche case-insensitive dans profiles, puis fallback sur auth.users
    SELECT id INTO v_user_id FROM profiles WHERE lower(email) = lower(trim(p_email)) LIMIT 1;
    IF v_user_id IS NULL THEN
        SELECT id INTO v_user_id FROM auth.users WHERE lower(email) = lower(trim(p_email)) LIMIT 1;
    END IF;

    IF v_user_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Utilisateur introuvable');
    END IF;

    -- Verrouiller la ligne profil; si absente, renvoyer erreur explicite
    SELECT credits INTO v_current FROM profiles WHERE id = v_user_id FOR UPDATE;
    IF NOT FOUND THEN
        RETURN json_build_object('success', false, 'error', 'Profil inexistant pour cet utilisateur');
    END IF;

    v_new := v_current + p_delta;
    IF v_new < 0 THEN
        RETURN json_build_object('success', false, 'error', 'Cr√©dits insuffisants', 'current', v_current, 'delta', p_delta);
    END IF;

    UPDATE profiles SET credits = v_new WHERE id = v_user_id;
    v_type := CASE WHEN p_delta >= 0 THEN 'addition' ELSE 'deduction' END;

    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'credit_transactions') THEN
        INSERT INTO credit_transactions (user_id, transaction_type, amount, balance_after, description, reference_id, reference_type, created_at)
        VALUES (v_user_id, v_type, p_delta, v_new, p_description, p_reference_id, p_reference_type, NOW());
    END IF;

    RETURN json_build_object('success', true, 'email', trim(p_email), 'new_balance', v_new, 'delta', p_delta, 'transaction_type', v_type);
END;
$$;


ALTER FUNCTION public.admin_adjust_credits(p_email text, p_delta integer, p_description text, p_reference_id uuid, p_reference_type text) OWNER TO postgres;

--
-- Name: admin_adjust_credits_by_user_id(uuid, integer, text, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.admin_adjust_credits_by_user_id(p_user_id uuid, p_delta integer, p_description text, p_reference_id uuid DEFAULT NULL::uuid, p_reference_type text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_current INTEGER;
    v_new INTEGER;
    v_type TEXT;
BEGIN
    SELECT credits INTO v_current FROM profiles WHERE id = p_user_id FOR UPDATE;
    IF NOT FOUND THEN
        RETURN json_build_object('success', false, 'error', 'Profil inexistant pour cet utilisateur');
    END IF;

    v_new := v_current + p_delta;
    IF v_new < 0 THEN
        RETURN json_build_object('success', false, 'error', 'Cr√©dits insuffisants', 'current', v_current, 'delta', p_delta);
    END IF;

    UPDATE profiles SET credits = v_new WHERE id = p_user_id;
    v_type := CASE WHEN p_delta >= 0 THEN 'addition' ELSE 'deduction' END;

    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'credit_transactions') THEN
        INSERT INTO credit_transactions (user_id, transaction_type, amount, balance_after, description, reference_id, reference_type, created_at)
        VALUES (p_user_id, v_type, p_delta, v_new, p_description, p_reference_id, p_reference_type, NOW());
    END IF;

    RETURN json_build_object('success', true, 'user_id', p_user_id, 'new_balance', v_new, 'delta', p_delta, 'transaction_type', v_type);
END;
$$;


ALTER FUNCTION public.admin_adjust_credits_by_user_id(p_user_id uuid, p_delta integer, p_description text, p_reference_id uuid, p_reference_type text) OWNER TO postgres;

--
-- Name: assign_credits_for_plan(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.assign_credits_for_plan() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
credit_amount INTEGER;
BEGIN
-- Only if subscription is active
IF NEW.status = 'active' THEN

-- Get credits from shop_items table
SELECT credits_amount INTO credit_amount
FROM shop_items
WHERE item_type = 'subscription'
AND name = NEW.plan
AND is_active = true
LIMIT 1;

-- If plan found in shop, use its credits
IF credit_amount IS NOT NULL THEN
-- FORCE update to exact amount from shop
INSERT INTO user_credits (user_id, balance)
VALUES (NEW.user_id, credit_amount)
ON CONFLICT (user_id)
DO UPDATE SET balance = credit_amount;

RAISE NOTICE 'Credits set to % for user % with plan % (from shop_items)', credit_amount, NEW.user_id, NEW.plan;
ELSE
-- Fallback if plan not in shop (shouldn't happen)
RAISE WARNING 'Plan % not found in shop_items, using default 10 credits', NEW.plan;

INSERT INTO user_credits (user_id, balance)
VALUES (NEW.user_id, 10)
ON CONFLICT (user_id)
DO UPDATE SET balance = 10;
END IF;
END IF;

RETURN NEW;
END;
$$;


ALTER FUNCTION public.assign_credits_for_plan() OWNER TO postgres;

--
-- Name: auto_create_ride_offer_from_mission(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.auto_create_ride_offer_from_mission() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Quand une mission passe en in_progress, cr√©er automatiquement une offre de place
  IF NEW.status = 'in_progress' AND (OLD.status IS NULL OR OLD.status != 'in_progress') THEN
    INSERT INTO ride_offers (
      user_id, mission_id,
      origin_city, origin_lat, origin_lng,
      destination_city, destination_lat, destination_lng,
      departure_date, departure_time,
      vehicle_type, status, needs_return,
      notes
    )
    SELECT
      COALESCE(NEW.assigned_user_id, NEW.user_id),
      NEW.id,
      COALESCE(NEW.pickup_city, split_part(NEW.pickup_address, ',', 1)),
      NEW.pickup_lat::double precision,
      NEW.pickup_lng::double precision,
      COALESCE(NEW.delivery_city, split_part(NEW.delivery_address, ',', 1)),
      NEW.delivery_lat::double precision,
      NEW.delivery_lng::double precision,
      COALESCE(NEW.pickup_date::date, CURRENT_DATE),
      COALESCE(NEW.pickup_date::time, '08:00'::time),
      COALESCE(NEW.vehicle_type, 'car'),
      'active',
      true,
      'Place disponible ‚Äî convoyage ' || COALESCE(NEW.reference, '')
    WHERE NOT EXISTS (
      SELECT 1 FROM ride_offers WHERE mission_id = NEW.id AND status IN ('active', 'en_route')
    );
  END IF;
  
  -- Quand une mission est termin√©e, fermer l'offre
  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
    UPDATE ride_offers SET status = 'completed' WHERE mission_id = NEW.id AND status IN ('active', 'en_route');
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.auto_create_ride_offer_from_mission() OWNER TO postgres;

--
-- Name: FUNCTION auto_create_ride_offer_from_mission(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.auto_create_ride_offer_from_mission() IS 'Cr√©e automatiquement une offre de place quand une mission d√©marre';


--
-- Name: auto_fill_legal_mentions(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.auto_fill_legal_mentions() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Si pas de mentions personnalis√©es, g√©n√©rer automatiquement
  IF NEW.legal_mentions IS NULL OR NEW.legal_mentions = '' THEN
    NEW.legal_mentions := get_legal_mentions(NEW.vat_regime, NEW.vat_liable);
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.auto_fill_legal_mentions() OWNER TO postgres;

--
-- Name: auto_generate_report_on_session_end(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.auto_generate_report_on_session_end() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
    -- D√©tecter zones d'arr√™t
    PERFORM detect_stop_zones(NEW.id);
    
    -- Simplifier route (garder 1 point sur 5)
    PERFORM simplify_tracking_route(NEW.id);
    
    -- G√©n√©rer rapport
    PERFORM generate_driving_report(NEW.id);
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.auto_generate_report_on_session_end() OWNER TO postgres;

--
-- Name: auto_generate_share_code(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.auto_generate_share_code() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  new_code TEXT;
  exists_code BOOLEAN;
BEGIN
  IF NEW.share_code IS NOT NULL THEN
    RETURN NEW;
  END IF;

  LOOP
    new_code := public.generate_share_code();
    SELECT EXISTS(SELECT 1 FROM public.missions WHERE share_code = new_code) INTO exists_code;
    EXIT WHEN NOT exists_code;
  END LOOP;

  NEW.share_code := new_code;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.auto_generate_share_code() OWNER TO postgres;

--
-- Name: calculate_distance_km(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_distance_km(lat1 numeric, lon1 numeric, lat2 numeric, lon2 numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
earth_radius_km decimal := 6371.0;
dlat decimal;
dlon decimal;
a decimal;
c decimal;
BEGIN
IF lat1 IS NULL OR lon1 IS NULL OR lat2 IS NULL OR lon2 IS NULL THEN
RETURN NULL;
END IF;

dlat := radians(lat2 - lat1);
dlon := radians(lon2 - lon1);

a := sin(dlat/2) * sin(dlat/2) + 
cos(radians(lat1)) * cos(radians(lat2)) * 
sin(dlon/2) * sin(dlon/2);

c := 2 * atan2(sqrt(a), sqrt(1-a));

RETURN earth_radius_km * c;
END;
$$;


ALTER FUNCTION public.calculate_distance_km(lat1 numeric, lon1 numeric, lat2 numeric, lon2 numeric) OWNER TO postgres;

--
-- Name: calculate_driver_rating(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_driver_rating(p_user_id uuid) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_avg_rating DECIMAL(3,2);
BEGIN
  SELECT COALESCE(AVG(overall_rating), 0.00)
  INTO v_avg_rating
  FROM ride_reviews
  WHERE reviewed_user_id = p_user_id
    AND is_public = true;
  
  UPDATE driver_profiles
  SET average_rating = v_avg_rating,
      total_reviews = (SELECT COUNT(*) FROM ride_reviews WHERE reviewed_user_id = p_user_id)
  WHERE user_id = p_user_id;
  
  RETURN v_avg_rating;
END;
$$;


ALTER FUNCTION public.calculate_driver_rating(p_user_id uuid) OWNER TO postgres;

--
-- Name: calculate_planning_eta(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_planning_eta(p_planning_id uuid, p_user_lat double precision, p_user_lng double precision) RETURNS TABLE(city text, distance_km double precision, eta_minutes integer, is_reached boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_earth_radius CONSTANT DOUBLE PRECISION := 6371;
  v_avg_speed_kmh CONSTANT DOUBLE PRECISION := 80;
  v_planning RECORD;
BEGIN
  SELECT * INTO v_planning FROM convoy_plannings WHERE id = p_planning_id;
  IF v_planning IS NULL THEN RETURN; END IF;

  -- Calcul pour chaque point du trajet
  RETURN QUERY
  WITH all_points AS (
    -- Origine
    SELECT v_planning.origin_city AS city, v_planning.origin_lat AS lat, v_planning.origin_lng AS lng, -1 AS sort_order
    UNION ALL
    -- Waypoints
    SELECT pw.city, pw.lat, pw.lng, pw.sort_order
    FROM planning_waypoints pw WHERE pw.planning_id = p_planning_id
    UNION ALL
    -- Destination
    SELECT v_planning.destination_city, v_planning.destination_lat, v_planning.destination_lng, 9999
  )
  SELECT 
    ap.city,
    -- Distance Haversine
    (v_earth_radius * 2 * asin(sqrt(
      sin(radians(ap.lat - p_user_lat) / 2) ^ 2 +
      cos(radians(p_user_lat)) * cos(radians(ap.lat)) *
      sin(radians(ap.lng - p_user_lng) / 2) ^ 2
    ))) AS distance_km,
    -- ETA en minutes (distance / vitesse * 60)
    ((v_earth_radius * 2 * asin(sqrt(
      sin(radians(ap.lat - p_user_lat) / 2) ^ 2 +
      cos(radians(p_user_lat)) * cos(radians(ap.lat)) *
      sin(radians(ap.lng - p_user_lng) / 2) ^ 2
    )) / v_avg_speed_kmh) * 60)::INTEGER AS eta_minutes,
    -- Consid√©r√© comme atteint si < 2km
    ((v_earth_radius * 2 * asin(sqrt(
      sin(radians(ap.lat - p_user_lat) / 2) ^ 2 +
      cos(radians(p_user_lat)) * cos(radians(ap.lat)) *
      sin(radians(ap.lng - p_user_lng) / 2) ^ 2
    ))) < 2)::BOOLEAN AS is_reached
  FROM all_points ap
  WHERE ap.lat IS NOT NULL AND ap.lng IS NOT NULL
  ORDER BY ap.sort_order;
END;
$$;


ALTER FUNCTION public.calculate_planning_eta(p_planning_id uuid, p_user_lat double precision, p_user_lng double precision) OWNER TO postgres;

--
-- Name: FUNCTION calculate_planning_eta(p_planning_id uuid, p_user_lat double precision, p_user_lng double precision); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calculate_planning_eta(p_planning_id uuid, p_user_lat double precision, p_user_lng double precision) IS 'Calcule l ETA vers chaque ville du planning bas√© sur la position GPS';


--
-- Name: calculate_profile_completion(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_profile_completion(profile_id uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    completion INTEGER := 0;
    required_fields INTEGER := 0;
    filled_fields INTEGER := 0;
BEGIN
    -- R√©cup√©rer le profil
    SELECT 
        CASE WHEN full_name IS NOT NULL AND full_name != '' THEN 1 ELSE 0 END +
        CASE WHEN email IS NOT NULL AND email != '' THEN 1 ELSE 0 END +
        CASE WHEN phone IS NOT NULL AND phone != '' THEN 1 ELSE 0 END +
        CASE WHEN avatar_url IS NOT NULL AND avatar_url != '' THEN 1 ELSE 0 END +
        CASE WHEN user_type IS NOT NULL THEN 1 ELSE 0 END +
        CASE WHEN 
            (user_type = 'individual' OR user_type = 'driver') 
            OR (company IS NOT NULL AND company != '') 
        THEN 1 ELSE 0 END +
        CASE WHEN 
            (user_type = 'individual' OR user_type = 'driver') 
            OR (siret IS NOT NULL AND siret != '') 
        THEN 1 ELSE 0 END +
        CASE WHEN 
            (user_type = 'individual' OR user_type = 'driver') 
            OR (logo_url IS NOT NULL AND logo_url != '') 
        THEN 1 ELSE 0 END +
        CASE WHEN phone_verified = TRUE THEN 1 ELSE 0 END +
        CASE WHEN email_verified = TRUE THEN 1 ELSE 0 END
    INTO filled_fields
    FROM public.profiles
    WHERE id = profile_id;

    -- Total des champs requis = 10
    required_fields := 10;
    
    -- Calcul pourcentage
    completion := (filled_fields * 100) / required_fields;
    
    RETURN completion;
END;
$$;


ALTER FUNCTION public.calculate_profile_completion(profile_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION calculate_profile_completion(profile_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calculate_profile_completion(profile_id uuid) IS 'Calcule pourcentage de compl√©tion du profil (0-100)';


--
-- Name: calculate_quote_total_distance(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_quote_total_distance() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Calculer la distance totale depuis les items JSON
  SELECT COALESCE(SUM((item->>'distance')::DECIMAL), 0)
  INTO NEW.total_distance
  FROM jsonb_array_elements(NEW.items) AS item;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.calculate_quote_total_distance() OWNER TO postgres;

--
-- Name: calculate_vat(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_vat() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Si non assujetti √† la TVA ou r√©gime franchise/micro
  IF NEW.vat_liable = false OR NEW.vat_regime IN ('franchise', 'micro') THEN
    NEW.tax_rate := 0;
    NEW.tax_amount := 0;
    NEW.total := NEW.subtotal;
  ELSE
    -- TVA normale (20% par d√©faut)
    IF NEW.tax_rate IS NULL THEN
      NEW.tax_rate := 20;
    END IF;
    NEW.tax_amount := ROUND((NEW.subtotal * NEW.tax_rate / 100)::numeric, 2);
    NEW.total := NEW.subtotal + NEW.tax_amount;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.calculate_vat() OWNER TO postgres;

--
-- Name: check_assignment_rules(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_assignment_rules() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  existing_assignment RECORD;
BEGIN
  -- 1. V√âRIFIER LES DOUBLONS (INSERT uniquement)
  IF (TG_OP = 'INSERT') THEN
    -- V√©rifier si la mission est d√©j√† assign√©e
    SELECT * INTO existing_assignment
    FROM mission_assignments
    WHERE mission_id = NEW.mission_id
    AND status NOT IN ('cancelled', 'completed');
    
    IF FOUND THEN
      -- ‚úÖ Annuler automatiquement l'ancienne assignation
      UPDATE mission_assignments 
      SET status = 'cancelled', 
          notes = COALESCE(notes || ' | ', '') || '‚ùå Annul√©e - R√©assign√©e le ' || NOW()::TEXT
      WHERE id = existing_assignment.id;
    END IF;
  END IF;
  
  -- 2. CHANGEMENT D'ASSIGN√â (UPDATE) - Permettre sauf si compl√©t√©
  IF (TG_OP = 'UPDATE' AND OLD.user_id IS DISTINCT FROM NEW.user_id) THEN
    IF OLD.status = 'completed' THEN
      RAISE EXCEPTION '‚ùå Mission d√©j√† termin√©e, impossible de r√©assigner !';
    END IF;
    
    NEW.notes := COALESCE(NEW.notes || ' | ', '') || 'üîÑ R√©assign√© le ' || NOW()::TEXT;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.check_assignment_rules() OWNER TO postgres;

--
-- Name: check_email_available(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_email_available(p_email text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN NOT EXISTS (SELECT 1 FROM public.profiles WHERE email = p_email);
END;
$$;


ALTER FUNCTION public.check_email_available(p_email text) OWNER TO postgres;

--
-- Name: check_existing_user(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_existing_user(p_email text, p_phone text DEFAULT NULL::text) RETURNS TABLE(user_exists boolean, user_id uuid, matched_by text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
-- V√©rifier par email
IF EXISTS (SELECT 1 FROM profiles WHERE email = p_email) THEN
RETURN QUERY
SELECT 
true,
id,
'email'::text
FROM profiles
WHERE email = p_email
LIMIT 1;
RETURN;
END IF;

-- V√©rifier par t√©l√©phone si fourni
IF p_phone IS NOT NULL AND p_phone != '' THEN
IF EXISTS (SELECT 1 FROM profiles WHERE phone = p_phone) THEN
RETURN QUERY
SELECT 
true,
id,
'phone'::text
FROM profiles
WHERE phone = p_phone
LIMIT 1;
RETURN;
END IF;
END IF;

-- Aucun utilisateur trouv√©
RETURN QUERY SELECT false, NULL::uuid, NULL::text;
END;
$$;


ALTER FUNCTION public.check_existing_user(p_email text, p_phone text) OWNER TO postgres;

--
-- Name: check_phone_usage_count(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_phone_usage_count(p_phone text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN (SELECT COUNT(*) FROM public.profiles WHERE phone = p_phone);
END;
$$;


ALTER FUNCTION public.check_phone_usage_count(p_phone text) OWNER TO postgres;

--
-- Name: check_signup_fraud(text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_signup_fraud(p_email text, p_phone text, p_siret text, p_device_fingerprint text, p_ip_address text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    fraud_score INTEGER := 0;
    fraud_flags JSONB := '[]'::JSONB;
    is_suspicious BOOLEAN := FALSE;
BEGIN
    -- V√©rifier blacklist
    IF EXISTS (SELECT 1 FROM public.signup_blacklist WHERE type = 'email' AND value = p_email AND (expires_at IS NULL OR expires_at > NOW())) THEN
        fraud_flags := fraud_flags || jsonb_build_object('type', 'blacklist_email', 'severity', 'critical')::JSONB;
        fraud_score := fraud_score + 100;
    END IF;

    IF p_phone IS NOT NULL AND EXISTS (SELECT 1 FROM public.signup_blacklist WHERE type = 'phone' AND value = p_phone AND (expires_at IS NULL OR expires_at > NOW())) THEN
        fraud_flags := fraud_flags || jsonb_build_object('type', 'blacklist_phone', 'severity', 'critical')::JSONB;
        fraud_score := fraud_score + 100;
    END IF;

    IF p_siret IS NOT NULL AND EXISTS (SELECT 1 FROM public.signup_blacklist WHERE type = 'siret' AND value = p_siret AND (expires_at IS NULL OR expires_at > NOW())) THEN
        fraud_flags := fraud_flags || jsonb_build_object('type', 'blacklist_siret', 'severity', 'critical')::JSONB;
        fraud_score := fraud_score + 100;
    END IF;

    -- V√©rifier duplications SIRET (comptes existants)
    IF p_siret IS NOT NULL AND EXISTS (SELECT 1 FROM public.profiles WHERE siret = p_siret) THEN
        fraud_flags := fraud_flags || jsonb_build_object('type', 'siret_duplicate', 'severity', 'high')::JSONB;
        fraud_score := fraud_score + 50;
    END IF;

    -- V√©rifier duplications t√©l√©phone
    IF p_phone IS NOT NULL THEN
        IF (SELECT COUNT(*) FROM public.profiles WHERE phone = p_phone) >= 3 THEN
            fraud_flags := fraud_flags || jsonb_build_object('type', 'phone_multiple_accounts', 'severity', 'high')::JSONB;
            fraud_score := fraud_score + 40;
        ELSIF (SELECT COUNT(*) FROM public.profiles WHERE phone = p_phone) >= 1 THEN
            fraud_flags := fraud_flags || jsonb_build_object('type', 'phone_duplicate', 'severity', 'medium')::JSONB;
            fraud_score := fraud_score + 20;
        END IF;
    END IF;

    -- V√©rifier device fingerprint (m√™me appareil)
    IF p_device_fingerprint IS NOT NULL THEN
        IF (SELECT COUNT(*) FROM public.profiles WHERE device_fingerprint = p_device_fingerprint) >= 5 THEN
            fraud_flags := fraud_flags || jsonb_build_object('type', 'device_multiple_accounts', 'severity', 'high')::JSONB;
            fraud_score := fraud_score + 60;
        ELSIF (SELECT COUNT(*) FROM public.profiles WHERE device_fingerprint = p_device_fingerprint) >= 2 THEN
            fraud_flags := fraud_flags || jsonb_build_object('type', 'device_duplicate', 'severity', 'medium')::JSONB;
            fraud_score := fraud_score + 30;
        END IF;
    END IF;

    -- V√©rifier tentatives multiples depuis m√™me IP (rate limiting)
    IF (SELECT COUNT(*) FROM public.signup_attempts 
        WHERE ip_address = p_ip_address 
        AND created_at > NOW() - INTERVAL '1 hour') >= 5 THEN
        fraud_flags := fraud_flags || jsonb_build_object('type', 'ip_rate_limit', 'severity', 'medium')::JSONB;
        fraud_score := fraud_score + 30;
    END IF;

    -- V√©rifier pattern suspect (email jetable/temporaire)
    IF p_email ~* '(temp|throw|disposable|trash|fake|test|@guerrillamail|@10minutemail)' THEN
        fraud_flags := fraud_flags || jsonb_build_object('type', 'disposable_email', 'severity', 'high')::JSONB;
        fraud_score := fraud_score + 50;
    END IF;

    -- D√©terminer si suspicious
    is_suspicious := fraud_score >= 50;

    RETURN jsonb_build_object(
        'fraud_score', fraud_score,
        'is_suspicious', is_suspicious,
        'flags', fraud_flags,
        'recommendation', CASE 
            WHEN fraud_score >= 100 THEN 'block'
            WHEN fraud_score >= 50 THEN 'manual_review'
            ELSE 'allow'
        END
    );
END;
$$;


ALTER FUNCTION public.check_signup_fraud(p_email text, p_phone text, p_siret text, p_device_fingerprint text, p_ip_address text) OWNER TO postgres;

--
-- Name: FUNCTION check_signup_fraud(p_email text, p_phone text, p_siret text, p_device_fingerprint text, p_ip_address text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.check_signup_fraud(p_email text, p_phone text, p_siret text, p_device_fingerprint text, p_ip_address text) IS 'Analyse compl√®te anti-fraude retournant score et flags';


--
-- Name: check_signup_system_health(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_signup_system_health() RETURNS TABLE(component text, status text, details text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Check 1: Bucket avatars existe
  RETURN QUERY
  SELECT 
    'Storage Bucket'::TEXT,
    CASE WHEN EXISTS (SELECT 1 FROM storage.buckets WHERE id = 'avatars') 
      THEN 'OK'::TEXT 
      ELSE 'MISSING'::TEXT 
    END,
    CASE WHEN EXISTS (SELECT 1 FROM storage.buckets WHERE id = 'avatars') 
      THEN 'Bucket avatars exists'::TEXT
      ELSE 'Run: INSERT INTO storage.buckets (id, name, public) VALUES (''avatars'', ''avatars'', true)'::TEXT
    END;
  
  -- Check 2: Trigger handle_new_user existe
  RETURN QUERY
  SELECT 
    'Auth Trigger'::TEXT,
    CASE WHEN EXISTS (
      SELECT 1 FROM pg_trigger 
      WHERE tgname = 'on_auth_user_created'
    ) THEN 'OK'::TEXT ELSE 'MISSING'::TEXT END,
    CASE WHEN EXISTS (
      SELECT 1 FROM pg_trigger 
      WHERE tgname = 'on_auth_user_created'
    ) THEN 'Trigger configured'::TEXT
    ELSE 'Run: CREATE TRIGGER on_auth_user_created...'::TEXT END;
  
  -- Check 3: Fonctions RPC existent
  RETURN QUERY
  SELECT 
    'RPC Functions'::TEXT,
    CASE WHEN (
      SELECT COUNT(*) FROM pg_proc 
      WHERE proname IN ('check_email_available', 'check_siret_available', 'check_signup_fraud')
    ) = 3 THEN 'OK'::TEXT ELSE 'INCOMPLETE'::TEXT END,
    'check_email_available, check_siret_available, check_signup_fraud'::TEXT;
  
  -- Check 4: Tables existent
  RETURN QUERY
  SELECT 
    'Tables'::TEXT,
    CASE WHEN (
      SELECT COUNT(*) FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_name IN ('fraud_detection_logs', 'signup_blacklist', 'signup_attempts')
    ) = 3 THEN 'OK'::TEXT ELSE 'INCOMPLETE'::TEXT END,
    'fraud_detection_logs, signup_blacklist, signup_attempts'::TEXT;
  
  -- Check 5: Colonnes profiles existent
  RETURN QUERY
  SELECT 
    'Profile Columns'::TEXT,
    CASE WHEN (
      SELECT COUNT(*) FROM information_schema.columns 
      WHERE table_name = 'profiles' 
      AND column_name IN ('user_type', 'siret', 'device_fingerprint', 'company', 'bank_iban')
    ) = 5 THEN 'OK'::TEXT ELSE 'INCOMPLETE'::TEXT END,
    'user_type, siret, device_fingerprint, company, bank_iban'::TEXT;
  
  RETURN;
END;
$$;


ALTER FUNCTION public.check_signup_system_health() OWNER TO postgres;

--
-- Name: FUNCTION check_signup_system_health(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.check_signup_system_health() IS 'Diagnostic: v√©rifie que tous les composants sont configur√©s';


--
-- Name: check_siret_available(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_siret_available(p_siret text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN NOT EXISTS (SELECT 1 FROM public.profiles WHERE siret = p_siret);
END;
$$;


ALTER FUNCTION public.check_siret_available(p_siret text) OWNER TO postgres;

--
-- Name: check_trip_full(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_trip_full() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  total_booked INTEGER;
  available INTEGER;
BEGIN
  -- Calculer le total de places r√©serv√©es
  SELECT 
    COALESCE(SUM(seats_booked), 0),
    t.available_seats
  INTO total_booked, available
  FROM covoiturage_bookings b
  JOIN covoiturage_trips t ON t.id = b.trip_id
  WHERE b.trip_id = NEW.trip_id
    AND b.status IN ('pending', 'confirmed')
  GROUP BY t.available_seats;
  
  -- Si toutes les places sont prises, marquer comme complet
  IF total_booked >= available THEN
    UPDATE covoiturage_trips
    SET status = 'full'
    WHERE id = NEW.trip_id;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.check_trip_full() OWNER TO postgres;

--
-- Name: claim_mission(text, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.claim_mission(p_code text, p_user_id uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_clean TEXT := UPPER(REGEXP_REPLACE(p_code, '[^A-Za-z0-9]', '', 'g'));
  v_mission_id UUID;
  v_creator_id UUID;
  v_status TEXT;
  v_share_code TEXT;
  v_current_assigned UUID;
  v_reference TEXT;
BEGIN
  -- Trouver la mission par code normalis√©
  SELECT id, user_id, status, share_code, assigned_user_id, reference
  INTO v_mission_id, v_creator_id, v_status, v_share_code, v_current_assigned, v_reference
  FROM public.missions
  WHERE normalized_share_code = v_clean
  FOR UPDATE;

  -- V√©rifications
  IF v_mission_id IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Code invalide', 'message', 'Aucune mission trouv√©e avec ce code');
  END IF;

  IF v_creator_id = p_user_id THEN
    RETURN json_build_object('success', false, 'error', 'Mission propre', 'message', 'Vous ne pouvez pas rejoindre votre propre mission');
  END IF;

  IF v_status IN ('completed', 'cancelled', 'canceled') THEN
    RETURN json_build_object('success', false, 'error', 'Mission termin√©e', 'message', 'Cette mission est d√©j√† termin√©e ou annul√©e', 'status', v_status);
  END IF;

  IF v_current_assigned IS NOT NULL AND v_current_assigned <> p_user_id THEN
    RETURN json_build_object('success', false, 'error', 'Mission d√©j√† assign√©e', 'message', 'Cette mission est d√©j√† assign√©e √† quelqu''un d''autre');
  END IF;

  -- Idempotent: d√©j√† assign√©e √† cet utilisateur
  IF v_current_assigned = p_user_id THEN
    RETURN json_build_object(
      'success', true,
      'alreadyJoined', true,
      'mission_id', v_mission_id,
      'share_code', v_share_code,
      'status', v_status,
      'message', 'Mission d√©j√† pr√©sente dans votre liste',
      'mission', json_build_object(
        'id', v_mission_id,
        'reference', v_reference
      )
    );
  END IF;

  -- Assigner la mission SANS changer le statut
  -- Le statut reste 'pending' jusqu'√† ce que l'inspection de d√©part commence
  UPDATE public.missions 
  SET 
    assigned_user_id = p_user_id,
    -- NE PAS changer le statut ici, il passera en 'in_progress' au d√©marrage de l'inspection
    updated_at = now()
  WHERE id = v_mission_id;

  -- Relire le statut
  SELECT status INTO v_status FROM public.missions WHERE id = v_mission_id;

  RETURN json_build_object(
    'success', true,
    'mission_id', v_mission_id,
    'share_code', v_share_code,
    'status', v_status,
    'message', 'Mission ajout√©e √† votre liste',
    'mission', json_build_object(
      'id', v_mission_id,
      'reference', v_reference
    )
  );

EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('success', false, 'error', 'Erreur serveur', 'message', SQLERRM);
END;
$$;


ALTER FUNCTION public.claim_mission(p_code text, p_user_id uuid) OWNER TO postgres;

--
-- Name: cleanup_expired_alerts(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_expired_alerts() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE navigation_alerts
SET is_active = false
WHERE expires_at < now()
AND is_active = true;
END;
$$;


ALTER FUNCTION public.cleanup_expired_alerts() OWNER TO postgres;

--
-- Name: cleanup_expired_phone_verifications(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_expired_phone_verifications() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  DELETE FROM phone_verifications 
  WHERE created_at < NOW() - INTERVAL '1 hour';
END;
$$;


ALTER FUNCTION public.cleanup_expired_phone_verifications() OWNER TO postgres;

--
-- Name: cleanup_expired_tracking_links(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_expired_tracking_links() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_count INTEGER;
BEGIN
  -- D√©sactiver liens expir√©s
  UPDATE public_tracking_links
  SET is_active = false
  WHERE expires_at < NOW() 
  AND is_active = true;
  
  GET DIAGNOSTICS v_count = ROW_COUNT;
  
  RAISE NOTICE '‚úÖ % liens expir√©s d√©sactiv√©s', v_count;
  RETURN v_count;
END;
$$;


ALTER FUNCTION public.cleanup_expired_tracking_links() OWNER TO postgres;

--
-- Name: cleanup_inactive_tracking(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_inactive_tracking() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_count INTEGER;
BEGIN
  -- D√©sactiver positions inactives depuis > 2 heures
  UPDATE mission_tracking_live
  SET is_active = false
  WHERE last_update < NOW() - INTERVAL '2 hours'
  AND is_active = true;
  
  GET DIAGNOSTICS v_count = ROW_COUNT;
  
  RAISE NOTICE '‚úÖ % positions d√©sactiv√©es (inactives > 2h)', v_count;
  RETURN v_count;
END;
$$;


ALTER FUNCTION public.cleanup_inactive_tracking() OWNER TO postgres;

--
-- Name: cleanup_old_ai_requests(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_old_ai_requests() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  DELETE FROM public.ai_requests_usage
  WHERE created_at < NOW() - INTERVAL '12 months';
END;
$$;


ALTER FUNCTION public.cleanup_old_ai_requests() OWNER TO postgres;

--
-- Name: cleanup_old_documents(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_old_documents() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Supprimer les documents de plus de 1 an
    DELETE FROM unified_scanned_documents
    WHERE created_at < NOW() - INTERVAL '1 year';
END;
$$;


ALTER FUNCTION public.cleanup_old_documents() OWNER TO postgres;

--
-- Name: cleanup_old_gps_data(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_old_gps_data(p_retention_days integer DEFAULT 90) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_deleted INTEGER;
BEGIN
  DELETE FROM gps_location_points
  WHERE recorded_at < NOW() - (p_retention_days || ' days')::INTERVAL;
  
  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  
  RETURN v_deleted;
END;
$$;


ALTER FUNCTION public.cleanup_old_gps_data(p_retention_days integer) OWNER TO postgres;

--
-- Name: cleanup_old_pdfs(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_old_pdfs(days_old integer DEFAULT 30) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_deleted_count INTEGER;
BEGIN
  -- Supprimer les PDFs de plus de X jours et jamais t√©l√©charg√©s
  WITH deleted AS (
    DELETE FROM inspection_pdfs
    WHERE generated_at < NOW() - (days_old || ' days')::INTERVAL
    AND last_downloaded_at IS NULL
    RETURNING *
  )
  SELECT COUNT(*) INTO v_deleted_count FROM deleted;
  
  RAISE NOTICE 'Deleted % old PDFs', v_deleted_count;
  RETURN v_deleted_count;
END;
$$;


ALTER FUNCTION public.cleanup_old_pdfs(days_old integer) OWNER TO postgres;

--
-- Name: FUNCTION cleanup_old_pdfs(days_old integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.cleanup_old_pdfs(days_old integer) IS 'Nettoie les PDFs non t√©l√©charg√©s de plus de X jours';


--
-- Name: cleanup_old_tracking_history(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_old_tracking_history() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_count INTEGER;
BEGIN
  -- Supprimer historique > 7 jours
  DELETE FROM mission_tracking_history
  WHERE recorded_at < NOW() - INTERVAL '7 days';
  
  GET DIAGNOSTICS v_count = ROW_COUNT;
  
  RAISE NOTICE '‚úÖ % enregistrements historiques supprim√©s (> 7 jours)', v_count;
  RETURN v_count;
END;
$$;


ALTER FUNCTION public.cleanup_old_tracking_history() OWNER TO postgres;

--
-- Name: close_mission_after_arrival(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.close_mission_after_arrival(p_mission_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_mission record;
  v_user_id uuid;
BEGIN
  -- R√©cup√©rer l'utilisateur actuel
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Non authentifi√©'
    );
  END IF;

  -- R√©cup√©rer la mission
  SELECT * INTO v_mission
  FROM missions
  WHERE id = p_mission_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Mission introuvable'
    );
  END IF;

  -- Pas de v√©rification de droits stricte
  -- Si l'utilisateur authentifi√© a pu cr√©er l'inspection, il peut cl√¥turer
  -- (L'inspection elle-m√™me est prot√©g√©e par RLS)
  
  -- V√©rification: cr√©ateur OU a cr√©√© une inspection pour cette mission
  IF v_user_id != v_mission.user_id THEN
    -- V√©rifier si l'utilisateur a cr√©√© une inspection pour cette mission
    -- via la table vehicle_inspections (inspector_id li√© √† profiles)
    IF NOT EXISTS (
      SELECT 1 
      FROM vehicle_inspections vi
      INNER JOIN profiles p ON vi.inspector_id = p.id
      WHERE vi.mission_id = p_mission_id
      AND p.id = v_user_id
    ) THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Non autoris√©: vous n''avez pas d''inspection sur cette mission'
      );
    END IF;
  END IF;

  -- Mettre √† jour la mission (bypass RLS gr√¢ce √† SECURITY DEFINER)
  -- Les inspections sont d√©j√† li√©es via departure_inspection_id et arrival_inspection_id
  UPDATE missions
  SET 
    status = 'completed',
    updated_at = now()
  WHERE id = p_mission_id;

  RETURN jsonb_build_object(
    'success', true,
    'mission_id', p_mission_id,
    'message', 'Mission cl√¥tur√©e avec succ√®s'
  );

EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$$;


ALTER FUNCTION public.close_mission_after_arrival(p_mission_id uuid) OWNER TO postgres;

--
-- Name: complete_mission(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.complete_mission(p_mission_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_exists BOOLEAN;
BEGIN
  SELECT TRUE INTO v_exists FROM public.missions WHERE id = p_mission_id;
  IF NOT FOUND THEN
    RETURN jsonb_build_object('ok', false, 'error', 'Mission introuvable');
  END IF;

  -- Tenter de mettre √† jour status + completed_at si pr√©sent
  BEGIN
    UPDATE public.missions
    SET status = 'completed',
        completed_at = NOW()
    WHERE id = p_mission_id;
  EXCEPTION WHEN undefined_column THEN
    -- completed_at n'existe pas, faire une mise √† jour minimale
    UPDATE public.missions
    SET status = 'completed'
    WHERE id = p_mission_id;
  END;

  RETURN jsonb_build_object('ok', true);
END;
$$;


ALTER FUNCTION public.complete_mission(p_mission_id uuid) OWNER TO postgres;

--
-- Name: compute_planning_expires_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.compute_planning_expires_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- expires_at = planning_date + end_time + flexibility_minutes
  NEW.expires_at := (NEW.planning_date + NEW.end_time) + 
    (COALESCE(NEW.flexibility_minutes, 30) * INTERVAL '1 minute');
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.compute_planning_expires_at() OWNER TO postgres;

--
-- Name: FUNCTION compute_planning_expires_at(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.compute_planning_expires_at() IS 'Trigger: calcule expires_at = date + end_time + flexibility';


--
-- Name: convert_quote_to_mission(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.convert_quote_to_mission(quote_id uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  new_mission_id UUID;
  quote_data RECORD;
BEGIN
  -- R√©cup√©rer les donn√©es du devis
  SELECT * INTO quote_data
  FROM quotes
  WHERE id = quote_id AND status = 'accepted';

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Quote not found or not accepted';
  END IF;

  -- G√©n√©rer un ID de mission (placeholder)
  new_mission_id := gen_random_uuid();

  -- TODO: Cr√©er la mission selon votre sch√©ma
  -- D√©commentez et adaptez selon vos tables missions/mission_routes
  -- INSERT INTO missions (id, user_id, client_id, status, notes)
  -- VALUES (new_mission_id, quote_data.user_id, quote_data.client_id, 'pending', 
  --         'Cr√©√© depuis devis ' || quote_data.quote_number);

  -- Marquer le devis comme converti
  UPDATE quotes
  SET 
    converted_to_mission_id = new_mission_id,
    status = 'converted',
    converted_at = NOW()
  WHERE id = quote_id;

  RETURN new_mission_id;
END;
$$;


ALTER FUNCTION public.convert_quote_to_mission(quote_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION convert_quote_to_mission(quote_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.convert_quote_to_mission(quote_id uuid) IS 'Convertit un devis accept√© en mission (√† adapter selon votre sch√©ma missions)';


--
-- Name: create_calendar_event_on_assignment(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_calendar_event_on_assignment() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_mission_title text;
  v_mission_date timestamptz;
BEGIN
  SELECT title, scheduled_date INTO v_mission_title, v_mission_date
  FROM missions
  WHERE id = NEW.mission_id;

  INSERT INTO calendar_events (
    user_id,
    contact_id,
    mission_id,
    title,
    description,
    start_date,
    end_date,
    event_type,
    color
  ) VALUES (
    NEW.user_id,
    NEW.contact_id,
    NEW.mission_id,
    v_mission_title,
    'Mission assign√©e - ' || COALESCE(NEW.notes, ''),
    v_mission_date,
    v_mission_date + interval '4 hours',
    'mission',
    '#14b8a6'
  );

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.create_calendar_event_on_assignment() OWNER TO postgres;

--
-- Name: create_contact_invitation(uuid, uuid, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_contact_invitation(p_inviter_id uuid, p_invited_user_id uuid, p_contact_type text, p_name text, p_email text, p_phone text, p_company text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_contact_id uuid;
BEGIN
  -- V√©rifier si une invitation existe d√©j√†
  IF EXISTS (
    SELECT 1 FROM contacts 
    WHERE user_id = p_inviter_id 
    AND invited_user_id = p_invited_user_id
  ) THEN
    RETURN json_build_object(
      'success', false,
      'message', 'Invitation d√©j√† envoy√©e'
    );
  END IF;

  -- V√©rifier si une invitation inverse existe
  IF EXISTS (
    SELECT 1 FROM contacts 
    WHERE user_id = p_invited_user_id 
    AND invited_user_id = p_inviter_id
  ) THEN
    RETURN json_build_object(
      'success', false,
      'message', 'L''utilisateur vous a d√©j√† envoy√© une invitation'
    );
  END IF;

  -- Cr√©er le contact avec statut pending
  INSERT INTO contacts (
    user_id,
    invited_by,
    invited_user_id,
    type,
    name,
    email,
    phone,
    company,
    invitation_status,
    invitation_sent_at
  ) VALUES (
    p_inviter_id,
    p_inviter_id,
    p_invited_user_id,
    p_contact_type,
    p_name,
    p_email,
    p_phone,
    COALESCE(p_company, ''),
    'pending',
    now()
  ) RETURNING id INTO v_contact_id;

  RETURN json_build_object(
    'success', true,
    'contact_id', v_contact_id,
    'message', 'Invitation envoy√©e avec succ√®s'
  );
END;
$$;


ALTER FUNCTION public.create_contact_invitation(p_inviter_id uuid, p_invited_user_id uuid, p_contact_type text, p_name text, p_email text, p_phone text, p_company text) OWNER TO postgres;

--
-- Name: create_contact_request(uuid, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_contact_request(p_requester_id uuid, p_target_email text, p_target_name text DEFAULT NULL::text, p_message text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_request_id uuid;
  v_existing_request uuid;
BEGIN
  -- V√©rifier s'il existe d√©j√† une demande en attente
  SELECT id INTO v_existing_request
  FROM public.contact_requests
  WHERE requester_id = p_requester_id 
    AND target_email = p_target_email
    AND status = 'pending'
  LIMIT 1;
  
  IF v_existing_request IS NOT NULL THEN
    -- Une demande existe d√©j√†
    RETURN v_existing_request;
  END IF;
  
  -- Cr√©er la nouvelle demande
  INSERT INTO public.contact_requests (
    requester_id,
    target_email,
    target_name,
    message,
    status
  )
  VALUES (
    p_requester_id,
    p_target_email,
    p_target_name,
    p_message,
    'pending'
  )
  RETURNING id INTO v_request_id;
  
  RETURN v_request_id;
END;
$$;


ALTER FUNCTION public.create_contact_request(p_requester_id uuid, p_target_email text, p_target_name text, p_message text) OWNER TO postgres;

--
-- Name: create_or_get_inspection_share(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_or_get_inspection_share(p_mission_id uuid, p_user_id uuid, p_report_type text) RETURNS TABLE(share_url text, share_token text, created_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_token TEXT;
  v_existing_record RECORD;
BEGIN
  -- V√©rifier si un partage existe d√©j√†
  SELECT * INTO v_existing_record
  FROM public.inspection_report_shares
  WHERE mission_id = p_mission_id
    AND report_type = p_report_type
    AND is_active = TRUE;

  -- Si existe, retourner le lien existant
  IF FOUND THEN
    RETURN QUERY SELECT 
      'https://www.xcrackz.com/rapport-inspection/' || v_existing_record.share_token AS share_url,
      v_existing_record.share_token,
      v_existing_record.created_at;
    RETURN;
  END IF;

  -- Sinon, cr√©er un nouveau token
  v_token := encode(gen_random_bytes(16), 'base64');
  v_token := replace(replace(replace(v_token, '/', ''), '+', ''), '=', '');

  -- Ins√©rer le nouveau partage
  INSERT INTO public.inspection_report_shares (
    mission_id,
    user_id,
    share_token,
    report_type
  ) VALUES (
    p_mission_id,
    p_user_id,
    v_token,
    p_report_type
  );

  -- Retourner le lien
  RETURN QUERY SELECT 
    'https://www.xcrackz.com/rapport-inspection/' || v_token AS share_url,
    v_token,
    NOW();
END;
$$;


ALTER FUNCTION public.create_or_get_inspection_share(p_mission_id uuid, p_user_id uuid, p_report_type text) OWNER TO postgres;

--
-- Name: create_or_update_public_report(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_or_update_public_report(p_mission_id uuid, p_user_id uuid DEFAULT auth.uid()) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_report_id uuid;
  v_share_token text;
  v_departure_id uuid;
  v_arrival_id uuid;
  v_existing_record public_inspection_reports;
BEGIN
  -- R√©cup√©rer les IDs des inspections
  SELECT 
    departure_inspection_id,
    arrival_inspection_id
  INTO v_departure_id, v_arrival_id
  FROM missions
  WHERE id = p_mission_id;

  -- V√©rifier si un rapport existe d√©j√† pour cette mission
  SELECT * INTO v_existing_record
  FROM public_inspection_reports
  WHERE mission_id = p_mission_id
  LIMIT 1;

  IF v_existing_record IS NOT NULL THEN
    -- Mettre √† jour le rapport existant
    UPDATE public_inspection_reports
    SET 
      departure_inspection_id = v_departure_id,
      arrival_inspection_id = v_arrival_id,
      updated_at = now()
    WHERE id = v_existing_record.id
    RETURNING id, share_token INTO v_report_id, v_share_token;
  ELSE
    -- Cr√©er un nouveau rapport
    INSERT INTO public_inspection_reports (
      mission_id,
      departure_inspection_id,
      arrival_inspection_id,
      created_by
    ) VALUES (
      p_mission_id,
      v_departure_id,
      v_arrival_id,
      p_user_id
    )
    RETURNING id, share_token INTO v_report_id, v_share_token;
  END IF;

  -- Retourner le r√©sultat
  RETURN jsonb_build_object(
    'success', true,
    'report_id', v_report_id,
    'share_token', v_share_token,
    'share_url', 'https://xcrackz.com/rapport/' || v_share_token
  );
END;
$$;


ALTER FUNCTION public.create_or_update_public_report(p_mission_id uuid, p_user_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION create_or_update_public_report(p_mission_id uuid, p_user_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.create_or_update_public_report(p_mission_id uuid, p_user_id uuid) IS 'Cr√©e ou met √† jour un rapport public pour une mission. G√©n√®re automatiquement un token unique.';


--
-- Name: create_profile_for_existing_user(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_profile_for_existing_user(user_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  user_record RECORD;
BEGIN
  -- R√©cup√©rer l'utilisateur
  SELECT * INTO user_record FROM auth.users WHERE id = user_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'User % not found', user_id;
  END IF;
  
  -- Cr√©er le profil si inexistant
  INSERT INTO public.profiles (
    id,
    email,
    full_name,
    created_at
  )
  VALUES (
    user_id,
    user_record.email,
    COALESCE(user_record.raw_user_meta_data->>'full_name', split_part(user_record.email, '@', 1)),
    NOW()
  )
  ON CONFLICT (id) DO NOTHING;
  
  RAISE NOTICE 'Profile created for user %', user_id;
END;
$$;


ALTER FUNCTION public.create_profile_for_existing_user(user_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION create_profile_for_existing_user(user_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.create_profile_for_existing_user(user_id uuid) IS 'Backup: cr√©e profil manuellement pour un utilisateur existant';


--
-- Name: daily_tracking_cleanup(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.daily_tracking_cleanup() RETURNS TABLE(inactive_count integer, history_count integer, links_count integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cleanup_inactive_tracking(),
    cleanup_old_tracking_history(),
    cleanup_expired_tracking_links();
END;
$$;


ALTER FUNCTION public.daily_tracking_cleanup() OWNER TO postgres;

--
-- Name: FUNCTION daily_tracking_cleanup(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.daily_tracking_cleanup() IS 'Nettoyage quotidien complet - √Ä planifier avec pg_cron';


--
-- Name: deactivate_unpopular_alerts(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.deactivate_unpopular_alerts() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE navigation_alerts
SET is_active = false
WHERE downvotes > upvotes * 2
AND downvotes >= 5
AND is_active = true;
END;
$$;


ALTER FUNCTION public.deactivate_unpopular_alerts() OWNER TO postgres;

--
-- Name: deduct_credits(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.deduct_credits(p_user_id uuid, p_amount integer) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  current_credits INTEGER;
BEGIN
  -- V√©rifier le solde actuel
  SELECT credits INTO current_credits
  FROM user_credits
  WHERE user_id = p_user_id;
  
  IF current_credits IS NULL THEN
    RAISE EXCEPTION 'User credits record not found for user %', p_user_id;
  END IF;
  
  IF current_credits < p_amount THEN
    RAISE EXCEPTION 'Insufficient credits. Current: %, Required: %', current_credits, p_amount;
  END IF;
  
  -- D√©duire les cr√©dits
  UPDATE user_credits
  SET 
    credits = credits - p_amount,
    updated_at = NOW()
  WHERE user_id = p_user_id;
  
  RAISE NOTICE 'D√©duit % cr√©dits pour user %. Nouveau solde: %', p_amount, p_user_id, (current_credits - p_amount);
END;
$$;


ALTER FUNCTION public.deduct_credits(p_user_id uuid, p_amount integer) OWNER TO postgres;

--
-- Name: deduct_credits(uuid, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.deduct_credits(p_user_id uuid, p_amount integer, p_description text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_current_credits INTEGER;
    v_new_balance INTEGER;
BEGIN
    SELECT credits INTO v_current_credits
    FROM profiles
    WHERE id = p_user_id
    FOR UPDATE;

    IF v_current_credits < p_amount THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Cr√©dits insuffisants',
            'current_credits', v_current_credits,
            'required', p_amount
        );
    END IF;

    UPDATE profiles
    SET credits = credits - p_amount
    WHERE id = p_user_id
    RETURNING credits INTO v_new_balance;

    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'credit_transactions') THEN
        INSERT INTO credit_transactions (user_id, transaction_type, amount, balance_after, description, reference_id, reference_type, created_at)
        VALUES (p_user_id, 'deduction', -p_amount, v_new_balance, p_description, NULL, NULL, NOW());
    END IF;

    RETURN json_build_object(
        'success', true,
        'new_balance', v_new_balance,
        'deducted', p_amount
    );
END;
$$;


ALTER FUNCTION public.deduct_credits(p_user_id uuid, p_amount integer, p_description text) OWNER TO postgres;

--
-- Name: deduct_credits(uuid, text, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.deduct_credits(p_user_id uuid, p_feature_key text, p_reference_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
v_cost integer;
v_current_balance integer;
v_free_from_plan text;
v_user_plan text;
v_is_free boolean := false;
v_has_free_tracking boolean := false;
BEGIN
-- R√©cup√©rer le co√ªt de la fonctionnalit√©
SELECT credit_cost, free_from_plan
INTO v_cost, v_free_from_plan
FROM feature_costs
WHERE feature_key = p_feature_key AND is_active = true;

IF NOT FOUND THEN
RETURN jsonb_build_object('success', false, 'error', 'Feature not found');
END IF;

-- R√©cup√©rer le solde actuel
SELECT balance INTO v_current_balance
FROM user_credits
WHERE user_id = p_user_id;

IF NOT FOUND THEN
RETURN jsonb_build_object('success', false, 'error', 'User credits not found');
END IF;

-- V√©rifier si l'utilisateur a un plan avec cette fonctionnalit√© gratuite
SELECT cp.name, cp.free_tracking
INTO v_user_plan, v_has_free_tracking
FROM subscriptions s
JOIN credits_packages cp ON cp.id = s.package_id
WHERE s.user_id = p_user_id
AND s.status = 'active'
AND s.current_period_end > now()
ORDER BY s.created_at DESC
LIMIT 1;

-- V√©rifier si la fonctionnalit√© est gratuite pour ce plan
IF v_free_from_plan IS NOT NULL THEN
IF (v_free_from_plan = 'pro' AND v_user_plan IN ('Pro', 'Business', 'Enterprise')) OR
(v_free_from_plan = 'business' AND v_user_plan IN ('Business', 'Enterprise')) OR
(v_free_from_plan = 'enterprise' AND v_user_plan = 'Enterprise') THEN
v_is_free := true;
END IF;
END IF;

-- Cas sp√©cial tracking GPS
IF p_feature_key = 'tracking_location' AND v_has_free_tracking = true THEN
v_is_free := true;
END IF;

-- D√©duire les cr√©dits si pas gratuit
IF NOT v_is_free THEN
IF v_current_balance < v_cost THEN
RETURN jsonb_build_object('success', false, 'error', 'Insufficient credits');
END IF;

UPDATE user_credits
SET balance = balance - v_cost
WHERE user_id = p_user_id;
END IF;

-- Logger l'utilisation
INSERT INTO credit_usage_log (user_id, feature_key, credits_used, was_free, reference_id)
VALUES (p_user_id, p_feature_key, CASE WHEN v_is_free THEN 0 ELSE v_cost END, v_is_free, p_reference_id);

RETURN jsonb_build_object(
'success', true,
'credits_used', CASE WHEN v_is_free THEN 0 ELSE v_cost END,
'was_free', v_is_free,
'new_balance', v_current_balance - CASE WHEN v_is_free THEN 0 ELSE v_cost END
);
END;
$$;


ALTER FUNCTION public.deduct_credits(p_user_id uuid, p_feature_key text, p_reference_id uuid) OWNER TO postgres;

--
-- Name: delete_availability(uuid, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.delete_availability(p_user_id uuid, p_date date) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  DELETE FROM availability_calendar 
  WHERE user_id = p_user_id 
    AND date = p_date;

  IF FOUND THEN
    RETURN json_build_object(
      'success', true,
      'message', 'Disponibilit√© supprim√©e'
    );
  ELSE
    RETURN json_build_object(
      'success', false,
      'message', 'Aucune disponibilit√© trouv√©e pour cette date'
    );
  END IF;
END;
$$;


ALTER FUNCTION public.delete_availability(p_user_id uuid, p_date date) OWNER TO postgres;

--
-- Name: detect_stop_zones(uuid, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.detect_stop_zones(p_session_id uuid, p_min_duration_minutes integer DEFAULT 5, p_max_speed_kmh double precision DEFAULT 5.0) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_count INTEGER := 0;
BEGIN
  -- Identifier s√©quences o√π vitesse < 5 km/h pendant 5+ minutes
  INSERT INTO gps_stop_zones (
    session_id,
    start_time,
    end_time,
    duration_minutes,
    latitude,
    longitude,
    location
  )
  WITH stop_sequences AS (
    SELECT 
      session_id,
      MIN(recorded_at) as start_time,
      MAX(recorded_at) as end_time,
      EXTRACT(EPOCH FROM (MAX(recorded_at) - MIN(recorded_at))) / 60 as duration_minutes,
      AVG(latitude) as avg_lat,
      AVG(longitude) as avg_lng,
      COUNT(*) as point_count
    FROM gps_location_points
    WHERE session_id = p_session_id
      AND (speed_kmh IS NULL OR speed_kmh < p_max_speed_kmh)
      AND is_valid = TRUE
    GROUP BY session_id, 
      -- Grouper par proximit√© temporelle (gaps > 2 minutes s√©parent les groupes)
      recorded_at - (ROW_NUMBER() OVER (ORDER BY recorded_at) * INTERVAL '2 seconds')
    HAVING EXTRACT(EPOCH FROM (MAX(recorded_at) - MIN(recorded_at))) / 60 >= p_min_duration_minutes
  )
  SELECT 
    session_id,
    start_time,
    end_time,
    duration_minutes::INTEGER,
    avg_lat,
    avg_lng,
    ST_SetSRID(ST_MakePoint(avg_lng, avg_lat), 4326)
  FROM stop_sequences
  ON CONFLICT DO NOTHING;
  
  GET DIAGNOSTICS v_count = ROW_COUNT;
  
  RETURN v_count;
END;
$$;


ALTER FUNCTION public.detect_stop_zones(p_session_id uuid, p_min_duration_minutes integer, p_max_speed_kmh double precision) OWNER TO postgres;

--
-- Name: detect_suspicious_behavior(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.detect_suspicious_behavior(p_email text, p_phone text, p_ip_address text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
v_recent_attempts integer;
v_same_phone_count integer;
BEGIN
-- Compter les tentatives r√©centes depuis la m√™me IP
SELECT COUNT(*)
INTO v_recent_attempts
FROM account_creation_attempts
WHERE ip_address = p_ip_address
AND attempt_date > now() - interval '1 hour';

-- Plus de 5 tentatives en 1h depuis la m√™me IP
IF v_recent_attempts > 5 THEN
INSERT INTO suspicious_accounts (email, phone, reason, severity)
VALUES (
p_email,
p_phone,
format('Trop de tentatives depuis IP %s: %s tentatives en 1h', p_ip_address, v_recent_attempts),
'high'
);
END IF;

-- V√©rifier si le m√™me t√©l√©phone a √©t√© utilis√© pour plusieurs comptes
IF p_phone IS NOT NULL AND p_phone != '' THEN
SELECT COUNT(DISTINCT email)
INTO v_same_phone_count
FROM account_creation_attempts
WHERE phone = p_phone
AND success = true;

IF v_same_phone_count > 1 THEN
INSERT INTO suspicious_accounts (email, phone, reason, severity)
VALUES (
p_email,
p_phone,
format('M√™me t√©l√©phone utilis√© pour %s comptes diff√©rents', v_same_phone_count),
'medium'
);
END IF;
END IF;
END;
$$;


ALTER FUNCTION public.detect_suspicious_behavior(p_email text, p_phone text, p_ip_address text) OWNER TO postgres;

--
-- Name: distribute_subscription_credits(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.distribute_subscription_credits() RETURNS TABLE(user_email text, plan text, credits_added integer, auto_renew boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_count INTEGER := 0;
    v_sub RECORD;
BEGIN
    -- Cr√©er une table temporaire pour les r√©sultats
    CREATE TEMP TABLE IF NOT EXISTS temp_distribution_results (
        user_email text,
        plan text,
        credits_added integer,
        auto_renew boolean
    ) ON COMMIT DROP;

    -- R√©cup√©rer tous les abonnements actifs avec auto_renew = true
    FOR v_sub IN 
        SELECT 
            s.id,
            s.user_id,
            s.plan,
            s.auto_renew,
            s.current_period_end,
            p.email,
            CASE s.plan
                WHEN 'free' THEN 0
                WHEN 'starter' THEN 10
                WHEN 'basic' THEN 25        -- 19.99‚Ç¨/mois
                WHEN 'pro' THEN 100         -- 49.99‚Ç¨/mois
                WHEN 'business' THEN 500    -- 79.99‚Ç¨/mois
                WHEN 'enterprise' THEN 500  -- 79.99‚Ç¨/mois
                ELSE 0
            END as monthly_credits
        FROM subscriptions s
        JOIN profiles p ON p.id = s.user_id
        WHERE s.status = 'active'
        AND s.auto_renew = true  -- NOUVEAU : Seulement si auto_renew activ√©
        AND (s.current_period_end IS NULL OR s.current_period_end > NOW())
        AND s.plan != 'free'
    LOOP
        -- Ajouter les cr√©dits mensuels dans profiles
        UPDATE profiles
        SET credits = COALESCE(credits, 0) + v_sub.monthly_credits
        WHERE id = v_sub.user_id;
        
        -- Synchroniser user_credits
        UPDATE user_credits
        SET balance = COALESCE(balance, 0) + v_sub.monthly_credits
        WHERE user_id = v_sub.user_id;
        
        -- Si user_credits n'existe pas, cr√©er
        INSERT INTO user_credits (user_id, balance)
        VALUES (v_sub.user_id, v_sub.monthly_credits)
        ON CONFLICT (user_id) DO NOTHING;
        
        -- Ajouter au r√©sultat
        INSERT INTO temp_distribution_results VALUES (
            v_sub.email,
            v_sub.plan,
            v_sub.monthly_credits,
            v_sub.auto_renew
        );
        
        v_count := v_count + 1;
        
        RAISE NOTICE 'Ajout√© % cr√©dits √† % (plan: %, auto_renew: true)', 
            v_sub.monthly_credits, v_sub.email, v_sub.plan;
    END LOOP;
    
    RAISE NOTICE 'Distribution termin√©e : % abonnements trait√©s', v_count;
    
    -- Retourner les r√©sultats
    RETURN QUERY SELECT * FROM temp_distribution_results;
END;
$$;


ALTER FUNCTION public.distribute_subscription_credits() OWNER TO postgres;

--
-- Name: expire_old_quotes(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.expire_old_quotes() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  expired_count INTEGER;
BEGIN
  UPDATE quotes
  SET status = 'expired'
  WHERE status IN ('draft', 'sent')
    AND valid_until < CURRENT_DATE;
  
  GET DIAGNOSTICS expired_count = ROW_COUNT;
  RETURN expired_count;
END;
$$;


ALTER FUNCTION public.expire_old_quotes() OWNER TO postgres;

--
-- Name: expire_old_ride_entries(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.expire_old_ride_entries() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Expirer les offres dont la date de d√©part est pass√©e depuis 24h
  UPDATE ride_offers 
  SET status = 'expired', updated_at = NOW()
  WHERE status IN ('active') 
    AND departure_date < CURRENT_DATE - INTERVAL '1 day';
    
  -- Expirer les demandes dont la date est pass√©e depuis 24h
  UPDATE ride_requests 
  SET status = 'expired', updated_at = NOW()
  WHERE status IN ('active')
    AND needed_date < CURRENT_DATE - INTERVAL '1 day';
    
  -- Expirer les matchs propos√©s non r√©pondus depuis +48h
  UPDATE ride_matches
  SET status = 'expired', updated_at = NOW()
  WHERE status = 'proposed'
    AND created_at < NOW() - INTERVAL '48 hours';
END;
$$;


ALTER FUNCTION public.expire_old_ride_entries() OWNER TO postgres;

--
-- Name: FUNCTION expire_old_ride_entries(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.expire_old_ride_entries() IS 'Expire automatiquement les offres/demandes/matchs p√©rim√©s';


--
-- Name: find_planning_matches(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.find_planning_matches(p_planning_id uuid) RETURNS TABLE(matched_planning_id uuid, matched_user_id uuid, match_score integer, match_type text, distance_km double precision, time_overlap_minutes integer, potential_km_saved double precision)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_planning RECORD;
  v_earth_radius CONSTANT DOUBLE PRECISION := 6371; -- km
BEGIN
  -- R√©cup√©rer le planning source
  SELECT * INTO v_planning FROM convoy_plannings WHERE id = p_planning_id;
  
  IF v_planning IS NULL THEN
    RETURN;
  END IF;

  RETURN QUERY
  WITH source AS (
    SELECT 
      v_planning.id AS src_id,
      v_planning.user_id AS src_user,
      v_planning.planning_date AS src_date,
      v_planning.start_time AS src_start,
      v_planning.end_time AS src_end,
      v_planning.flexibility_minutes AS src_flex,
      v_planning.origin_lat AS src_o_lat,
      v_planning.origin_lng AS src_o_lng,
      v_planning.destination_lat AS src_d_lat,
      v_planning.destination_lng AS src_d_lng,
      v_planning.is_return_trip AS src_return,
      v_planning.return_lat AS src_r_lat,
      v_planning.return_lng AS src_r_lng,
      v_planning.return_city AS src_r_city
  ),
  candidates AS (
    SELECT 
      cp.*,
      s.*,
      -- Distance entre origines
      v_earth_radius * 2 * asin(sqrt(
        sin(radians(cp.origin_lat - s.src_o_lat) / 2) ^ 2 +
        cos(radians(s.src_o_lat)) * cos(radians(cp.origin_lat)) *
        sin(radians(cp.origin_lng - s.src_o_lng) / 2) ^ 2
      )) AS origin_distance_km,
      -- Distance entre destinations
      v_earth_radius * 2 * asin(sqrt(
        sin(radians(cp.destination_lat - s.src_d_lat) / 2) ^ 2 +
        cos(radians(s.src_d_lat)) * cos(radians(cp.destination_lat)) *
        sin(radians(cp.destination_lng - s.src_d_lng) / 2) ^ 2
      )) AS dest_distance_km,
      -- Distance crois√©e (origin candidat -> dest source) pour retours classiques
      v_earth_radius * 2 * asin(sqrt(
        sin(radians(cp.origin_lat - s.src_d_lat) / 2) ^ 2 +
        cos(radians(s.src_d_lat)) * cos(radians(cp.origin_lat)) *
        sin(radians(cp.origin_lng - s.src_d_lng) / 2) ^ 2
      )) AS cross_distance_km,
      -- *** NOUVEAU: Distance retour ‚Üí origine du candidat ***
      -- Si le source a une ville de retour, distance entre return_city et l'origine du candidat
      CASE WHEN s.src_r_lat IS NOT NULL THEN
        v_earth_radius * 2 * asin(sqrt(
          sin(radians(cp.origin_lat - s.src_r_lat) / 2) ^ 2 +
          cos(radians(s.src_r_lat)) * cos(radians(cp.origin_lat)) *
          sin(radians(cp.origin_lng - s.src_r_lng) / 2) ^ 2
        ))
      ELSE NULL END AS return_to_origin_km,
      -- *** NOUVEAU: Distance destination du candidat ‚Üí ville de retour du source ***
      CASE WHEN s.src_r_lat IS NOT NULL THEN
        v_earth_radius * 2 * asin(sqrt(
          sin(radians(cp.destination_lat - s.src_r_lat) / 2) ^ 2 +
          cos(radians(s.src_r_lat)) * cos(radians(cp.destination_lat)) *
          sin(radians(cp.destination_lng - s.src_r_lng) / 2) ^ 2
        ))
      ELSE NULL END AS return_to_dest_km,
      -- *** NOUVEAU: Si le candidat a un retour, distance entre les deux villes de retour ***
      CASE WHEN s.src_r_lat IS NOT NULL AND cp.return_lat IS NOT NULL THEN
        v_earth_radius * 2 * asin(sqrt(
          sin(radians(cp.return_lat - s.src_r_lat) / 2) ^ 2 +
          cos(radians(s.src_r_lat)) * cos(radians(cp.return_lat)) *
          sin(radians(cp.return_lng - s.src_r_lng) / 2) ^ 2
        ))
      ELSE NULL END AS return_to_return_km,
      -- Overlap temporel en minutes
      GREATEST(0, 
        EXTRACT(EPOCH FROM (LEAST(cp.end_time, s.src_end) - GREATEST(cp.start_time, s.src_start))) / 60
      )::INTEGER AS time_overlap
    FROM convoy_plannings cp
    CROSS JOIN source s
    WHERE cp.id != s.src_id
      AND cp.user_id != s.src_user
      AND cp.status = 'published'
      -- M√™me date OU date +1 pour retour le lendemain
      AND cp.planning_date BETWEEN s.src_date AND s.src_date + INTERVAL '1 day'
      AND cp.origin_lat IS NOT NULL
      AND cp.destination_lat IS NOT NULL
  )
  SELECT 
    c.id AS matched_planning_id,
    c.user_id AS matched_user_id,
    -- Score composite am√©lior√©
    LEAST(100, (
      -- Proximit√© des origines (max 40 pts)
      CASE WHEN c.origin_distance_km < 5 THEN 40
           WHEN c.origin_distance_km < 15 THEN 30
           WHEN c.origin_distance_km < 30 THEN 20
           WHEN c.origin_distance_km < 50 THEN 10
           ELSE 0 END +
      -- Proximit√© des destinations (max 40 pts)
      CASE WHEN c.dest_distance_km < 5 THEN 40
           WHEN c.dest_distance_km < 15 THEN 30
           WHEN c.dest_distance_km < 30 THEN 20
           WHEN c.dest_distance_km < 50 THEN 10
           ELSE 0 END +
      -- Overlap temporel (max 20 pts)
      CASE WHEN c.time_overlap > 120 THEN 20
           WHEN c.time_overlap > 60 THEN 15
           WHEN c.time_overlap > 30 THEN 10
           ELSE 5 END +
      -- *** BONUS RETOUR: Si le trajet du candidat passe par/va vers la ville de retour ***
      CASE 
        -- Le candidat va vers ma ville de retour (sa destination = mon retour)
        WHEN c.return_to_dest_km IS NOT NULL AND c.return_to_dest_km < 15 THEN 30
        WHEN c.return_to_dest_km IS NOT NULL AND c.return_to_dest_km < 30 THEN 20
        -- Le candidat part de ma ville de retour (route compl√©mentaire)
        WHEN c.return_to_origin_km IS NOT NULL AND c.return_to_origin_km < 15 THEN 25
        WHEN c.return_to_origin_km IS NOT NULL AND c.return_to_origin_km < 30 THEN 15
        -- Les deux retournent au m√™me endroit
        WHEN c.return_to_return_km IS NOT NULL AND c.return_to_return_km < 15 THEN 35
        WHEN c.return_to_return_km IS NOT NULL AND c.return_to_return_km < 30 THEN 20
        ELSE 0
      END
    ))::INTEGER AS match_score,
    -- Type de match √©largi
    CASE 
      WHEN c.origin_distance_km < 15 AND c.dest_distance_km < 15 THEN 'same_route'
      -- NOUVEAU: match retour quand le candidat va vers ma ville de retour
      WHEN c.src_r_lat IS NOT NULL AND c.return_to_dest_km IS NOT NULL AND c.return_to_dest_km < 30 THEN 'return_opportunity'
      -- NOUVEAU: les deux retournent au m√™me endroit  
      WHEN c.src_r_lat IS NOT NULL AND c.return_to_return_km IS NOT NULL AND c.return_to_return_km < 30 THEN 'return_opportunity'
      WHEN c.cross_distance_km < 15 THEN 'return_opportunity'
      WHEN c.origin_distance_km < 50 OR c.dest_distance_km < 50 THEN 'nearby_route'
      ELSE 'time_overlap'
    END AS match_type,
    -- Distance la plus pertinente
    LEAST(
      c.origin_distance_km, 
      c.dest_distance_km,
      COALESCE(c.return_to_dest_km, 9999),
      COALESCE(c.return_to_origin_km, 9999),
      COALESCE(c.return_to_return_km, 9999)
    ) AS distance_km,
    c.time_overlap AS time_overlap_minutes,
    -- KM √©conomis√©s
    CASE 
      WHEN c.origin_distance_km < 15 AND c.dest_distance_km < 15 THEN c.origin_distance_km + c.dest_distance_km
      WHEN c.return_to_dest_km IS NOT NULL AND c.return_to_dest_km < 30 THEN c.return_to_dest_km * 2
      WHEN c.return_to_return_km IS NOT NULL AND c.return_to_return_km < 30 THEN c.return_to_return_km * 2
      WHEN c.cross_distance_km < 15 THEN c.cross_distance_km * 2
      ELSE LEAST(c.origin_distance_km, c.dest_distance_km)
    END AS potential_km_saved
  FROM candidates c
  WHERE (
    c.origin_distance_km < 50 
    OR c.dest_distance_km < 50 
    OR c.cross_distance_km < 50
    -- NOUVEAU: inclure les candidats proches de ma ville de retour
    OR (c.return_to_dest_km IS NOT NULL AND c.return_to_dest_km < 50)
    OR (c.return_to_origin_km IS NOT NULL AND c.return_to_origin_km < 50)
    OR (c.return_to_return_km IS NOT NULL AND c.return_to_return_km < 50)
  )
    AND c.time_overlap > 0
  ORDER BY match_score DESC
  LIMIT 20;
END;
$$;


ALTER FUNCTION public.find_planning_matches(p_planning_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION find_planning_matches(p_planning_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.find_planning_matches(p_planning_id uuid) IS 'Algorithme IA de matching: score bas√© sur proximit√© g√©ographique, overlap temporel et type de trajet';


--
-- Name: find_ride_matches_for_request(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.find_ride_matches_for_request(p_request_id uuid) RETURNS TABLE(offer_id uuid, driver_id uuid, pickup_city text, dropoff_city text, detour_km double precision, distance_covered_km double precision, match_score integer, match_type text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_req RECORD;
  v_earth_radius CONSTANT DOUBLE PRECISION := 6371;
BEGIN
  SELECT * INTO v_req FROM ride_requests WHERE id = p_request_id;
  IF v_req IS NULL THEN RETURN; END IF;

  RETURN QUERY
  WITH offers AS (
    SELECT 
      ro.*,
      -- Distance entre le pickup du passager et l'origine de l'offre
      v_earth_radius * 2 * asin(sqrt(
        sin(radians(v_req.pickup_lat - ro.origin_lat) / 2) ^ 2 +
        cos(radians(v_req.pickup_lat)) * cos(radians(ro.origin_lat)) *
        sin(radians(v_req.pickup_lng - ro.origin_lng) / 2) ^ 2
      )) AS dist_pickup_to_origin,
      -- Distance entre le pickup du passager et la destination de l'offre
      v_earth_radius * 2 * asin(sqrt(
        sin(radians(v_req.pickup_lat - ro.destination_lat) / 2) ^ 2 +
        cos(radians(v_req.pickup_lat)) * cos(radians(ro.destination_lat)) *
        sin(radians(v_req.pickup_lng - ro.destination_lng) / 2) ^ 2
      )) AS dist_pickup_to_dest,
      -- Distance entre la destination du passager et la destination de l'offre
      v_earth_radius * 2 * asin(sqrt(
        sin(radians(v_req.destination_lat - ro.destination_lat) / 2) ^ 2 +
        cos(radians(v_req.destination_lat)) * cos(radians(ro.destination_lat)) *
        sin(radians(v_req.destination_lng - ro.destination_lng) / 2) ^ 2
      )) AS dist_dest_to_dest,
      -- Distance directe passager pickup ‚Üí destination
      v_earth_radius * 2 * asin(sqrt(
        sin(radians(v_req.destination_lat - v_req.pickup_lat) / 2) ^ 2 +
        cos(radians(v_req.pickup_lat)) * cos(radians(v_req.destination_lat)) *
        sin(radians(v_req.destination_lng - v_req.pickup_lng) / 2) ^ 2
      )) AS passenger_total_distance,
      -- Distance trajet conducteur origin ‚Üí dest
      v_earth_radius * 2 * asin(sqrt(
        sin(radians(ro.destination_lat - ro.origin_lat) / 2) ^ 2 +
        cos(radians(ro.origin_lat)) * cos(radians(ro.destination_lat)) *
        sin(radians(ro.destination_lng - ro.origin_lng) / 2) ^ 2
      )) AS driver_route_distance
    FROM ride_offers ro
    WHERE ro.status IN ('active', 'en_route')
      AND ro.user_id != v_req.user_id
      AND ro.departure_date = v_req.needed_date
      AND ro.origin_lat IS NOT NULL
      AND ro.destination_lat IS NOT NULL
      AND ro.seats_available > 0
  )
  SELECT
    o.id AS offer_id,
    o.user_id AS driver_id,
    -- Ville de pickup (la plus proche entre origin et route)
    CASE 
      WHEN o.dist_pickup_to_origin < o.dist_pickup_to_dest THEN o.origin_city
      ELSE o.destination_city
    END AS pickup_city,
    -- Ville de dropoff
    CASE
      WHEN o.dist_dest_to_dest < 30 THEN o.destination_city
      ELSE o.destination_city
    END AS dropoff_city,
    -- D√©tour estim√© = dist pickup passager par rapport √† la route directe
    LEAST(o.dist_pickup_to_origin, o.dist_pickup_to_dest) AS detour_km,
    -- Distance couverte pour le passager
    CASE 
      WHEN o.dist_dest_to_dest < 30 THEN o.passenger_total_distance
      ELSE GREATEST(0, o.passenger_total_distance - o.dist_dest_to_dest)
    END AS distance_covered_km,
    -- Score composite (0-100)
    LEAST(100, (
      -- Faible d√©tour pour le conducteur (max 35 pts)
      CASE 
        WHEN LEAST(o.dist_pickup_to_origin, o.dist_pickup_to_dest) < 5 THEN 35
        WHEN LEAST(o.dist_pickup_to_origin, o.dist_pickup_to_dest) < 10 THEN 28
        WHEN LEAST(o.dist_pickup_to_origin, o.dist_pickup_to_dest) < 20 THEN 18
        WHEN LEAST(o.dist_pickup_to_origin, o.dist_pickup_to_dest) < 30 THEN 10
        ELSE 0
      END +
      -- Destination proche (max 35 pts)
      CASE
        WHEN o.dist_dest_to_dest < 5 THEN 35
        WHEN o.dist_dest_to_dest < 15 THEN 28
        WHEN o.dist_dest_to_dest < 30 THEN 18
        WHEN o.dist_dest_to_dest < 50 THEN 10
        ELSE 0
      END +
      -- Couverture du trajet passager (max 20 pts)
      CASE
        WHEN o.passenger_total_distance > 0 THEN
          LEAST(20, (GREATEST(0, o.passenger_total_distance - o.dist_dest_to_dest) / o.passenger_total_distance * 20)::INTEGER)
        ELSE 10
      END +
      -- Bonus m√™me direction (max 10 pts)
      CASE
        WHEN o.dist_pickup_to_origin < 20 AND o.dist_dest_to_dest < 20 THEN 10
        WHEN o.dist_pickup_to_dest < 20 THEN 5
        ELSE 0
      END
    ))::INTEGER AS match_score,
    -- Type de match
    CASE
      WHEN LEAST(o.dist_pickup_to_origin, o.dist_pickup_to_dest) < 5 THEN 'on_route'
      WHEN LEAST(o.dist_pickup_to_origin, o.dist_pickup_to_dest) < o.max_detour_km THEN 'small_detour'
      WHEN o.dist_dest_to_dest > 30 THEN 'partial'
      ELSE 'on_route'
    END AS match_type
  FROM offers o
  WHERE (
    LEAST(o.dist_pickup_to_origin, o.dist_pickup_to_dest) < GREATEST(o.max_detour_km, v_req.max_detour_km)
    OR o.dist_dest_to_dest < 50
  )
  ORDER BY match_score DESC
  LIMIT 30;
END;
$$;


ALTER FUNCTION public.find_ride_matches_for_request(p_request_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION find_ride_matches_for_request(p_request_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.find_ride_matches_for_request(p_request_id uuid) IS 'Matching IA route-based : trouve les conducteurs dont le trajet passe pr√®s du passager';


--
-- Name: find_similar_rides(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.find_similar_rides(p_ride_id uuid) RETURNS TABLE(similar_ride_id uuid, similarity_score integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  WITH ride_info AS (
    SELECT departure_city, arrival_city, departure_date
    FROM carpooling_rides_pro
    WHERE id = p_ride_id
  )
  SELECT 
    r.id,
    CASE 
      WHEN r.departure_city = ri.departure_city AND r.arrival_city = ri.arrival_city THEN 100
      WHEN r.departure_city = ri.departure_city OR r.arrival_city = ri.arrival_city THEN 50
      ELSE 25
    END as similarity_score
  FROM carpooling_rides_pro r, ride_info ri
  WHERE r.id != p_ride_id
    AND r.status = 'published'
    AND r.departure_date = ri.departure_date
    AND (r.departure_city = ri.departure_city OR r.arrival_city = ri.arrival_city)
  ORDER BY similarity_score DESC
  LIMIT 10;
END;
$$;


ALTER FUNCTION public.find_similar_rides(p_ride_id uuid) OWNER TO postgres;

--
-- Name: generate_driving_report(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_driving_report(p_session_id uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_report_id UUID;
  v_total_distance FLOAT;
  v_duration_minutes INTEGER;
  v_avg_speed FLOAT;
  v_max_speed FLOAT;
  v_harsh_events INTEGER;
  v_idle_minutes INTEGER;
  v_safety_score INTEGER;
BEGIN
  -- Calculer statistiques
  SELECT 
    COALESCE(SUM(
      ST_Distance(
        location::geography,
        LAG(location::geography) OVER (ORDER BY recorded_at)
      ) / 1000
    ), 0),
    EXTRACT(EPOCH FROM (MAX(recorded_at) - MIN(recorded_at))) / 60,
    AVG(speed_kmh),
    MAX(speed_kmh)
  INTO v_total_distance, v_duration_minutes, v_avg_speed, v_max_speed
  FROM gps_location_points
  WHERE session_id = p_session_id
    AND is_valid = TRUE
    AND location IS NOT NULL;
  
  -- D√©tecter freinages/acc√©l√©rations brusques (changement vitesse > 30 km/h en < 5 secondes)
  SELECT COUNT(*)
  INTO v_harsh_events
  FROM (
    SELECT 
      ABS(speed_kmh - LAG(speed_kmh) OVER (ORDER BY recorded_at)) as speed_change,
      EXTRACT(EPOCH FROM (recorded_at - LAG(recorded_at) OVER (ORDER BY recorded_at))) as time_diff
    FROM gps_location_points
    WHERE session_id = p_session_id AND is_valid = TRUE
  ) changes
  WHERE speed_change > 30 AND time_diff < 5;
  
  -- Calculer temps √† l'arr√™t moteur tournant
  SELECT COALESCE(SUM(duration_minutes), 0)
  INTO v_idle_minutes
  FROM gps_stop_zones
  WHERE session_id = p_session_id;
  
  -- Score de s√©curit√© (0-100)
  v_safety_score := GREATEST(0, LEAST(100, 
    100 
    - (v_harsh_events * 5)  -- -5 points par √©v√©nement brusque
    - (CASE WHEN v_max_speed > 130 THEN 20 ELSE 0 END)  -- -20 si exc√®s vitesse
    - (CASE WHEN v_idle_minutes > 30 THEN 10 ELSE 0 END)  -- -10 si idle excessif
  ));
  
  -- Ins√©rer rapport
  INSERT INTO driving_reports (
    session_id,
    total_distance_km,
    total_duration_minutes,
    average_speed_kmh,
    max_speed_kmh,
    harsh_braking_count,
    harsh_acceleration_count,
    idle_time_minutes,
    safety_score,
    fuel_efficiency_rating
  )
  VALUES (
    p_session_id,
    v_total_distance,
    v_duration_minutes::INTEGER,
    v_avg_speed,
    v_max_speed,
    v_harsh_events,
    v_harsh_events,
    v_idle_minutes::INTEGER,
    v_safety_score,
    CASE 
      WHEN v_safety_score >= 90 THEN 'Excellent'
      WHEN v_safety_score >= 75 THEN 'Bon'
      WHEN v_safety_score >= 60 THEN 'Moyen'
      ELSE '√Ä am√©liorer'
    END
  )
  ON CONFLICT (session_id) 
  DO UPDATE SET
    total_distance_km = EXCLUDED.total_distance_km,
    total_duration_minutes = EXCLUDED.total_duration_minutes,
    average_speed_kmh = EXCLUDED.average_speed_kmh,
    max_speed_kmh = EXCLUDED.max_speed_kmh,
    harsh_braking_count = EXCLUDED.harsh_braking_count,
    harsh_acceleration_count = EXCLUDED.harsh_acceleration_count,
    idle_time_minutes = EXCLUDED.idle_time_minutes,
    safety_score = EXCLUDED.safety_score,
    fuel_efficiency_rating = EXCLUDED.fuel_efficiency_rating
  RETURNING id INTO v_report_id;
  
  RETURN v_report_id;
END;
$$;


ALTER FUNCTION public.generate_driving_report(p_session_id uuid) OWNER TO postgres;

--
-- Name: generate_public_tracking_link(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_public_tracking_link(p_mission_id uuid) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_token TEXT;
  v_mission_end TIMESTAMPTZ;
BEGIN
  -- R√©cup√©rer date de fin de mission
  SELECT delivery_date INTO v_mission_end
  FROM missions
  WHERE id = p_mission_id;
  
  -- Si pas de date de fin, expiration dans 7 jours
  IF v_mission_end IS NULL THEN
    v_mission_end := NOW() + INTERVAL '7 days';
  END IF;
  
  -- G√©n√©rer un token URL-safe (base64 classique nettoy√©)
  v_token := replace(replace(replace(
    encode(gen_random_bytes(24), 'base64'),
    '+', '-'), '/', '_'), '=', '');
  
  -- Cr√©er ou r√©activer le lien (UPSERT)
  INSERT INTO public_tracking_links (mission_id, token, expires_at)
  VALUES (p_mission_id, v_token, v_mission_end + INTERVAL '48 hours')
  ON CONFLICT (mission_id) 
  DO UPDATE SET 
    is_active = true,
    expires_at = EXCLUDED.expires_at,
    access_count = 0
  RETURNING token INTO v_token;
  
  RETURN v_token;
END;
$$;


ALTER FUNCTION public.generate_public_tracking_link(p_mission_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION generate_public_tracking_link(p_mission_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.generate_public_tracking_link(p_mission_id uuid) IS 'G√©n√®re un lien public s√©curis√© pour une mission - Expiration 48h apr√®s fin mission';


--
-- Name: generate_share_code(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_share_code() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  chars CONSTANT TEXT := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; -- sans I,O,0,1
  code TEXT;
BEGIN
  -- Pr√©fixe XZ- puis 6 caract√®res (ABC-123)
  code := 'XZ-';
  FOR i IN 1..6 LOOP
    code := code || substr(chars, 1 + floor(random() * length(chars))::int, 1);
    IF i = 3 THEN
      code := code || '-';
    END IF;
  END LOOP;
  RETURN code;
END;
$$;


ALTER FUNCTION public.generate_share_code() OWNER TO postgres;

--
-- Name: FUNCTION generate_share_code(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.generate_share_code() IS 'G√©n√®re un code de partage type XZ-ABC-123';


--
-- Name: get_ai_requests_count(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_ai_requests_count(p_user_id uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_month_key text;
  v_count integer;
BEGIN
  v_month_key := get_current_month_key();
  
  SELECT COALESCE(request_count, 0)
  INTO v_count
  FROM public.ai_requests_usage
  WHERE user_id = p_user_id AND month_key = v_month_key;
  
  RETURN COALESCE(v_count, 0);
END;
$$;


ALTER FUNCTION public.get_ai_requests_count(p_user_id uuid) OWNER TO postgres;

--
-- Name: get_all_users(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_all_users() RETURNS TABLE(id uuid, email text)
    LANGUAGE sql SECURITY DEFINER
    AS $$
  SELECT id, email
  FROM auth.users
  ORDER BY email;
$$;


ALTER FUNCTION public.get_all_users() OWNER TO postgres;

--
-- Name: get_client_stats_by_siret(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_client_stats_by_siret(p_siret text) RETURNS TABLE(total_invoices bigint, total_quotes bigint, total_amount numeric, paid_amount numeric, pending_amount numeric, first_activity date, last_activity date)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(DISTINCT i.id) as total_invoices,
    COUNT(DISTINCT q.id) as total_quotes,
    COALESCE(SUM(i.total), 0) as total_amount,
    COALESCE(SUM(CASE WHEN i.status = 'paid' THEN i.total ELSE 0 END), 0) as paid_amount,
    COALESCE(SUM(CASE WHEN i.status IN ('draft', 'sent', 'overdue') THEN i.total ELSE 0 END), 0) as pending_amount,
    MIN(COALESCE(i.issue_date, i.created_at::DATE, q.issue_date, q.created_at::DATE))::DATE as first_activity,
    MAX(COALESCE(i.issue_date, i.created_at::DATE, q.issue_date, q.created_at::DATE))::DATE as last_activity
  FROM public.invoices i
  FULL OUTER JOIN public.quotes q ON i.client_siret = q.client_siret
  WHERE COALESCE(i.client_siret, q.client_siret) = p_siret;
END;
$$;


ALTER FUNCTION public.get_client_stats_by_siret(p_siret text) OWNER TO postgres;

--
-- Name: get_current_month_key(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_current_month_key() RETURNS text
    LANGUAGE sql STABLE
    AS $$
  SELECT TO_CHAR(NOW(), 'YYYY-MM');
$$;


ALTER FUNCTION public.get_current_month_key() OWNER TO postgres;

--
-- Name: get_current_month_navigation_stats(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_current_month_navigation_stats() RETURNS TABLE(total_sessions bigint, active_sessions bigint, completed_sessions bigint, cancelled_sessions bigint, cached_sessions bigint, api_sessions bigint, total_distance_km numeric, avg_distance_km numeric, mapbox_quota_used bigint, mapbox_quota_remaining bigint, mapbox_quota_percent numeric, mapbox_cost_usd numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*)::BIGINT as total_sessions,
    COUNT(*) FILTER (WHERE status = 'active')::BIGINT as active_sessions,
    COUNT(*) FILTER (WHERE status = 'completed')::BIGINT as completed_sessions,
    COUNT(*) FILTER (WHERE status = 'cancelled')::BIGINT as cancelled_sessions,
    COUNT(*) FILTER (WHERE from_cache = TRUE)::BIGINT as cached_sessions,
    COUNT(*) FILTER (WHERE from_cache = FALSE)::BIGINT as api_sessions,
    ROUND(SUM(distance_meters) / 1000, 2) as total_distance_km,
    ROUND(AVG(distance_meters) / 1000, 2) as avg_distance_km,
    COUNT(*) FILTER (WHERE from_cache = FALSE)::BIGINT as mapbox_quota_used,
    (25000 - COUNT(*) FILTER (WHERE from_cache = FALSE))::BIGINT as mapbox_quota_remaining,
    ROUND((COUNT(*) FILTER (WHERE from_cache = FALSE)::NUMERIC / 25000 * 100), 2) as mapbox_quota_percent,
    CASE 
      WHEN COUNT(*) FILTER (WHERE from_cache = FALSE) > 25000 
      THEN (COUNT(*) FILTER (WHERE from_cache = FALSE) - 25000) * 0.50
      ELSE 0 
    END as mapbox_cost_usd
  FROM navigation_sessions
  WHERE created_at >= DATE_TRUNC('month', NOW());
END;
$$;


ALTER FUNCTION public.get_current_month_navigation_stats() OWNER TO postgres;

--
-- Name: FUNCTION get_current_month_navigation_stats(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_current_month_navigation_stats() IS 'Obtenir statistiques navigation du mois en cours';


--
-- Name: get_dashboard_stats(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_dashboard_stats(p_user_id uuid) RETURNS json
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  v_result JSON;
  v_now TIMESTAMPTZ := NOW();
  v_start_of_month TIMESTAMPTZ;
  v_start_of_week TIMESTAMPTZ;
  v_start_of_today TIMESTAMPTZ;
BEGIN
  v_start_of_month := date_trunc('month', v_now);
  v_start_of_week := date_trunc('week', v_now);
  v_start_of_today := date_trunc('day', v_now);

  SELECT json_build_object(
    -- Mission counts
    'total_missions', COALESCE((SELECT COUNT(*) FROM missions WHERE user_id = p_user_id), 0),
    'active_missions', COALESCE((SELECT COUNT(*) FROM missions WHERE user_id = p_user_id AND status = 'in_progress'), 0),
    'completed_missions', COALESCE((SELECT COUNT(*) FROM missions WHERE user_id = p_user_id AND status = 'completed'), 0),
    'cancelled_missions', COALESCE((SELECT COUNT(*) FROM missions WHERE user_id = p_user_id AND status = 'cancelled'), 0),
    'pending_missions', COALESCE((SELECT COUNT(*) FROM missions WHERE user_id = p_user_id AND status = 'pending'), 0),
    'missions_this_week', COALESCE((SELECT COUNT(*) FROM missions WHERE user_id = p_user_id AND created_at >= v_start_of_week), 0),
    'missions_today', COALESCE((SELECT COUNT(*) FROM missions WHERE user_id = p_user_id AND created_at >= v_start_of_today), 0),

    -- Revenue
    'total_revenue', COALESCE((
      SELECT SUM(COALESCE(company_commission, 0) + COALESCE(bonus_amount, 0))
      FROM missions WHERE user_id = p_user_id AND status = 'completed'
    ), 0),
    'monthly_revenue', COALESCE((
      SELECT SUM(COALESCE(company_commission, 0) + COALESCE(bonus_amount, 0))
      FROM missions WHERE user_id = p_user_id AND status = 'completed' AND created_at >= v_start_of_month
    ), 0),
    'weekly_revenue', COALESCE((
      SELECT SUM(COALESCE(company_commission, 0) + COALESCE(bonus_amount, 0))
      FROM missions WHERE user_id = p_user_id AND status = 'completed' AND created_at >= v_start_of_week
    ), 0),
    'average_mission_price', COALESCE((
      SELECT AVG(COALESCE(company_commission, 0) + COALESCE(bonus_amount, 0))
      FROM missions WHERE user_id = p_user_id AND status = 'completed'
    ), 0),

    -- Rates
    'completion_rate', CASE
      WHEN (SELECT COUNT(*) FROM missions WHERE user_id = p_user_id) > 0
      THEN ROUND((SELECT COUNT(*)::numeric FROM missions WHERE user_id = p_user_id AND status = 'completed') /
           (SELECT COUNT(*)::numeric FROM missions WHERE user_id = p_user_id) * 100, 1)
      ELSE 0 END,
    'cancelled_rate', CASE
      WHEN (SELECT COUNT(*) FROM missions WHERE user_id = p_user_id) > 0
      THEN ROUND((SELECT COUNT(*)::numeric FROM missions WHERE user_id = p_user_id AND status = 'cancelled') /
           (SELECT COUNT(*)::numeric FROM missions WHERE user_id = p_user_id) * 100, 1)
      ELSE 0 END,

    -- Distance & delivery time
    'total_distance', COALESCE((SELECT SUM(COALESCE(distance_km, 0)) FROM missions WHERE user_id = p_user_id), 0),
    'average_delivery_time_hours', COALESCE((
      SELECT AVG(EXTRACT(EPOCH FROM (delivery_date - pickup_date)) / 3600)
      FROM missions WHERE user_id = p_user_id AND status = 'completed'
        AND pickup_date IS NOT NULL AND delivery_date IS NOT NULL
        AND delivery_date > pickup_date
    ), 0),

    -- Contacts
    'total_contacts', COALESCE((SELECT COUNT(*) FROM contacts WHERE user_id = p_user_id), 0),
    'total_drivers', COALESCE((SELECT COUNT(*) FROM contacts WHERE user_id = p_user_id AND is_driver = true), 0),
    'total_clients', COALESCE((SELECT COUNT(*) FROM contacts WHERE user_id = p_user_id AND type = 'customer'), 0),
    'top_rated_contacts', COALESCE((SELECT COUNT(*) FROM contacts WHERE user_id = p_user_id AND rating_average >= 4), 0),

    -- Invoices
    'total_invoices', COALESCE((SELECT COUNT(*) FROM invoices WHERE user_id = p_user_id), 0),
    'paid_invoices', COALESCE((SELECT COUNT(*) FROM invoices WHERE user_id = p_user_id AND status = 'paid'), 0),
    'pending_invoices', COALESCE((SELECT COUNT(*) FROM invoices WHERE user_id = p_user_id AND status NOT IN ('paid', 'cancelled')), 0),

    -- Credits
    'total_credits', COALESCE((SELECT credits FROM profiles WHERE id = p_user_id), 0),

    -- Last 6 months chart data
    'monthly_chart', (
      SELECT json_agg(row_to_json(t) ORDER BY t.month_date)
      FROM (
        SELECT
          to_char(d.month_date, 'Mon') AS month,
          d.month_date,
          COALESCE((SELECT COUNT(*) FROM missions m WHERE m.user_id = p_user_id
            AND date_trunc('month', m.created_at) = d.month_date), 0) AS missions,
          COALESCE((SELECT SUM(COALESCE(m.company_commission, 0) + COALESCE(m.bonus_amount, 0))
            FROM missions m WHERE m.user_id = p_user_id AND m.status = 'completed'
            AND date_trunc('month', m.created_at) = d.month_date), 0) AS revenue
        FROM generate_series(
          date_trunc('month', v_now) - INTERVAL '5 months',
          date_trunc('month', v_now),
          INTERVAL '1 month'
        ) AS d(month_date)
      ) t
    )
  ) INTO v_result;

  RETURN v_result;
END;
$$;


ALTER FUNCTION public.get_dashboard_stats(p_user_id uuid) OWNER TO postgres;

--
-- Name: get_documents_by_siret(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_documents_by_siret(p_siret text) RETURNS TABLE(type text, document_id uuid, document_number text, document_date date, total numeric, status text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  
  -- Factures
  SELECT 
    'invoice'::TEXT as type,
    i.id as document_id,
    i.invoice_number as document_number,
    COALESCE(i.issue_date, i.created_at::DATE) as document_date,
    i.total,
    i.status
  FROM public.invoices i
  WHERE i.client_siret = p_siret
  
  UNION ALL
  
  -- Devis
  SELECT 
    'quote'::TEXT as type,
    q.id as document_id,
    q.quote_number as document_number,
    COALESCE(q.issue_date, q.created_at::DATE) as document_date,
    q.total,
    q.status
  FROM public.quotes q
  WHERE q.client_siret = p_siret
  
  ORDER BY document_date DESC;
END;
$$;


ALTER FUNCTION public.get_documents_by_siret(p_siret text) OWNER TO postgres;

--
-- Name: get_driver_trips_count(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_driver_trips_count(user_uuid uuid) RETURNS integer
    LANGUAGE sql STABLE
    AS $$
SELECT COUNT(*)::integer
FROM carpooling_trips
WHERE driver_id = user_uuid
AND status = 'completed';
$$;


ALTER FUNCTION public.get_driver_trips_count(user_uuid uuid) OWNER TO postgres;

--
-- Name: get_expiring_quotes(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_expiring_quotes(days_before integer DEFAULT 7) RETURNS TABLE(id uuid, quote_number character varying, client_name character varying, total_ttc numeric, valid_until date, days_remaining integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    q.id,
    q.quote_number,
    c.name AS client_name,
    q.total_ttc,
    q.valid_until,
    (q.valid_until - CURRENT_DATE)::INTEGER AS days_remaining
  FROM quotes q
  JOIN clients c ON c.id = q.client_id
  WHERE q.status IN ('draft', 'sent')
    AND q.valid_until BETWEEN CURRENT_DATE AND (CURRENT_DATE + days_before)
  ORDER BY q.valid_until ASC;
END;
$$;


ALTER FUNCTION public.get_expiring_quotes(days_before integer) OWNER TO postgres;

--
-- Name: FUNCTION get_expiring_quotes(days_before integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_expiring_quotes(days_before integer) IS 'Retourne les devis qui expirent dans les N jours (par d√©faut 7)';


--
-- Name: get_full_inspection_report(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_full_inspection_report(p_token text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_share_record RECORD;
  v_mission_id UUID;
  v_result JSONB;
  v_timeline JSONB;
BEGIN
  SELECT * INTO v_share_record
  FROM public.inspection_report_shares
  WHERE share_token = p_token
    AND is_active = TRUE
    AND (expires_at IS NULL OR expires_at > NOW())
  LIMIT 1;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('error', 'Token invalide ou expir√©');
  END IF;

  UPDATE public.inspection_report_shares
  SET access_count = access_count + 1,
      last_accessed_at = NOW()
  WHERE share_token = p_token;

  v_mission_id := v_share_record.mission_id;

  -- Construire la timeline en agr√©gant tous les √©v√©nements
  SELECT jsonb_agg(event ORDER BY event->>'timestamp')
  INTO v_timeline
  FROM (
    -- √âv√©nements: Inspection D√©part
    SELECT jsonb_build_object(
      'event_type', 'departure_inspection',
      'timestamp', vi.created_at,
      'inspection_id', vi.id,
      'data', jsonb_build_object(
        'id', vi.id,
        'created_at', vi.created_at,
        'completed_at', vi.completed_at,
        'mileage_km', vi.mileage_km,
        'fuel_level', vi.fuel_level,
        'cleanliness_interior', vi.internal_cleanliness,
        'cleanliness_exterior', vi.external_cleanliness,
        'notes', vi.notes,
        'driver_signature', vi.driver_signature,
        'client_signature', vi.client_signature,
        'driver_name', vi.driver_name,
        'client_name', vi.client_name,
        'latitude', vi.latitude,
        'longitude', vi.longitude,
        'has_security_kit', COALESCE((vi.vehicle_info->>'has_security_kit')::boolean, false),
        'has_spare_wheel', COALESCE((vi.vehicle_info->>'has_spare_wheel')::boolean, false),
        'has_inflation_kit', COALESCE((vi.vehicle_info->>'has_inflation_kit')::boolean, false),
        'has_fuel_card', COALESCE((vi.vehicle_info->>'has_fuel_card')::boolean, false),
        'is_loaded', COALESCE((vi.vehicle_info->>'is_loaded')::boolean, false),
        'has_confided_object', COALESCE((vi.vehicle_info->>'has_confided_object')::boolean, false),
        'confided_object_description', vi.vehicle_info->>'confided_object_description',
        'photos', COALESCE((
          SELECT jsonb_agg(jsonb_build_object(
            'id', ip.id,
            'photo_url', ip.full_url,
            'thumbnail_url', ip.thumbnail_url,
            'photo_type', ip.photo_type,
            'taken_at', ip.taken_at
          ) ORDER BY ip.taken_at)
          FROM inspection_photos_v2 ip
          WHERE ip.inspection_id = vi.id
        ), '[]'::jsonb),
        'damages', COALESCE((
          SELECT jsonb_agg(jsonb_build_object(
            'id', d.id,
            'damage_type', d.damage_type,
            'severity', d.severity,
            'location', d.location,
            'description', d.description,
            'photo_url', d.photo_url,
            'created_at', d.created_at
          ) ORDER BY d.created_at)
          FROM inspection_damages d
          WHERE d.inspection_id = vi.id
        ), '[]'::jsonb)
      )
    ) AS event
    FROM vehicle_inspections vi
    WHERE vi.mission_id = v_mission_id AND vi.inspection_type = 'departure'

    UNION ALL

    -- √âv√©nements: Inspection Arriv√©e
    SELECT jsonb_build_object(
      'event_type', 'arrival_inspection',
      'timestamp', vi.created_at,
      'inspection_id', vi.id,
      'data', jsonb_build_object(
        'id', vi.id,
        'created_at', vi.created_at,
        'completed_at', vi.completed_at,
        'mileage_km', vi.mileage_km,
        'fuel_level', vi.fuel_level,
        'cleanliness_interior', vi.internal_cleanliness,
        'cleanliness_exterior', vi.external_cleanliness,
        'notes', vi.notes,
        'driver_signature', vi.driver_signature,
        'client_signature', vi.client_signature,
        'driver_name', vi.driver_name,
        'client_name', vi.client_name,
        'latitude', vi.latitude,
        'longitude', vi.longitude,
        'has_security_kit', COALESCE((vi.vehicle_info->>'has_security_kit')::boolean, false),
        'has_spare_wheel', COALESCE((vi.vehicle_info->>'has_spare_wheel')::boolean, false),
        'has_inflation_kit', COALESCE((vi.vehicle_info->>'has_inflation_kit')::boolean, false),
        'has_fuel_card', COALESCE((vi.vehicle_info->>'has_fuel_card')::boolean, false),
        'is_loaded', COALESCE((vi.vehicle_info->>'is_loaded')::boolean, false),
        'has_confided_object', COALESCE((vi.vehicle_info->>'has_confided_object')::boolean, false),
        'confided_object_description', vi.vehicle_info->>'confided_object_description',
        'photos', COALESCE((
          SELECT jsonb_agg(jsonb_build_object(
            'id', ip.id,
            'photo_url', ip.full_url,
            'thumbnail_url', ip.thumbnail_url,
            'photo_type', ip.photo_type,
            'taken_at', ip.taken_at
          ) ORDER BY ip.taken_at)
          FROM inspection_photos_v2 ip
          WHERE ip.inspection_id = vi.id
        ), '[]'::jsonb),
        'damages', COALESCE((
          SELECT jsonb_agg(jsonb_build_object(
            'id', d.id,
            'damage_type', d.damage_type,
            'severity', d.severity,
            'location', d.location,
            'description', d.description,
            'photo_url', d.photo_url,
            'created_at', d.created_at
          ) ORDER BY d.created_at)
          FROM inspection_damages d
          WHERE d.inspection_id = vi.id
        ), '[]'::jsonb)
      )
    ) AS event
    FROM vehicle_inspections vi
    WHERE vi.mission_id = v_mission_id AND vi.inspection_type = 'arrival'

    UNION ALL

    -- √âv√©nements: Documents scann√©s
    SELECT jsonb_build_object(
      'event_type', 'document_scanned',
      'timestamp', d.created_at,
      'document_id', d.id,
      'data', jsonb_build_object(
        'id', d.id,
        'title', d.document_title,
        'file_url', d.document_url,
        'mime_type', CASE
          WHEN lower(d.document_url) LIKE '%.pdf' THEN 'application/pdf'
          WHEN lower(d.document_url) LIKE '%.png' THEN 'image/png'
          WHEN lower(d.document_url) LIKE '%.jpg' OR lower(d.document_url) LIKE '%.jpeg' THEN 'image/jpeg'
          WHEN lower(d.document_url) LIKE '%.webp' THEN 'image/webp'
          ELSE NULL
        END,
        'created_at', d.created_at
      )
    ) AS event
    FROM inspection_documents d
    WHERE d.inspection_id IN (
      SELECT id FROM vehicle_inspections WHERE mission_id = v_mission_id
    )

    UNION ALL

    -- √âv√©nements: D√©penses/Frais
    SELECT jsonb_build_object(
      'event_type', 'expense_recorded',
      'timestamp', e.created_at,
      'expense_id', e.id,
      'data', jsonb_build_object(
        'id', e.id,
        'description', e.description,
        'expense_type', e.expense_type,
        'amount', e.amount,
        'created_at', e.created_at
      )
    ) AS event
    FROM inspection_expenses e
    WHERE e.inspection_id IN (
      SELECT id FROM vehicle_inspections WHERE mission_id = v_mission_id
    )
  ) events;

  -- Construire la r√©ponse finale
  SELECT jsonb_build_object(
    'mission', jsonb_build_object(
      'id', m.id,
      'reference', m.reference,
      'status', m.status,
      'created_at', m.created_at,
      'pickup_date', m.pickup_date,
      'delivery_date', m.delivery_date,
      'pickup_address', m.pickup_address,
      'delivery_address', m.delivery_address,
      'pickup_contact_name', m.pickup_contact_name,
      'pickup_contact_phone', m.pickup_contact_phone,
      'delivery_contact_name', m.delivery_contact_name,
      'delivery_contact_phone', m.delivery_contact_phone,
      'vehicle_type', m.vehicle_type,
      'driver_name', COALESCE(
        (SELECT vi.driver_name FROM vehicle_inspections vi 
         WHERE vi.mission_id = m.id AND vi.inspection_type = 'departure' 
         ORDER BY vi.created_at DESC LIMIT 1),
        (SELECT vi.driver_name FROM vehicle_inspections vi 
         WHERE vi.mission_id = m.id AND vi.inspection_type = 'arrival' 
         ORDER BY vi.created_at DESC LIMIT 1)
      ),
      'driver_phone', COALESCE(m.driver_phone, m.pickup_contact_phone)
    ),
    'vehicle', jsonb_build_object(
      'brand', m.vehicle_brand,
      'model', m.vehicle_model,
      'plate', m.vehicle_plate,
      'vin', m.vehicle_vin,
      'year', m.vehicle_year,
      'color', m.vehicle_color
    ),
    'timeline', COALESCE(v_timeline, '[]'::jsonb),
    'report_type', v_share_record.report_type
  ) INTO v_result
  FROM missions m
  WHERE m.id = v_mission_id;

  RETURN v_result;
END;
$$;


ALTER FUNCTION public.get_full_inspection_report(p_token text) OWNER TO postgres;

--
-- Name: get_inspection_email_history(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_inspection_email_history(p_inspection_id uuid) RETURNS TABLE(sent_at timestamp with time zone, recipient_email text, status text, error_message text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    el.sent_at,
    el.recipient_email,
    el.status,
    el.error_message
  FROM email_logs el
  WHERE el.inspection_id = p_inspection_id
  ORDER BY el.sent_at DESC;
END;
$$;


ALTER FUNCTION public.get_inspection_email_history(p_inspection_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_inspection_email_history(p_inspection_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_inspection_email_history(p_inspection_id uuid) IS 'R√©cup√®re l''historique complet des envois email pour une inspection';


--
-- Name: get_inspection_report_by_token(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_inspection_report_by_token(p_token text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_share_record RECORD;
  v_result JSONB;
BEGIN
  SELECT * INTO v_share_record
  FROM public.inspection_report_shares
  WHERE share_token = p_token
    AND is_active = TRUE
    AND (expires_at IS NULL OR expires_at > NOW())
  LIMIT 1;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('error', 'Token invalide ou expir√©');
  END IF;

  UPDATE public.inspection_report_shares
  SET access_count = access_count + 1,
      last_accessed_at = NOW()
  WHERE share_token = p_token;

  SELECT jsonb_build_object(
    'mission_data', jsonb_build_object(
      'id', m.id,
      'reference', m.reference,
      'status', m.status,
      'created_at', m.created_at,
      'pickup_date', m.pickup_date,
      'delivery_date', m.delivery_date,
      'pickup_address', m.pickup_address,
      'delivery_address', m.delivery_address,
      'pickup_contact_name', m.pickup_contact_name,
      'pickup_contact_phone', m.pickup_contact_phone,
      'delivery_contact_name', m.delivery_contact_name,
      'delivery_contact_phone', m.delivery_contact_phone,
      'driver_phone', m.driver_phone,
      'vehicle_type', m.vehicle_type,
      'has_restitution', COALESCE(m.has_restitution, false),
      'restitution_vehicle_brand', m.restitution_vehicle_brand,
      'restitution_vehicle_model', m.restitution_vehicle_model,
      'restitution_vehicle_plate', m.restitution_vehicle_plate,
      'restitution_pickup_address', m.restitution_pickup_address,
      'restitution_delivery_address', m.restitution_delivery_address,
      'restitution_pickup_date', m.restitution_pickup_date,
      'restitution_delivery_date', m.restitution_delivery_date,
      'driver_name', COALESCE(
        (
          SELECT vi.driver_name
          FROM vehicle_inspections vi
          WHERE vi.mission_id = m.id AND vi.inspection_type = 'departure'
          ORDER BY vi.created_at DESC
          LIMIT 1
        ),
        (
          SELECT vi.driver_name
          FROM vehicle_inspections vi
          WHERE vi.mission_id = m.id AND vi.inspection_type = 'arrival'
          ORDER BY vi.created_at DESC
          LIMIT 1
        )
      )
    ),
    'vehicle_data', jsonb_build_object(
      'brand', m.vehicle_brand,
      'model', m.vehicle_model,
      'plate', m.vehicle_plate,
      'vin', m.vehicle_vin,
      'year', m.vehicle_year,
      'color', m.vehicle_color
    ),
    'inspection_departure', (
      SELECT jsonb_build_object(
        'id', vi.id,
        'created_at', vi.created_at,
        'completed_at', vi.completed_at,
        'mileage_km', vi.mileage_km,
        'fuel_level', vi.fuel_level,
        'cleanliness_interior', vi.internal_cleanliness,
        'cleanliness_exterior', vi.external_cleanliness,
        'overall_condition', vi.overall_condition,
        'vehicle_info', vi.vehicle_info,
        'notes', vi.notes,
        'driver_name', vi.driver_name,
        'client_name', vi.client_name,
        'driver_signature', vi.driver_signature,
        'client_signature', vi.client_signature,
        'latitude', vi.latitude,
        'longitude', vi.longitude,
        'photos', (
          SELECT COALESCE(jsonb_agg(jsonb_build_object(
            'id', ip.id,
            'photo_url', ip.full_url,
            'thumbnail_url', ip.thumbnail_url,
            'photo_type', ip.photo_type,
            'taken_at', ip.taken_at
          ) ORDER BY ip.taken_at), '[]'::jsonb)
          FROM inspection_photos_v2 ip
          WHERE ip.inspection_id = vi.id
        ),
        'scanned_documents', (
          SELECT COALESCE(jsonb_agg(jsonb_build_object(
            'id', doc.id,
            'document_url', doc.document_url,
            'document_type', doc.document_type,
            'document_title', doc.document_title,
            'title', COALESCE(doc.document_title, doc.document_type, 'Document'),
            'file_url', doc.document_url,
            'created_at', doc.created_at
          ) ORDER BY doc.created_at), '[]'::jsonb)
          FROM inspection_documents doc
          WHERE doc.inspection_id = vi.id
        )
      )
      FROM vehicle_inspections vi
      WHERE vi.mission_id = m.id
        AND vi.inspection_type = 'departure'
      ORDER BY vi.created_at DESC
      LIMIT 1
    ),
    'inspection_arrival', (
      SELECT jsonb_build_object(
        'id', vi.id,
        'created_at', vi.created_at,
        'completed_at', vi.completed_at,
        'mileage_km', vi.mileage_km,
        'fuel_level', vi.fuel_level,
        'cleanliness_interior', vi.internal_cleanliness,
        'cleanliness_exterior', vi.external_cleanliness,
        'overall_condition', vi.overall_condition,
        'vehicle_info', vi.vehicle_info,
        'notes', vi.notes,
        'driver_name', vi.driver_name,
        'client_name', vi.client_name,
        'driver_signature', vi.driver_signature,
        'client_signature', vi.client_signature,
        'latitude', vi.latitude,
        'longitude', vi.longitude,
        'photos', (
          SELECT COALESCE(jsonb_agg(jsonb_build_object(
            'id', ip.id,
            'photo_url', ip.full_url,
            'thumbnail_url', ip.thumbnail_url,
            'photo_type', ip.photo_type,
            'taken_at', ip.taken_at
          ) ORDER BY ip.taken_at), '[]'::jsonb)
          FROM inspection_photos_v2 ip
          WHERE ip.inspection_id = vi.id
        ),
        'scanned_documents', (
          SELECT COALESCE(jsonb_agg(jsonb_build_object(
            'id', doc.id,
            'document_url', doc.document_url,
            'document_type', doc.document_type,
            'document_title', doc.document_title,
            'title', COALESCE(doc.document_title, doc.document_type, 'Document'),
            'file_url', doc.document_url,
            'created_at', doc.created_at
          ) ORDER BY doc.created_at), '[]'::jsonb)
          FROM inspection_documents doc
          WHERE doc.inspection_id = vi.id
        )
      )
      FROM vehicle_inspections vi
      WHERE vi.mission_id = m.id
        AND vi.inspection_type = 'arrival'
      ORDER BY vi.created_at DESC
      LIMIT 1
    ),
    'inspection_restitution_departure', (
      SELECT jsonb_build_object(
        'id', vi.id,
        'created_at', vi.created_at,
        'completed_at', vi.completed_at,
        'mileage_km', vi.mileage_km,
        'fuel_level', vi.fuel_level,
        'cleanliness_interior', vi.internal_cleanliness,
        'cleanliness_exterior', vi.external_cleanliness,
        'overall_condition', vi.overall_condition,
        'vehicle_info', vi.vehicle_info,
        'notes', vi.notes,
        'driver_name', vi.driver_name,
        'client_name', vi.client_name,
        'driver_signature', vi.driver_signature,
        'client_signature', vi.client_signature,
        'latitude', vi.latitude,
        'longitude', vi.longitude,
        'photos', (
          SELECT COALESCE(jsonb_agg(jsonb_build_object(
            'id', ip.id,
            'photo_url', ip.full_url,
            'thumbnail_url', ip.thumbnail_url,
            'photo_type', ip.photo_type,
            'taken_at', ip.taken_at
          ) ORDER BY ip.taken_at), '[]'::jsonb)
          FROM inspection_photos_v2 ip
          WHERE ip.inspection_id = vi.id
        ),
        'scanned_documents', (
          SELECT COALESCE(jsonb_agg(jsonb_build_object(
            'id', doc.id,
            'document_url', doc.document_url,
            'document_type', doc.document_type,
            'document_title', doc.document_title,
            'title', COALESCE(doc.document_title, doc.document_type, 'Document'),
            'file_url', doc.document_url,
            'created_at', doc.created_at
          ) ORDER BY doc.created_at), '[]'::jsonb)
          FROM inspection_documents doc
          WHERE doc.inspection_id = vi.id
        )
      )
      FROM vehicle_inspections vi
      WHERE vi.mission_id = m.id
        AND vi.inspection_type = 'restitution_departure'
      ORDER BY vi.created_at DESC
      LIMIT 1
    ),
    'inspection_restitution_arrival', (
      SELECT jsonb_build_object(
        'id', vi.id,
        'created_at', vi.created_at,
        'completed_at', vi.completed_at,
        'mileage_km', vi.mileage_km,
        'fuel_level', vi.fuel_level,
        'cleanliness_interior', vi.internal_cleanliness,
        'cleanliness_exterior', vi.external_cleanliness,
        'overall_condition', vi.overall_condition,
        'vehicle_info', vi.vehicle_info,
        'notes', vi.notes,
        'driver_name', vi.driver_name,
        'client_name', vi.client_name,
        'driver_signature', vi.driver_signature,
        'client_signature', vi.client_signature,
        'latitude', vi.latitude,
        'longitude', vi.longitude,
        'photos', (
          SELECT COALESCE(jsonb_agg(jsonb_build_object(
            'id', ip.id,
            'photo_url', ip.full_url,
            'thumbnail_url', ip.thumbnail_url,
            'photo_type', ip.photo_type,
            'taken_at', ip.taken_at
          ) ORDER BY ip.taken_at), '[]'::jsonb)
          FROM inspection_photos_v2 ip
          WHERE ip.inspection_id = vi.id
        ),
        'scanned_documents', (
          SELECT COALESCE(jsonb_agg(jsonb_build_object(
            'id', doc.id,
            'document_url', doc.document_url,
            'document_type', doc.document_type,
            'document_title', doc.document_title,
            'title', COALESCE(doc.document_title, doc.document_type, 'Document'),
            'file_url', doc.document_url,
            'created_at', doc.created_at
          ) ORDER BY doc.created_at), '[]'::jsonb)
          FROM inspection_documents doc
          WHERE doc.inspection_id = vi.id
        )
      )
      FROM vehicle_inspections vi
      WHERE vi.mission_id = m.id
        AND vi.inspection_type = 'restitution_arrival'
      ORDER BY vi.created_at DESC
      LIMIT 1
    ),
    'report_type', v_share_record.report_type
  ) INTO v_result
  FROM missions m
  WHERE m.id = v_share_record.mission_id;

  RETURN v_result;
END;
$$;


ALTER FUNCTION public.get_inspection_report_by_token(p_token text) OWNER TO postgres;

--
-- Name: get_latest_position(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_latest_position(p_mission_id uuid) RETURNS TABLE(id uuid, mission_id uuid, user_id uuid, latitude numeric, longitude numeric, speed_kmh numeric, heading numeric, accuracy numeric, recorded_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    tp.id,
    tp.mission_id,
    tp.user_id,
    tp.latitude,
    tp.longitude,
    tp.speed_kmh,
    tp.heading,
    tp.accuracy,
    tp.recorded_at
  FROM public.tracking_positions tp
  WHERE tp.mission_id = p_mission_id
  ORDER BY tp.recorded_at DESC
  LIMIT 1;
END;
$$;


ALTER FUNCTION public.get_latest_position(p_mission_id uuid) OWNER TO postgres;

--
-- Name: get_legal_mentions(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_legal_mentions(p_vat_regime text, p_vat_liable boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_mentions text;
BEGIN
  -- Mentions selon le r√©gime fiscal
  CASE p_vat_regime
    WHEN 'micro' THEN
      v_mentions := E'TVA non applicable - Article 293 B du Code G√©n√©ral des Imp√¥ts.\n' ||
                    E'Micro-entrepreneur b√©n√©ficiant du r√©gime fiscal de la micro-entreprise.\n' ||
                    E'En cas de retard de paiement, indemnit√© forfaitaire l√©gale pour frais de recouvrement : 40 euros (article L.441-6 du Code de commerce).\n' ||
                    E'Aucun escompte en cas de paiement anticip√©.';
    
    WHEN 'franchise' THEN
      v_mentions := E'TVA non applicable - Article 293 B du Code G√©n√©ral des Imp√¥ts (franchise en base de TVA).\n' ||
                    E'En cas de retard de paiement, indemnit√© forfaitaire l√©gale pour frais de recouvrement : 40 euros (article L.441-6 du Code de commerce).\n' ||
                    E'P√©nalit√©s de retard en cas de paiement tardif : taux BCE + 10 points.\n' ||
                    E'Aucun escompte en cas de paiement anticip√©.';
    
    ELSE -- 'normal'
      IF p_vat_liable THEN
        v_mentions := E'TVA applicable selon le taux en vigueur.\n' ||
                      E'En cas de retard de paiement, indemnit√© forfaitaire l√©gale pour frais de recouvrement : 40 euros (article L.441-6 du Code de commerce).\n' ||
                      E'P√©nalit√©s de retard en cas de paiement tardif : taux BCE + 10 points.\n' ||
                      E'Aucun escompte en cas de paiement anticip√©.\n' ||
                      E'R√®glement par virement bancaire ou ch√®que.';
      ELSE
        v_mentions := E'TVA non applicable - Prestation de service exon√©r√©e.\n' ||
                      E'En cas de retard de paiement, indemnit√© forfaitaire l√©gale pour frais de recouvrement : 40 euros (article L.441-6 du Code de commerce).\n' ||
                      E'Aucun escompte en cas de paiement anticip√©.';
      END IF;
  END CASE;

  RETURN v_mentions;
END;
$$;


ALTER FUNCTION public.get_legal_mentions(p_vat_regime text, p_vat_liable boolean) OWNER TO postgres;

--
-- Name: get_mission_inspection_ids(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_mission_inspection_ids(p_mission_id uuid) RETURNS TABLE(departure_id uuid, arrival_id uuid)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    (SELECT id FROM vehicle_inspections 
     WHERE mission_id = p_mission_id AND inspection_type = 'departure' 
     ORDER BY created_at DESC LIMIT 1) as departure_id,
    (SELECT id FROM vehicle_inspections 
     WHERE mission_id = p_mission_id AND inspection_type = 'arrival' 
     ORDER BY created_at DESC LIMIT 1) as arrival_id;
END;
$$;


ALTER FUNCTION public.get_mission_inspection_ids(p_mission_id uuid) OWNER TO postgres;

--
-- Name: get_mission_last_position(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_mission_last_position(p_mission_id uuid) RETURNS TABLE(latitude double precision, longitude double precision, speed double precision, bearing double precision, last_update timestamp with time zone, battery_level integer, is_active boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    mtl.latitude,
    mtl.longitude,
    mtl.speed,
    mtl.bearing,
    mtl.last_update,
    mtl.battery_level,
    mtl.is_active
  FROM mission_tracking_live mtl
  WHERE mtl.mission_id = p_mission_id
  AND mtl.is_active = true
  ORDER BY mtl.last_update DESC
  LIMIT 1;
END;
$$;


ALTER FUNCTION public.get_mission_last_position(p_mission_id uuid) OWNER TO postgres;

--
-- Name: get_mission_positions(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_mission_positions(p_mission_id uuid, p_limit integer DEFAULT 100) RETURNS TABLE(id uuid, latitude numeric, longitude numeric, speed_kmh numeric, heading numeric, recorded_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    tp.id,
    tp.latitude,
    tp.longitude,
    tp.speed_kmh,
    tp.heading,
    tp.recorded_at
  FROM public.tracking_positions tp
  WHERE tp.mission_id = p_mission_id
  ORDER BY tp.recorded_at DESC
  LIMIT p_limit;
END;
$$;


ALTER FUNCTION public.get_mission_positions(p_mission_id uuid, p_limit integer) OWNER TO postgres;

--
-- Name: get_monthly_revenue(uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_monthly_revenue(p_user_id uuid, p_month_key text DEFAULT NULL::text) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_month_key text;
  v_total_revenue numeric;
BEGIN
  -- Utiliser le mois actuel si non sp√©cifi√©
  v_month_key := COALESCE(p_month_key, TO_CHAR(NOW(), 'YYYY-MM'));
  
  -- Calculer le total des revenus
  SELECT COALESCE(SUM(amount), 0)
  INTO v_total_revenue
  FROM public.mission_revenue_logs
  WHERE user_id = p_user_id AND month_key = v_month_key;
  
  RETURN v_total_revenue;
END;
$$;


ALTER FUNCTION public.get_monthly_revenue(p_user_id uuid, p_month_key text) OWNER TO postgres;

--
-- Name: get_navigation_quota_projection(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_navigation_quota_projection() RETURNS TABLE(jour_actuel integer, jours_restants integer, quota_utilise bigint, quota_restant bigint, moyenne_par_jour numeric, projection_fin_mois numeric, depassement_prevu boolean, sessions_max_par_jour numeric, statut text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  current_day INTEGER;
  days_in_month INTEGER;
  days_remaining INTEGER;
  used_quota BIGINT;
  avg_daily NUMERIC;
  projected NUMERIC;
BEGIN
  -- Calculer le jour actuel et jours restants
  current_day := DATE_PART('day', NOW())::INTEGER;
  days_in_month := DATE_PART('day', (DATE_TRUNC('month', NOW()) + INTERVAL '1 month - 1 day'))::INTEGER;
  days_remaining := days_in_month - current_day;
  
  -- Quota utilis√© ce mois
  SELECT COUNT(*) FILTER (WHERE from_cache = FALSE)
  INTO used_quota
  FROM navigation_sessions
  WHERE created_at >= DATE_TRUNC('month', NOW());
  
  -- Moyenne quotidienne
  avg_daily := CASE 
    WHEN current_day > 0 THEN used_quota::NUMERIC / current_day
    ELSE 0
  END;
  
  -- Projection fin de mois
  projected := used_quota + (avg_daily * days_remaining);
  
  RETURN QUERY
  SELECT 
    current_day,
    days_remaining,
    used_quota,
    (25000 - used_quota)::BIGINT,
    ROUND(avg_daily, 1),
    ROUND(projected, 0),
    projected > 25000,
    ROUND((25000 - used_quota)::NUMERIC / NULLIF(days_remaining, 0), 1),
    CASE 
      WHEN projected > 25000 THEN 'üö® D√âPASSEMENT PR√âVU'
      WHEN projected > 23000 THEN '‚ö†Ô∏è RISQUE √âLEV√â'
      WHEN projected > 20000 THEN '‚ö†Ô∏è SURVEILLER'
      ELSE '‚úÖ ON TRACK'
    END;
END;
$$;


ALTER FUNCTION public.get_navigation_quota_projection() OWNER TO postgres;

--
-- Name: FUNCTION get_navigation_quota_projection(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_navigation_quota_projection() IS 'Projection quota fin de mois bas√©e sur moyenne actuelle';


--
-- Name: get_notification_summary(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_notification_summary(days_back integer DEFAULT 7) RETURNS TABLE(total_sent bigint, total_received bigint, total_clicked bigint, overall_open_rate numeric, active_users bigint, active_devices bigint, most_common_type text, most_common_channel text)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*) FILTER (WHERE action = 'sent') as total_sent,
    COUNT(*) FILTER (WHERE action = 'received') as total_received,
    COUNT(*) FILTER (WHERE action = 'clicked') as total_clicked,
    ROUND(
      COUNT(*) FILTER (WHERE action = 'clicked')::NUMERIC / 
      NULLIF(COUNT(*) FILTER (WHERE action = 'received'), 0) * 100, 
      1
    ) as overall_open_rate,
    COUNT(DISTINCT n.user_id) as active_users,
    (SELECT COUNT(*) FROM user_devices WHERE last_active >= NOW() - INTERVAL '1 day' * days_back) as active_devices,
    (
      SELECT type 
      FROM notification_logs 
      WHERE created_at >= NOW() - INTERVAL '1 day' * days_back
      GROUP BY type 
      ORDER BY COUNT(*) DESC 
      LIMIT 1
    ) as most_common_type,
    (
      SELECT channel 
      FROM notification_logs 
      WHERE created_at >= NOW() - INTERVAL '1 day' * days_back
      GROUP BY channel 
      ORDER BY COUNT(*) DESC 
      LIMIT 1
    ) as most_common_channel
  FROM notification_logs n
  WHERE n.created_at >= NOW() - INTERVAL '1 day' * days_back;
END;
$$;


ALTER FUNCTION public.get_notification_summary(days_back integer) OWNER TO postgres;

--
-- Name: FUNCTION get_notification_summary(days_back integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_notification_summary(days_back integer) IS 'R√©sum√© complet des statistiques de notifications';


--
-- Name: get_optimized_tracking_positions(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_optimized_tracking_positions(p_session_id uuid, p_limit integer DEFAULT 1000) RETURNS TABLE(id uuid, latitude double precision, longitude double precision, speed_kmh double precision, heading double precision, accuracy double precision, recorded_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.id,
    p.latitude,
    p.longitude,
    p.speed_kmh,
    p.heading,
    p.accuracy,
    p.recorded_at
  FROM gps_location_points p
  WHERE p.session_id = p_session_id
    AND p.is_valid = TRUE  -- Filtrer positions invalides
    AND p.accuracy <= 50   -- Max 50m pr√©cision
  ORDER BY p.recorded_at DESC
  LIMIT p_limit;
END;
$$;


ALTER FUNCTION public.get_optimized_tracking_positions(p_session_id uuid, p_limit integer) OWNER TO postgres;

--
-- Name: get_planning_visibility(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_planning_visibility(p_planning_id uuid) RETURNS TABLE(city text, lat double precision, lng double precision, is_expired boolean, is_active boolean, eta_minutes integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_planning RECORD;
  v_now TIMESTAMPTZ := now();
BEGIN
  SELECT * INTO v_planning FROM convoy_plannings WHERE id = p_planning_id;
  IF v_planning IS NULL THEN RETURN; END IF;

  -- Origine
  RETURN QUERY SELECT 
    v_planning.origin_city,
    v_planning.origin_lat,
    v_planning.origin_lng,
    -- L'origine expire apr√®s start_time + flexibility
    (v_now > (v_planning.planning_date + v_planning.start_time) + 
      (COALESCE(v_planning.flexibility_minutes, 30) * INTERVAL '1 minute'))::BOOLEAN,
    (v_planning.status = 'published' AND v_now < v_planning.expires_at)::BOOLEAN,
    0;

  -- Waypoints (√©tapes interm√©diaires = villes desservies sur le retour)
  RETURN QUERY SELECT 
    pw.city,
    pw.lat,
    pw.lng,
    -- Un waypoint expire apr√®s son estimated_arrival
    (pw.estimated_arrival IS NOT NULL AND v_now > pw.estimated_arrival)::BOOLEAN,
    -- Actif si pas expir√© et planning pas fini
    (v_planning.status = 'published' AND 
     (pw.estimated_arrival IS NULL OR v_now <= pw.estimated_arrival) AND
     pw.sort_order >= v_planning.current_waypoint_index)::BOOLEAN,
    pw.eta_minutes;

  -- Destination
  RETURN QUERY SELECT 
    v_planning.destination_city,
    v_planning.destination_lat,
    v_planning.destination_lng,
    (v_now > v_planning.expires_at)::BOOLEAN,
    (v_planning.status = 'published' AND v_now < v_planning.expires_at)::BOOLEAN,
    EXTRACT(EPOCH FROM (v_planning.expires_at - (v_planning.planning_date + v_planning.start_time)))::INTEGER / 60;

  RETURN;
END;
$$;


ALTER FUNCTION public.get_planning_visibility(p_planning_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_planning_visibility(p_planning_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_planning_visibility(p_planning_id uuid) IS 'Retourne la visibilit√© de chaque √©tape du planning (expir√©e ou active)';


--
-- Name: get_public_report_data(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_public_report_data(p_share_token text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_report public_inspection_reports;
  v_result jsonb;
BEGIN
  -- R√©cup√©rer le rapport
  SELECT * INTO v_report
  FROM public_inspection_reports
  WHERE share_token = p_share_token;

  IF v_report IS NULL THEN
    RETURN jsonb_build_object('error', 'Report not found');
  END IF;

  -- V√©rifier expiration
  IF v_report.expires_at IS NOT NULL AND v_report.expires_at < now() THEN
    RETURN jsonb_build_object('error', 'Report expired');
  END IF;

  -- Incr√©menter le compteur
  PERFORM increment_report_view_count(p_share_token);

  -- Construire le r√©sultat complet
  SELECT jsonb_build_object(
    'share_token', v_report.share_token,
    'created_at', v_report.created_at,
    'view_count', v_report.view_count + 1,
    'mission', (
      SELECT jsonb_build_object(
        'id', m.id,
        'reference', m.reference,
        'pickup_location', m.pickup_location,
        'delivery_location', m.delivery_location,
        'status', m.status,
        'vehicle', (
          SELECT jsonb_build_object(
            'id', v.id,
            'brand', v.brand,
            'model', v.model,
            'plate', v.plate,
            'vehicle_type', v.vehicle_type
          )
          FROM vehicles v
          WHERE v.id = m.vehicle_id
        )
      )
      FROM missions m
      WHERE m.id = v_report.mission_id
    ),
    'departure', (
      SELECT jsonb_build_object(
        'id', vi.id,
        'inspection_type', vi.inspection_type,
        'datetime', vi.created_at,
        'location', vi.location,
        'notes', vi.notes,
        'driver_signature', vi.driver_signature,
        'client_signature', vi.client_signature,
        'status', vi.status,
        'photos', COALESCE((
          SELECT jsonb_agg(
            jsonb_build_object(
              'id', p.id,
              'photo_url', COALESCE(p.photo_url, p.full_url),
              'thumbnail_url', p.thumbnail_url,
              'photo_type', p.photo_type,
              'created_at', p.created_at
            ) ORDER BY p.created_at
          )
          FROM (
            -- Essayer inspection_photos d'abord
            SELECT id, photo_url, NULL as full_url, NULL as thumbnail_url, photo_type, created_at
            FROM inspection_photos
            WHERE inspection_id = v_report.departure_inspection_id
            UNION ALL
            -- Puis inspection_photos_v2
            SELECT id, NULL as photo_url, full_url, thumbnail_url, photo_type, created_at
            FROM inspection_photos_v2
            WHERE inspection_id = v_report.departure_inspection_id
          ) p
        ), '[]'::jsonb)
      )
      FROM vehicle_inspections vi
      WHERE vi.id = v_report.departure_inspection_id
    ),
    'arrival', (
      SELECT jsonb_build_object(
        'id', vi.id,
        'inspection_type', vi.inspection_type,
        'datetime', vi.created_at,
        'location', vi.location,
        'notes', vi.notes,
        'driver_signature', vi.driver_signature,
        'client_signature', vi.client_signature,
        'status', vi.status,
        'photos', COALESCE((
          SELECT jsonb_agg(
            jsonb_build_object(
              'id', p.id,
              'photo_url', COALESCE(p.photo_url, p.full_url),
              'thumbnail_url', p.thumbnail_url,
              'photo_type', p.photo_type,
              'created_at', p.created_at
            ) ORDER BY p.created_at
          )
          FROM (
            -- Essayer inspection_photos d'abord
            SELECT id, photo_url, NULL as full_url, NULL as thumbnail_url, photo_type, created_at
            FROM inspection_photos
            WHERE inspection_id = v_report.arrival_inspection_id
            UNION ALL
            -- Puis inspection_photos_v2
            SELECT id, NULL as photo_url, full_url, thumbnail_url, photo_type, created_at
            FROM inspection_photos_v2
            WHERE inspection_id = v_report.arrival_inspection_id
          ) p
        ), '[]'::jsonb)
      )
      FROM vehicle_inspections vi
      WHERE vi.id = v_report.arrival_inspection_id
    )
  ) INTO v_result;

  RETURN v_result;
END;
$$;


ALTER FUNCTION public.get_public_report_data(p_share_token text) OWNER TO postgres;

--
-- Name: FUNCTION get_public_report_data(p_share_token text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_public_report_data(p_share_token text) IS 'R√©cup√®re toutes les donn√©es d''un rapport public par token, incluant mission, v√©hicule, inspections, photos et signatures.';


--
-- Name: get_revenue_breakdown(uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_revenue_breakdown(p_user_id uuid, p_month_key text DEFAULT NULL::text) RETURNS TABLE(revenue_type text, total_amount numeric, count_missions bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_month_key text;
BEGIN
  v_month_key := COALESCE(p_month_key, TO_CHAR(NOW(), 'YYYY-MM'));
  
  RETURN QUERY
  SELECT 
    mrl.revenue_type,
    SUM(mrl.amount) as total_amount,
    COUNT(DISTINCT mrl.mission_id) as count_missions
  FROM public.mission_revenue_logs mrl
  WHERE mrl.user_id = p_user_id AND mrl.month_key = v_month_key
  GROUP BY mrl.revenue_type;
END;
$$;


ALTER FUNCTION public.get_revenue_breakdown(p_user_id uuid, p_month_key text) OWNER TO postgres;

--
-- Name: get_unread_messages_count(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_unread_messages_count(user_uuid uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)::INTEGER
    FROM carpooling_messages
    WHERE receiver_id = user_uuid AND is_read = FALSE
  );
END;
$$;


ALTER FUNCTION public.get_unread_messages_count(user_uuid uuid) OWNER TO postgres;

--
-- Name: get_user_average_rating(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_average_rating(user_uuid uuid) RETURNS numeric
    LANGUAGE sql STABLE
    AS $$
SELECT ROUND(AVG(rating)::decimal, 1)
FROM carpooling_reviews
WHERE reviewed_id = user_uuid;
$$;


ALTER FUNCTION public.get_user_average_rating(user_uuid uuid) OWNER TO postgres;

--
-- Name: get_user_credits(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_credits(p_user_id uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  user_credits_amount INTEGER;
BEGIN
  SELECT credits INTO user_credits_amount
  FROM user_credits
  WHERE user_id = p_user_id;
  
  RETURN COALESCE(user_credits_amount, 0);
END;
$$;


ALTER FUNCTION public.get_user_credits(p_user_id uuid) OWNER TO postgres;

--
-- Name: get_user_ride_rating(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_ride_rating(p_user_id uuid) RETURNS TABLE(avg_rating numeric, total_ratings integer, badges jsonb)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ROUND(AVG(rr.rating)::numeric, 1) AS avg_rating,
    COUNT(*)::INTEGER AS total_ratings,
    COALESCE(
      jsonb_agg(DISTINCT badge) FILTER (WHERE badge IS NOT NULL),
      '[]'::jsonb
    ) AS badges
  FROM ride_ratings rr
  LEFT JOIN LATERAL jsonb_array_elements_text(rr.badges) AS badge ON true
  WHERE rr.rated_id = p_user_id;
END;
$$;


ALTER FUNCTION public.get_user_ride_rating(p_user_id uuid) OWNER TO postgres;

--
-- Name: get_user_storage_usage(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_storage_usage(user_uuid uuid) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  total_size BIGINT;
BEGIN
  SELECT COALESCE(SUM(file_size), 0)
  INTO total_size
  FROM attachments
  WHERE user_id = user_uuid;
  
  RETURN total_size;
END;
$$;


ALTER FUNCTION public.get_user_storage_usage(user_uuid uuid) OWNER TO postgres;

--
-- Name: get_wallet_balance(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_wallet_balance(p_user_id uuid) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_balance NUMERIC;
BEGIN
  SELECT COALESCE(wallet_balance, 0) INTO v_balance
  FROM public.profiles
  WHERE id = p_user_id;

  RETURN COALESCE(v_balance, 0);
END;
$$;


ALTER FUNCTION public.get_wallet_balance(p_user_id uuid) OWNER TO postgres;

--
-- Name: handle_new_user(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.handle_new_user() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_full_name TEXT;
  v_first_name TEXT;
  v_last_name TEXT;
BEGIN
  -- Split full_name from metadata into first_name + last_name
  v_full_name := COALESCE(NEW.raw_user_meta_data->>'full_name', '');
  v_first_name := SPLIT_PART(v_full_name, ' ', 1);
  v_last_name := CASE 
    WHEN v_full_name LIKE '% %' THEN SUBSTRING(v_full_name FROM POSITION(' ' IN v_full_name) + 1)
    ELSE ''
  END;

  -- Insert profile (never fail on conflict)
  -- full_name is GENERATED ALWAYS from first_name || ' ' || last_name ‚Äî do NOT insert it!
  INSERT INTO public.profiles (
    id, 
    email, 
    first_name,
    last_name,
    phone, 
    user_type, 
    avatar_url,
    device_fingerprint, 
    registration_ip, 
    app_role,
    credits,
    created_at, 
    updated_at
  ) VALUES (
    NEW.id,
    COALESCE(NEW.email, NEW.raw_user_meta_data->>'email', ''),
    v_first_name,
    v_last_name,
    NULLIF(COALESCE(NEW.raw_user_meta_data->>'phone', ''), ''),
    COALESCE(NEW.raw_user_meta_data->>'user_type', 'individual'),
    NEW.raw_user_meta_data->>'avatar_url',
    NEW.raw_user_meta_data->>'device_fingerprint',
    NEW.raw_user_meta_data->>'registration_ip',
    COALESCE(NEW.raw_user_meta_data->>'app_role', 'convoyeur'),
    0,
    NOW(), 
    NOW()
  )
  ON CONFLICT (id) DO UPDATE SET
    email = COALESCE(EXCLUDED.email, profiles.email),
    first_name = COALESCE(NULLIF(EXCLUDED.first_name, ''), profiles.first_name),
    last_name = COALESCE(NULLIF(EXCLUDED.last_name, ''), profiles.last_name),
    updated_at = NOW();

  -- Insert user credits (never fail on conflict)
  INSERT INTO public.user_credits (user_id, balance, updated_at)
  VALUES (NEW.id, 0, NOW())
  ON CONFLICT (user_id) DO NOTHING;

  -- Insert subscription (never fail on conflict)
  INSERT INTO public.subscriptions (user_id, plan, status, created_at, updated_at)
  VALUES (NEW.id, 'free', 'active', NOW(), NOW())
  ON CONFLICT (user_id) DO NOTHING;

  RETURN NEW;

EXCEPTION
  WHEN OTHERS THEN
    -- NEVER block user creation - log the error and continue
    RAISE WARNING '[handle_new_user] Error for user %: % (SQLSTATE: %)', 
      NEW.id, SQLERRM, SQLSTATE;
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.handle_new_user() OWNER TO postgres;

--
-- Name: FUNCTION handle_new_user(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.handle_new_user() IS 'Trigger automatique: cr√©e profil apr√®s signup Supabase Auth';


--
-- Name: handle_ride_match_status_change(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.handle_ride_match_status_change() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Quand un match passe en 'accepted'
  IF NEW.status = 'accepted' AND OLD.status != 'accepted' THEN
    UPDATE ride_offers 
    SET seats_available = GREATEST(0, seats_available - 1), updated_at = NOW()
    WHERE id = NEW.offer_id;
    UPDATE ride_requests 
    SET status = 'matched', updated_at = NOW()
    WHERE id = NEW.request_id AND status = 'active';
  END IF;
  
  -- Quand le trajet d√©marre (in_transit)
  IF NEW.status = 'in_transit' AND OLD.status = 'accepted' THEN
    UPDATE ride_offers 
    SET status = 'en_route', updated_at = NOW()
    WHERE id = NEW.offer_id AND status = 'active';
  END IF;
  
  -- Quand un match est compl√©t√©
  IF NEW.status = 'completed' AND OLD.status IN ('accepted', 'in_transit') THEN
    UPDATE ride_offers
    SET status = CASE WHEN seats_available <= 0 THEN 'completed' ELSE status END,
        updated_at = NOW()
    WHERE id = NEW.offer_id;
    UPDATE ride_requests
    SET status = 'completed', updated_at = NOW()
    WHERE id = NEW.request_id;
  END IF;
  
  -- Quand un match est d√©clin√© ou annul√© apr√®s avoir √©t√© accept√©/in_transit
  IF NEW.status IN ('declined', 'cancelled') AND OLD.status IN ('accepted', 'in_transit') THEN
    UPDATE ride_offers 
    SET seats_available = seats_available + 1,
        status = CASE WHEN status = 'en_route' THEN 'active' ELSE status END,
        updated_at = NOW()
    WHERE id = NEW.offer_id;
    UPDATE ride_requests
    SET status = 'active', updated_at = NOW()
    WHERE id = NEW.request_id AND status = 'matched';
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.handle_ride_match_status_change() OWNER TO postgres;

--
-- Name: FUNCTION handle_ride_match_status_change(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.handle_ride_match_status_change() IS 'G√®re les effets de bord quand un match change de statut: places, request status';


--
-- Name: has_active_subscription(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.has_active_subscription(p_user_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 
    FROM user_credits 
    WHERE user_id = p_user_id 
    AND subscription_expires_at > now()
  );
END;
$$;


ALTER FUNCTION public.has_active_subscription(p_user_id uuid) OWNER TO postgres;

--
-- Name: has_sufficient_credits(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.has_sufficient_credits(p_user_id uuid, p_required_amount integer) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN (
    SELECT COALESCE(credits, 0) >= p_required_amount
    FROM user_credits
    WHERE user_id = p_user_id
  );
END;
$$;


ALTER FUNCTION public.has_sufficient_credits(p_user_id uuid, p_required_amount integer) OWNER TO postgres;

--
-- Name: increment_ai_request(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.increment_ai_request(p_user_id uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_month_key text;
  v_current_count integer;
BEGIN
  -- Obtenir la cl√© du mois actuel
  v_month_key := get_current_month_key();
  
  -- Ins√©rer ou mettre √† jour le compteur
  INSERT INTO public.ai_requests_usage (user_id, month_key, request_count, last_request_at)
  VALUES (p_user_id, v_month_key, 1, NOW())
  ON CONFLICT (user_id, month_key)
  DO UPDATE SET
    request_count = ai_requests_usage.request_count + 1,
    last_request_at = NOW(),
    updated_at = NOW()
  RETURNING request_count INTO v_current_count;
  
  RETURN v_current_count;
END;
$$;


ALTER FUNCTION public.increment_ai_request(p_user_id uuid) OWNER TO postgres;

--
-- Name: increment_report_view_count(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.increment_report_view_count(p_share_token text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  UPDATE public_inspection_reports
  SET 
    view_count = view_count + 1,
    last_viewed_at = now()
  WHERE share_token = p_share_token;
END;
$$;


ALTER FUNCTION public.increment_report_view_count(p_share_token text) OWNER TO postgres;

--
-- Name: increment_tracking_access(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.increment_tracking_access(p_token text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  UPDATE public_tracking_links
  SET access_count = access_count + 1,
      last_accessed_at = now()
  WHERE token = p_token
    AND is_active = true
    AND expires_at > now();
END;
$$;


ALTER FUNCTION public.increment_tracking_access(p_token text) OWNER TO postgres;

--
-- Name: inspection_photos_delete_trigger(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.inspection_photos_delete_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  DELETE FROM inspection_photos_v2
  WHERE id = OLD.id;
  
  RETURN OLD;
END;
$$;


ALTER FUNCTION public.inspection_photos_delete_trigger() OWNER TO postgres;

--
-- Name: inspection_photos_insert_trigger(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.inspection_photos_insert_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO inspection_photos_v2 (
    id,
    inspection_id,
    photo_type,
    full_url,
    thumbnail_url,
    file_size_bytes,
    latitude,
    longitude,
    taken_at,
    created_at
  ) VALUES (
    COALESCE(NEW.id, gen_random_uuid()),
    NEW.inspection_id,
    NEW.photo_type,
    NEW.photo_url, -- photo_url de la vue ‚Üí full_url dans v2
    NULL, -- thumbnail √† g√©n√©rer plus tard
    NULL, -- file_size √† calculer
    NEW.latitude,
    NEW.longitude,
    COALESCE(NEW.taken_at, NOW()),
    COALESCE(NEW.created_at, NOW())
  );
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.inspection_photos_insert_trigger() OWNER TO postgres;

--
-- Name: inspection_photos_update_trigger(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.inspection_photos_update_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE inspection_photos_v2
  SET
    photo_type = NEW.photo_type,
    full_url = NEW.photo_url,
    latitude = NEW.latitude,
    longitude = NEW.longitude,
    taken_at = NEW.taken_at
  WHERE id = OLD.id;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.inspection_photos_update_trigger() OWNER TO postgres;

--
-- Name: is_inspection_complete(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_inspection_complete(p_inspection_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_inspection RECORD;
  v_photo_count INTEGER;
  v_required_photos INTEGER := 4; -- Minimum requis
BEGIN
  -- R√©cup√©rer l'inspection (p_ pour param√®tre)
  SELECT * INTO v_inspection
  FROM vehicle_inspections
  WHERE id = p_inspection_id;
  
  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;
  
  -- V√©rifier signatures
  IF v_inspection.client_signature IS NULL OR v_inspection.driver_signature IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Compter les photos
  SELECT COUNT(*) INTO v_photo_count
  FROM inspection_photos_v2
  WHERE inspection_id = p_inspection_id;
  
  -- Retourner true si assez de photos
  RETURN v_photo_count >= v_required_photos;
END;
$$;


ALTER FUNCTION public.is_inspection_complete(p_inspection_id uuid) OWNER TO postgres;

--
-- Name: join_mission_v2(text, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.join_mission_v2(p_share_code text, p_user_id uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_mission_id UUID;
    v_creator_id UUID;
    v_current_assigned_id UUID;
    v_status TEXT;
BEGIN
    SELECT id, user_id, assigned_user_id, status
    INTO v_mission_id, v_creator_id, v_current_assigned_id, v_status
    FROM missions 
    WHERE UPPER(TRIM(REPLACE(share_code, '-', ''))) = UPPER(TRIM(REPLACE(p_share_code, '-', '')))
    LIMIT 1;
    
    IF v_mission_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Code invalide', 'message', 'Aucune mission trouv√©e avec ce code');
    END IF;
    
    IF v_creator_id = p_user_id THEN
        RETURN json_build_object('success', false, 'error', 'Mission propre', 'message', 'Vous ne pouvez pas rejoindre votre propre mission');
    END IF;
    
    IF v_current_assigned_id IS NOT NULL AND v_current_assigned_id != p_user_id THEN
        RETURN json_build_object('success', false, 'error', 'Mission d√©j√† assign√©e', 'message', 'Cette mission a d√©j√† √©t√© assign√©e √† un autre utilisateur');
    END IF;
    
    IF v_status IN ('cancelled', 'completed') THEN
        RETURN json_build_object('success', false, 'error', 'Mission termin√©e', 'message', 'Cette mission est d√©j√† termin√©e ou annul√©e');
    END IF;
    
    -- Assigner SANS changer le statut
    UPDATE missions 
    SET 
        assigned_user_id = p_user_id,
        -- Le statut reste tel quel (pending) jusqu'au d√©marrage de l'inspection
        updated_at = NOW()
    WHERE id = v_mission_id;
    
    RETURN json_build_object(
        'success', true,
        'mission_id', v_mission_id,
        'message', 'Mission ajout√©e avec succ√®s √† votre liste'
    );
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object('success', false, 'error', 'Erreur serveur', 'message', SQLERRM);
END;
$$;


ALTER FUNCTION public.join_mission_v2(p_share_code text, p_user_id uuid) OWNER TO postgres;

--
-- Name: join_mission_with_code(text, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.join_mission_with_code(p_share_code text, p_user_id uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN claim_mission(p_share_code, p_user_id);
END;
$$;


ALTER FUNCTION public.join_mission_with_code(p_share_code text, p_user_id uuid) OWNER TO postgres;

--
-- Name: lock_inspection(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.lock_inspection(inspection_uuid uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  UPDATE inspections
  SET status = 'locked',
      locked_at = NOW()
  WHERE id = inspection_uuid
    AND status = 'draft';
  
  RETURN FOUND;
END;
$$;


ALTER FUNCTION public.lock_inspection(inspection_uuid uuid) OWNER TO postgres;

--
-- Name: log_account_creation_attempt(text, text, text, text, boolean, text, boolean, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.log_account_creation_attempt(p_email text, p_phone text, p_ip_address text, p_user_agent text, p_success boolean, p_error_message text DEFAULT NULL::text, p_duplicate_detected boolean DEFAULT false, p_existing_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
v_attempt_id uuid;
BEGIN
INSERT INTO account_creation_attempts (
email,
phone,
ip_address,
user_agent,
success,
error_message,
duplicate_detected,
existing_user_id
) VALUES (
p_email,
p_phone,
p_ip_address,
p_user_agent,
p_success,
p_error_message,
p_duplicate_detected,
p_existing_user_id
)
RETURNING id INTO v_attempt_id;

RETURN v_attempt_id;
END;
$$;


ALTER FUNCTION public.log_account_creation_attempt(p_email text, p_phone text, p_ip_address text, p_user_agent text, p_success boolean, p_error_message text, p_duplicate_detected boolean, p_existing_user_id uuid) OWNER TO postgres;

--
-- Name: log_admin_status_change(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.log_admin_status_change() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  IF OLD.is_admin IS DISTINCT FROM NEW.is_admin THEN
    INSERT INTO public.admin_status_audit (
      target_user_id,
      modified_by,
      old_value,
      new_value
    ) VALUES (
      NEW.id,
      auth.uid(),
      OLD.is_admin,
      NEW.is_admin
    );
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.log_admin_status_change() OWNER TO postgres;

--
-- Name: log_mission_revenue(uuid, uuid, text, text, numeric, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.log_mission_revenue(p_mission_id uuid, p_user_id uuid, p_mission_reference text, p_revenue_type text, p_amount numeric, p_description text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_month_key text;
  v_log_id uuid;
BEGIN
  -- Obtenir la cl√© du mois actuel
  v_month_key := TO_CHAR(NOW(), 'YYYY-MM');
  
  -- Ins√©rer le log de revenu
  INSERT INTO public.mission_revenue_logs (
    mission_id,
    user_id,
    mission_reference,
    revenue_type,
    amount,
    description,
    month_key
  )
  VALUES (
    p_mission_id,
    p_user_id,
    p_mission_reference,
    p_revenue_type,
    p_amount,
    p_description,
    v_month_key
  )
  RETURNING id INTO v_log_id;
  
  RETURN v_log_id;
END;
$$;


ALTER FUNCTION public.log_mission_revenue(p_mission_id uuid, p_user_id uuid, p_mission_reference text, p_revenue_type text, p_amount numeric, p_description text) OWNER TO postgres;

--
-- Name: mark_conversation_as_read(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.mark_conversation_as_read(p_trip_id uuid, p_other_user_id uuid, p_current_user_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  UPDATE carpooling_messages
  SET is_read = TRUE
  WHERE trip_id = p_trip_id
    AND sender_id = p_other_user_id
    AND receiver_id = p_current_user_id
    AND is_read = FALSE;
END;
$$;


ALTER FUNCTION public.mark_conversation_as_read(p_trip_id uuid, p_other_user_id uuid, p_current_user_id uuid) OWNER TO postgres;

--
-- Name: mission_has_both_inspections(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.mission_has_both_inspections(p_mission_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_departure_count INT;
  v_arrival_count INT;
BEGIN
  -- Compter les inspections d√©part compl√®tes
  SELECT COUNT(*) INTO v_departure_count
  FROM vehicle_inspections
  WHERE mission_id = p_mission_id
    AND inspection_type = 'departure'
    AND client_signature IS NOT NULL
    AND driver_signature IS NOT NULL;

  -- Compter les inspections arriv√©e compl√®tes
  SELECT COUNT(*) INTO v_arrival_count
  FROM vehicle_inspections
  WHERE mission_id = p_mission_id
    AND inspection_type = 'arrival'
    AND client_signature IS NOT NULL
    AND driver_signature IS NOT NULL;

  RETURN (v_departure_count > 0 AND v_arrival_count > 0);
END;
$$;


ALTER FUNCTION public.mission_has_both_inspections(p_mission_id uuid) OWNER TO postgres;

--
-- Name: notify_booking_status_changed(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.notify_booking_status_changed() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_trip RECORD;
  v_title TEXT;
  v_body TEXT;
  v_notification_data JSONB;
BEGIN
  -- Uniquement si le statut change
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    -- R√©cup√©rer les infos du trajet
    SELECT departure_city, arrival_city INTO v_trip
    FROM carpooling_trips
    WHERE id = NEW.trip_id;
    
    -- Pr√©parer le message selon le statut
    IF NEW.status = 'confirmed' THEN
      v_title = 'R√©servation confirm√©e ‚úÖ';
      v_body = 'Votre r√©servation pour ' || v_trip.departure_city || ' ‚Üí ' || v_trip.arrival_city || ' est confirm√©e !';
    ELSIF NEW.status = 'rejected' THEN
      v_title = 'R√©servation refus√©e ‚ùå';
      v_body = 'Votre demande pour ' || v_trip.departure_city || ' ‚Üí ' || v_trip.arrival_city || ' a √©t√© refus√©e';
    ELSE
      RETURN NEW; -- Pas de notification pour les autres statuts
    END IF;
    
    -- Pr√©parer les donn√©es
    v_notification_data = jsonb_build_object(
      'type', 'booking_' || NEW.status,
      'bookingId', NEW.id,
      'tripId', NEW.trip_id
    );
    
    -- Envoyer la notification au passager
    PERFORM send_push_notification(
      NEW.passenger_id,
      v_title,
      v_body,
      v_notification_data
    );
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.notify_booking_status_changed() OWNER TO postgres;

--
-- Name: FUNCTION notify_booking_status_changed(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.notify_booking_status_changed() IS 'Envoie une notification quand une r√©servation change de statut';


--
-- Name: notify_mission_assigned(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.notify_mission_assigned() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_mission_reference TEXT;
  v_notification_data JSONB;
  v_assigned_user_id UUID;
BEGIN
  -- D√©terminer l'utilisateur assign√© (selon la structure de mission_assignments)
  -- Option 1: Si mission_assignments a une colonne user_id
  v_assigned_user_id := NEW.user_id;
  
  -- Uniquement si un utilisateur est assign√©
  IF v_assigned_user_id IS NOT NULL THEN
    -- R√©cup√©rer la r√©f√©rence de la mission
    SELECT reference INTO v_mission_reference FROM missions WHERE id = NEW.mission_id;
    
    -- Pr√©parer les donn√©es
    v_notification_data = jsonb_build_object(
      'type', 'mission_assigned',
      'missionId', NEW.mission_id,
      'reference', v_mission_reference
    );
    
    -- Envoyer la notification
    PERFORM send_push_notification(
      v_assigned_user_id,
      'Nouvelle mission assign√©e üìã',
      'Mission ' || v_mission_reference || ' vous a √©t√© assign√©e',
      v_notification_data
    );
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.notify_mission_assigned() OWNER TO postgres;

--
-- Name: FUNCTION notify_mission_assigned(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.notify_mission_assigned() IS 'Envoie une notification quand une mission est assign√©e';


--
-- Name: notify_mission_status_changed(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.notify_mission_status_changed() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_assigned_user_id UUID;
  v_status_text TEXT;
  v_notification_data JSONB;
BEGIN
  -- Uniquement si le statut change
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    -- R√©cup√©rer l'utilisateur assign√© depuis la table missions
    v_assigned_user_id := NEW.assigned_user_id;  -- ‚úÖ Utiliser assigned_user_id
    
    -- Si aucun utilisateur assign√©, pas de notification
    IF v_assigned_user_id IS NULL THEN
      RETURN NEW;
    END IF;
    
    -- Texte selon le statut
    CASE NEW.status
      WHEN 'completed' THEN v_status_text := 'termin√©e ‚úÖ';
      WHEN 'cancelled' THEN v_status_text := 'annul√©e ‚ùå';
      WHEN 'in_progress' THEN v_status_text := 'en cours üöÄ';
      ELSE v_status_text := 'mise √† jour üìù';
    END CASE;
    
    -- Pr√©parer les donn√©es
    v_notification_data = jsonb_build_object(
      'type', 'mission_status_changed',
      'missionId', NEW.id,
      'status', NEW.status
    );
    
    -- Envoyer la notification
    PERFORM send_push_notification(
      v_assigned_user_id,
      'Mission ' || v_status_text,
      'Mission ' || NEW.reference || ' : ' || v_status_text,
      v_notification_data
    );
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.notify_mission_status_changed() OWNER TO postgres;

--
-- Name: FUNCTION notify_mission_status_changed(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.notify_mission_status_changed() IS 'Envoie une notification quand le statut d''une mission change';


--
-- Name: notify_new_booking_request(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.notify_new_booking_request() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_trip RECORD;
  v_passenger_name TEXT;
  v_notification_data JSONB;
BEGIN
  -- R√©cup√©rer les infos du trajet et du conducteur
  SELECT t.driver_id, t.departure_city, t.arrival_city INTO v_trip
  FROM carpooling_trips t
  WHERE t.id = NEW.trip_id;
  
  -- R√©cup√©rer le nom du passager
  SELECT full_name INTO v_passenger_name
  FROM profiles
  WHERE id = NEW.passenger_id;
  
  -- Pr√©parer les donn√©es
  v_notification_data = jsonb_build_object(
    'type', 'trip_booking_request',
    'bookingId', NEW.id,
    'tripId', NEW.trip_id
  );
  
  -- Envoyer la notification au conducteur
  PERFORM send_push_notification(
    v_trip.driver_id,
    'Nouvelle demande de r√©servation üöó',
    v_passenger_name || ' souhaite r√©server ' || NEW.seats || ' place(s) pour ' || 
    v_trip.departure_city || ' ‚Üí ' || v_trip.arrival_city,
    v_notification_data
  );
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.notify_new_booking_request() OWNER TO postgres;

--
-- Name: FUNCTION notify_new_booking_request(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.notify_new_booking_request() IS 'Envoie une notification au conducteur pour nouvelle r√©servation';


--
-- Name: notify_new_message(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.notify_new_message() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_sender_name TEXT;
  v_trip RECORD;
  v_notification_data JSONB;
BEGIN
  -- R√©cup√©rer le nom de l'exp√©diteur
  SELECT full_name INTO v_sender_name FROM profiles WHERE id = NEW.sender_id;
  
  -- R√©cup√©rer les infos du trajet
  SELECT departure_city, arrival_city INTO v_trip
  FROM carpooling_trips
  WHERE id = NEW.trip_id;
  
  -- Pr√©parer les donn√©es
  v_notification_data = jsonb_build_object(
    'type', 'message_received',
    'tripId', NEW.trip_id,
    'senderId', NEW.sender_id
  );
  
  -- Envoyer la notification au destinataire
  PERFORM send_push_notification(
    NEW.receiver_id,
    'Nouveau message üí¨',
    v_sender_name || ': ' || LEFT(NEW.content, 50) || 
    CASE WHEN LENGTH(NEW.content) > 50 THEN '...' ELSE '' END,
    v_notification_data
  );
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.notify_new_message() OWNER TO postgres;

--
-- Name: FUNCTION notify_new_message(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.notify_new_message() IS 'Envoie une notification pour nouveau message';


--
-- Name: notify_on_match_change(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.notify_on_match_change() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Nouveau match trouv√©
  IF TG_OP = 'INSERT' THEN
    -- Notifier user_b (celui qui re√ßoit la proposition)
    INSERT INTO planning_notifications (user_id, type, title, body, data) VALUES (
      NEW.user_b_id,
      'new_match',
      'üîÑ Nouveau match trouv√© !',
      'Un convoyeur a un trajet compatible avec le v√¥tre. Score: ' || NEW.match_score || '%',
      jsonb_build_object('match_id', NEW.id, 'match_score', NEW.match_score, 'match_type', NEW.match_type)
    );
  END IF;

  -- Match accept√© ou d√©clin√©
  IF TG_OP = 'UPDATE' AND OLD.status != NEW.status THEN
    IF NEW.status = 'accepted' THEN
      -- Notifier les deux parties
      INSERT INTO planning_notifications (user_id, type, title, body, data) VALUES 
      (
        CASE WHEN NEW.user_a_id = auth.uid() THEN NEW.user_b_id ELSE NEW.user_a_id END,
        'match_accepted',
        '‚úÖ Match accept√© !',
        'Votre proposition de trajet partag√© a √©t√© accept√©e. Ouvrez le chat pour coordonner.',
        jsonb_build_object('match_id', NEW.id)
      );
    ELSIF NEW.status = 'declined' THEN
      INSERT INTO planning_notifications (user_id, type, title, body, data) VALUES (
        CASE WHEN NEW.user_a_id = auth.uid() THEN NEW.user_b_id ELSE NEW.user_a_id END,
        'match_declined',
        'Match d√©clin√©',
        'Votre proposition de trajet a √©t√© d√©clin√©e.',
        jsonb_build_object('match_id', NEW.id)
      );
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.notify_on_match_change() OWNER TO postgres;

--
-- Name: FUNCTION notify_on_match_change(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.notify_on_match_change() IS 'Trigger: cr√©e une notification quand un match est cr√©√©/accept√©/d√©clin√©';


--
-- Name: notify_on_new_message(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.notify_on_new_message() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_match RECORD;
  v_recipient_id UUID;
  v_sender_name TEXT;
BEGIN
  -- R√©cup√©rer le match
  SELECT * INTO v_match FROM planning_matches WHERE id = NEW.match_id;
  IF v_match IS NULL THEN RETURN NEW; END IF;

  -- D√©terminer le destinataire (l'autre personne du match)
  v_recipient_id := CASE 
    WHEN v_match.user_a_id = NEW.sender_id THEN v_match.user_b_id 
    ELSE v_match.user_a_id 
  END;

  -- Nom de l'exp√©diteur
  SELECT COALESCE(first_name || ' ' || last_name, email) INTO v_sender_name
  FROM profiles WHERE id = NEW.sender_id;

  INSERT INTO planning_notifications (user_id, type, title, body, data) VALUES (
    v_recipient_id,
    'new_message',
    'üí¨ ' || COALESCE(v_sender_name, 'Un convoyeur'),
    LEFT(NEW.content, 100),
    jsonb_build_object('match_id', NEW.match_id, 'message_id', NEW.id)
  );

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.notify_on_new_message() OWNER TO postgres;

--
-- Name: FUNCTION notify_on_new_message(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.notify_on_new_message() IS 'Trigger: cr√©e une notification quand un message est envoy√© dans un chat';


--
-- Name: notify_on_ride_match_change(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.notify_on_ride_match_change() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  _driver_name TEXT;
  _passenger_name TEXT;
  _title TEXT;
  _body TEXT;
  _target_user UUID;
BEGIN
  SELECT COALESCE(first_name || ' ' || last_name, 'Un conducteur') INTO _driver_name 
    FROM profiles WHERE id = NEW.driver_id;
  SELECT COALESCE(first_name || ' ' || last_name, 'Un passager') INTO _passenger_name 
    FROM profiles WHERE id = NEW.passenger_id;

  -- Nouveau match propos√© ‚Üí notifier le passager
  IF TG_OP = 'INSERT' AND NEW.status = 'proposed' THEN
    _target_user := NEW.passenger_id;
    _title := 'üéØ Nouveau match trouv√© !';
    _body := _driver_name || ' peut vous d√©poser (score ' || NEW.match_score || '%)';
  
  -- Match accept√© ‚Üí notifier l'autre partie
  ELSIF NEW.status = 'accepted' AND OLD.status = 'proposed' THEN
    _target_user := CASE WHEN NEW.driver_id = OLD.driver_id THEN NEW.passenger_id ELSE NEW.driver_id END;
    _title := '‚úÖ Match accept√© !';
    _body := 'Vous pouvez maintenant coordonner le trajet';
  
  -- Trajet d√©marr√© ‚Üí notifier le passager
  ELSIF NEW.status = 'in_transit' AND OLD.status = 'accepted' THEN
    _target_user := NEW.passenger_id;
    _title := 'üöó Trajet d√©marr√© !';
    _body := _driver_name || ' est en route pour vous r√©cup√©rer';
  
  -- Trajet termin√© ‚Üí notifier les deux
  ELSIF NEW.status = 'completed' THEN
    _target_user := NEW.passenger_id;
    _title := 'üèÅ Trajet termin√© !';
    _body := 'N''oubliez pas de noter votre exp√©rience';
    -- Aussi notifier le conducteur
    INSERT INTO planning_notifications (user_id, type, title, body, data)
    VALUES (NEW.driver_id, 'ride_completed', _title, 'N''oubliez pas de noter ' || _passenger_name, 
            jsonb_build_object('match_id', NEW.id));
  
  -- Annul√© ‚Üí notifier l'autre partie
  ELSIF NEW.status = 'cancelled' THEN
    _target_user := CASE WHEN NEW.driver_id != NEW.passenger_id THEN
      CASE WHEN NEW.driver_id = auth.uid() THEN NEW.passenger_id ELSE NEW.driver_id END
      ELSE NEW.driver_id END;
    _title := '‚ùå Trajet annul√©';
    _body := 'Le trajet a √©t√© annul√©';
  
  ELSE
    RETURN NEW;
  END IF;

  INSERT INTO planning_notifications (user_id, type, title, body, data)
  VALUES (_target_user, 'ride_' || NEW.status, _title, _body, 
          jsonb_build_object('match_id', NEW.id));

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.notify_on_ride_match_change() OWNER TO postgres;

--
-- Name: notify_on_ride_message(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.notify_on_ride_message() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  _sender_name TEXT;
  _other_user UUID;
BEGIN
  SELECT COALESCE(first_name || ' ' || last_name, 'Quelqu''un') INTO _sender_name 
    FROM profiles WHERE id = NEW.sender_id;

  -- Trouver l'autre partie du match
  SELECT CASE 
    WHEN driver_id = NEW.sender_id THEN passenger_id 
    ELSE driver_id 
  END INTO _other_user
  FROM ride_matches WHERE id = NEW.match_id;

  IF _other_user IS NOT NULL THEN
    INSERT INTO planning_notifications (user_id, type, title, body, data)
    VALUES (_other_user, 'new_message', 'üí¨ ' || _sender_name, 
            LEFT(NEW.content, 100),
            jsonb_build_object('match_id', NEW.match_id, 'message_id', NEW.id));
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.notify_on_ride_message() OWNER TO postgres;

--
-- Name: prevent_is_admin_self_modification(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prevent_is_admin_self_modification() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Si la valeur de is_admin change
  IF OLD.is_admin IS DISTINCT FROM NEW.is_admin THEN
    
    -- V√©rifier si l'utilisateur qui fait la modification est admin
    IF NOT EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid()
      AND is_admin = true
    ) THEN
      -- L'utilisateur n'est pas admin, bloquer la modification
      RAISE EXCEPTION 'Permission denied: Only administrators can modify admin status. Attempted by user: %', auth.uid();
    END IF;
    
    -- Log de s√©curit√© (optionnel mais recommand√©)
    RAISE NOTICE 'Admin status modified for user % by admin %', NEW.id, auth.uid();
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.prevent_is_admin_self_modification() OWNER TO postgres;

--
-- Name: FUNCTION prevent_is_admin_self_modification(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.prevent_is_admin_self_modification() IS 'S√©curit√© critique: Emp√™che les utilisateurs de se donner eux-m√™mes les privil√®ges administrateur. Seuls les admins existants peuvent modifier is_admin.';


--
-- Name: prevent_locked_inspection_changes(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prevent_locked_inspection_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF OLD.status = 'locked' AND (
    NEW.vehicle_info IS DISTINCT FROM OLD.vehicle_info OR
    NEW.damages IS DISTINCT FROM OLD.damages OR
    NEW.notes IS DISTINCT FROM OLD.notes OR
    NEW.fuel_level IS DISTINCT FROM OLD.fuel_level OR
    NEW.mileage_km IS DISTINCT FROM OLD.mileage_km
  ) THEN
    RAISE EXCEPTION 'Cannot modify a locked inspection';
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.prevent_locked_inspection_changes() OWNER TO postgres;

--
-- Name: process_wallet_transaction(uuid, text, numeric, text, text, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.process_wallet_transaction(p_user_id uuid, p_type text, p_amount numeric, p_description text DEFAULT NULL::text, p_reference_type text DEFAULT NULL::text, p_reference_id uuid DEFAULT NULL::uuid, p_metadata jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_current_balance NUMERIC;
  v_new_balance NUMERIC;
  v_transaction_id UUID;
BEGIN
  -- V√©rifier que l'utilisateur existe
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = p_user_id) THEN
    RAISE EXCEPTION 'User not found';
  END IF;

  -- Obtenir le solde actuel
  SELECT COALESCE(wallet_balance, 0) INTO v_current_balance
  FROM public.profiles
  WHERE id = p_user_id
  FOR UPDATE;  -- Lock la ligne pour √©viter les race conditions

  -- Calculer le nouveau solde
  v_new_balance := v_current_balance + p_amount;

  -- V√©rifier que le solde ne devient pas n√©gatif
  IF v_new_balance < 0 THEN
    RAISE EXCEPTION 'Insufficient balance';
  END IF;

  -- Mettre √† jour le solde dans profiles
  UPDATE public.profiles
  SET 
    wallet_balance = v_new_balance,
    updated_at = NOW()
  WHERE id = p_user_id;

  -- Cr√©er la transaction
  INSERT INTO public.wallet_transactions (
    user_id,
    type,
    amount,
    description,
    balance_after,
    reference_type,
    reference_id,
    metadata,
    status
  ) VALUES (
    p_user_id,
    p_type,
    p_amount,
    p_description,
    v_new_balance,
    p_reference_type,
    p_reference_id,
    p_metadata,
    'completed'
  )
  RETURNING id INTO v_transaction_id;

  RETURN v_transaction_id;
END;
$$;


ALTER FUNCTION public.process_wallet_transaction(p_user_id uuid, p_type text, p_amount numeric, p_description text, p_reference_type text, p_reference_id uuid, p_metadata jsonb) OWNER TO postgres;

--
-- Name: refresh_all_user_credits(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.refresh_all_user_credits() RETURNS TABLE(user_id uuid, plan text, old_balance integer, new_balance integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
RETURN QUERY
WITH credit_map AS (
SELECT 
s.user_id,
s.plan,
CASE s.plan
WHEN 'free' THEN 10
WHEN 'basic' THEN 50
WHEN 'pro' THEN 100
WHEN 'premium' THEN 250
WHEN 'enterprise' THEN 500
WHEN 'business' THEN 1000
ELSE 10
END as correct_credits
FROM subscriptions s
WHERE s.status = 'active'
)
UPDATE user_credits uc
SET balance = cm.correct_credits
FROM credit_map cm
WHERE uc.user_id = cm.user_id
RETURNING uc.user_id, cm.plan, 
(SELECT balance FROM user_credits WHERE user_credits.user_id = uc.user_id) as old_balance,
cm.correct_credits as new_balance;
END;
$$;


ALTER FUNCTION public.refresh_all_user_credits() OWNER TO postgres;

--
-- Name: regenerate_combined_pdf(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.regenerate_combined_pdf(p_mission_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_function_url TEXT;
  v_internal_secret TEXT;
  v_departure_id UUID;
  v_arrival_id UUID;
  v_response jsonb;
BEGIN
  -- Obtenir les IDs des inspections
  SELECT departure_id, arrival_id INTO v_departure_id, v_arrival_id
  FROM get_mission_inspection_ids(p_mission_id);

  IF v_departure_id IS NULL OR v_arrival_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'message', 'Mission incompl√®te : il manque une inspection (d√©part ou arriv√©e)'
    );
  END IF;

  v_function_url := 'https://bfrkthzovwpjrvqktdjn.supabase.co/functions/v1/generate-inspection-pdf';
  v_internal_secret := 'finality_pdf_internal_2024';
  
  v_response := net.http_post(
    url := v_function_url,
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'X-Internal-Secret', v_internal_secret
    ),
    body := jsonb_build_object(
      'missionId', p_mission_id,
      'departureId', v_departure_id,
      'arrivalId', v_arrival_id,
      'combined', true
    )
  );
  
  RETURN v_response;
END;
$$;


ALTER FUNCTION public.regenerate_combined_pdf(p_mission_id uuid) OWNER TO postgres;

--
-- Name: regenerate_inspection_pdf(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.regenerate_inspection_pdf(p_inspection_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_function_url TEXT;
  v_internal_secret TEXT;
  v_response jsonb;
BEGIN
  v_function_url := 'https://bfrkthzovwpjrvqktdjn.supabase.co/functions/v1/generate-inspection-pdf';
  v_internal_secret := 'finality_pdf_internal_2024';
  
  -- Appeler l'Edge Function
  v_response := net.http_post(
    url := v_function_url,
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'X-Internal-Secret', v_internal_secret
    ),
    body := jsonb_build_object(
      'inspectionId', p_inspection_id
    )
  );
  
  RETURN v_response;
END;
$$;


ALTER FUNCTION public.regenerate_inspection_pdf(p_inspection_id uuid) OWNER TO postgres;

--
-- Name: reject_contact_invitation(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reject_contact_invitation(p_contact_id uuid, p_user_id uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- V√©rifier que l'invitation existe et est en attente
  IF NOT EXISTS (
    SELECT 1 FROM contacts 
    WHERE id = p_contact_id 
    AND invited_user_id = p_user_id
    AND invitation_status = 'pending'
  ) THEN
    RETURN json_build_object(
      'success', false,
      'message', 'Invitation introuvable ou d√©j√† trait√©e'
    );
  END IF;

  -- Mettre √† jour le statut √† rejected
  UPDATE contacts 
  SET 
    invitation_status = 'rejected',
    invitation_responded_at = now()
  WHERE id = p_contact_id;

  RETURN json_build_object(
    'success', true,
    'message', 'Invitation refus√©e'
  );
END;
$$;


ALTER FUNCTION public.reject_contact_invitation(p_contact_id uuid, p_user_id uuid) OWNER TO postgres;

--
-- Name: renew_user_credits(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.renew_user_credits(p_user_id uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_plan text;
    v_credits_to_add integer;
    v_result json;
BEGIN
    -- R√©cup√©rer le plan de l'utilisateur
    SELECT plan INTO v_plan
    FROM subscriptions
    WHERE user_id = p_user_id
    AND status = 'active'
    AND (current_period_end IS NULL OR current_period_end > NOW());
    
    IF v_plan IS NULL THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Aucun abonnement actif'
        );
    END IF;
    
    -- Calculer les cr√©dits selon le plan
    v_credits_to_add := CASE v_plan
        WHEN 'starter' THEN 10
        WHEN 'basic' THEN 25        -- 19.99‚Ç¨/mois
        WHEN 'pro' THEN 100         -- 49.99‚Ç¨/mois
        WHEN 'business' THEN 500    -- 79.99‚Ç¨/mois
        WHEN 'enterprise' THEN 500  -- 79.99‚Ç¨/mois
        ELSE 0
    END;
    
    IF v_credits_to_add = 0 THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Plan ne donne pas de cr√©dits'
        );
    END IF;
    
    -- Ajouter les cr√©dits
    UPDATE profiles
    SET credits = COALESCE(credits, 0) + v_credits_to_add
    WHERE id = p_user_id;
    
    -- Synchroniser user_credits
    INSERT INTO user_credits (user_id, balance)
    VALUES (p_user_id, v_credits_to_add)
    ON CONFLICT (user_id) 
    DO UPDATE SET balance = user_credits.balance + v_credits_to_add;
    
    RETURN json_build_object(
        'success', true,
        'plan', v_plan,
        'credits_added', v_credits_to_add
    );
END;
$$;


ALTER FUNCTION public.renew_user_credits(p_user_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION renew_user_credits(p_user_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.renew_user_credits(p_user_id uuid) IS 'Renouvelle manuellement les cr√©dits d''un utilisateur selon son plan';


--
-- Name: reset_expired_subscription_credits(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reset_expired_subscription_credits() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    expired_user RECORD;
    user_credits INTEGER;
BEGIN
    -- Parcourir tous les abonnements expir√©s qui ont encore des cr√©dits
    -- Note: current_period_end est le nom de la colonne de date d'expiration
    FOR expired_user IN 
        SELECT s.user_id, p.credits
        FROM subscriptions s
        JOIN profiles p ON p.id = s.user_id
        WHERE (s.status = 'expired' OR (s.current_period_end IS NOT NULL AND s.current_period_end < NOW()))
        AND p.credits > 0
    LOOP
        user_credits := expired_user.credits;
        
        -- Mettre les cr√©dits √† 0
        UPDATE profiles 
        SET credits = 0, updated_at = NOW() 
        WHERE id = expired_user.user_id;
        
        -- Mettre √† jour le statut de l'abonnement si pas d√©j√† fait
        UPDATE subscriptions 
        SET status = 'expired', updated_at = NOW() 
        WHERE user_id = expired_user.user_id 
        AND status != 'expired';
        
        -- Enregistrer la transaction
        INSERT INTO credit_transactions (user_id, amount, transaction_type, description, balance_after, created_at)
        VALUES (
            expired_user.user_id, 
            -user_credits, 
            'deduction', 
            'Cr√©dits expir√©s - Abonnement termin√© (auto-cleanup)',
            0,
            NOW()
        );
        
        RAISE NOTICE 'Reset cr√©dits pour user %: % -> 0', expired_user.user_id, user_credits;
    END LOOP;
END;
$$;


ALTER FUNCTION public.reset_expired_subscription_credits() OWNER TO postgres;

--
-- Name: search_rides(text, text, date, integer, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.search_rides(p_departure_city text DEFAULT NULL::text, p_arrival_city text DEFAULT NULL::text, p_departure_date date DEFAULT NULL::date, p_min_seats integer DEFAULT 1, p_max_price numeric DEFAULT NULL::numeric) RETURNS TABLE(ride_id uuid, driver_name text, driver_rating numeric, departure_city text, arrival_city text, departure_datetime timestamp with time zone, available_seats integer, price_per_seat numeric, vehicle_info text, distance_km integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.id,
    dp.full_name,
    dp.average_rating,
    r.departure_city,
    r.arrival_city,
    (r.departure_date + r.departure_time)::TIMESTAMPTZ,
    r.available_seats,
    r.price_per_seat,
    r.vehicle_brand || ' ' || r.vehicle_model,
    r.distance_km
  FROM carpooling_rides_pro r
  JOIN driver_profiles dp ON r.driver_id = dp.user_id
  WHERE r.status = 'published'
    AND r.available_seats >= p_min_seats
    AND (p_departure_city IS NULL OR r.departure_city ILIKE '%' || p_departure_city || '%')
    AND (p_arrival_city IS NULL OR r.arrival_city ILIKE '%' || p_arrival_city || '%')
    AND (p_departure_date IS NULL OR r.departure_date = p_departure_date)
    AND (p_max_price IS NULL OR r.price_per_seat <= p_max_price)
  ORDER BY r.departure_date, r.departure_time;
END;
$$;


ALTER FUNCTION public.search_rides(p_departure_city text, p_arrival_city text, p_departure_date date, p_min_seats integer, p_max_price numeric) OWNER TO postgres;

--
-- Name: send_push_notification(uuid, text, text, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.send_push_notification(p_user_id uuid, p_title text, p_body text, p_data jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_tokens RECORD;
  v_result JSONB DEFAULT '[]'::jsonb;
BEGIN
  -- R√©cup√©rer tous les tokens actifs de l'utilisateur
  FOR v_tokens IN 
    SELECT push_token, platform 
    FROM user_push_tokens 
    WHERE user_id = p_user_id AND is_active = true
  LOOP
    -- Ajouter √† la liste des notifications √† envoyer
    v_result = v_result || jsonb_build_object(
      'to', v_tokens.push_token,
      'title', p_title,
      'body', p_body,
      'data', p_data,
      'sound', 'default',
      'priority', 'high'
    );
  END LOOP;
  
  RETURN v_result;
END;
$$;


ALTER FUNCTION public.send_push_notification(p_user_id uuid, p_title text, p_body text, p_data jsonb) OWNER TO postgres;

--
-- Name: FUNCTION send_push_notification(p_user_id uuid, p_title text, p_body text, p_data jsonb); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.send_push_notification(p_user_id uuid, p_title text, p_body text, p_data jsonb) IS 'Pr√©pare les donn√©es de notification push pour l''API Expo';


--
-- Name: set_availability(uuid, date, text, time without time zone, time without time zone, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.set_availability(p_user_id uuid, p_date date, p_status text, p_start_time time without time zone DEFAULT NULL::time without time zone, p_end_time time without time zone DEFAULT NULL::time without time zone, p_notes text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_availability_id uuid;
BEGIN
  -- Validation du statut
  IF p_status NOT IN ('available', 'unavailable', 'partially_available') THEN
    RETURN json_build_object(
      'success', false,
      'message', 'Statut invalide. Utilisez: available, unavailable ou partially_available'
    );
  END IF;

  -- Insert ou update
  INSERT INTO availability_calendar (
    user_id,
    date,
    status,
    start_time,
    end_time,
    notes
  ) VALUES (
    p_user_id,
    p_date,
    p_status,
    p_start_time,
    p_end_time,
    p_notes
  )
  ON CONFLICT (user_id, date) 
  DO UPDATE SET
    status = EXCLUDED.status,
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    notes = EXCLUDED.notes,
    updated_at = now()
  RETURNING id INTO v_availability_id;

  RETURN json_build_object(
    'success', true,
    'availability_id', v_availability_id,
    'message', 'Disponibilit√© enregistr√©e avec succ√®s'
  );
END;
$$;


ALTER FUNCTION public.set_availability(p_user_id uuid, p_date date, p_status text, p_start_time time without time zone, p_end_time time without time zone, p_notes text) OWNER TO postgres;

--
-- Name: set_availability_range(uuid, date, date, text, time without time zone, time without time zone, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.set_availability_range(p_user_id uuid, p_start_date date, p_end_date date, p_status text, p_start_time time without time zone DEFAULT NULL::time without time zone, p_end_time time without time zone DEFAULT NULL::time without time zone, p_notes text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_current_date date;
  v_count integer := 0;
BEGIN
  -- Validation
  IF p_start_date > p_end_date THEN
    RETURN json_build_object(
      'success', false,
      'message', 'La date de d√©but doit √™tre avant la date de fin'
    );
  END IF;

  -- Boucle sur toutes les dates
  v_current_date := p_start_date;
  WHILE v_current_date <= p_end_date LOOP
    INSERT INTO availability_calendar (
      user_id,
      date,
      status,
      start_time,
      end_time,
      notes
    ) VALUES (
      p_user_id,
      v_current_date,
      p_status,
      p_start_time,
      p_end_time,
      p_notes
    )
    ON CONFLICT (user_id, date) 
    DO UPDATE SET
      status = EXCLUDED.status,
      start_time = EXCLUDED.start_time,
      end_time = EXCLUDED.end_time,
      notes = EXCLUDED.notes,
      updated_at = now();
    
    v_count := v_count + 1;
    v_current_date := v_current_date + 1;
  END LOOP;

  RETURN json_build_object(
    'success', true,
    'days_updated', v_count,
    'message', format('%s jours mis √† jour', v_count)
  );
END;
$$;


ALTER FUNCTION public.set_availability_range(p_user_id uuid, p_start_date date, p_end_date date, p_status text, p_start_time time without time zone, p_end_time time without time zone, p_notes text) OWNER TO postgres;

--
-- Name: set_ride_expiration(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.set_ride_expiration() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_TABLE_NAME = 'ride_offers' THEN
    NEW.expires_at := (NEW.departure_date + INTERVAL '1 day')::timestamptz;
  ELSIF TG_TABLE_NAME = 'ride_requests' THEN
    NEW.expires_at := (NEW.needed_date + INTERVAL '1 day')::timestamptz;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.set_ride_expiration() OWNER TO postgres;

--
-- Name: simplify_tracking_route(uuid, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.simplify_tracking_route(p_session_id uuid, p_tolerance double precision DEFAULT 0.0001) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_deleted INTEGER;
BEGIN
  -- Garder seulement les points significatifs
  -- - Premier et dernier point
  -- - Points avec changement de direction significatif
  -- - Points avec changement de vitesse > 20 km/h
  
  WITH significant_points AS (
    SELECT 
      id,
      ROW_NUMBER() OVER (ORDER BY recorded_at) as rn,
      COUNT(*) OVER () as total_points,
      speed_kmh,
      LAG(speed_kmh) OVER (ORDER BY recorded_at) as prev_speed
    FROM gps_location_points
    WHERE session_id = p_session_id
      AND is_valid = TRUE
  )
  DELETE FROM gps_location_points
  WHERE id IN (
    SELECT id FROM significant_points
    WHERE rn > 1  -- Pas le premier
      AND rn < total_points  -- Pas le dernier
      AND ABS(COALESCE(speed_kmh, 0) - COALESCE(prev_speed, 0)) < 20  -- Pas de changement vitesse significatif
  )
  AND session_id = p_session_id;
  
  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  
  RETURN v_deleted;
END;
$$;


ALTER FUNCTION public.simplify_tracking_route(p_session_id uuid, p_tolerance double precision) OWNER TO postgres;

--
-- Name: spend_credits_atomic(uuid, integer, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.spend_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_reference_type text DEFAULT NULL::text, p_reference_id text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_current_credits INTEGER;
  v_new_balance INTEGER;
BEGIN
  -- Lock the row and get current credits atomically
  SELECT credits INTO v_current_credits
  FROM profiles
  WHERE id = p_user_id
  FOR UPDATE;

  IF v_current_credits IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Utilisateur non trouv√©');
  END IF;

  IF v_current_credits < p_amount THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Cr√©dits insuffisants',
      'current_credits', v_current_credits,
      'requested', p_amount
    );
  END IF;

  v_new_balance := v_current_credits - p_amount;

  -- Update credits
  UPDATE profiles
  SET credits = v_new_balance,
      updated_at = NOW()
  WHERE id = p_user_id;

  -- Create transaction record
  INSERT INTO credit_transactions (user_id, amount, transaction_type, description, reference_type, reference_id, balance_after)
  VALUES (p_user_id, -p_amount, 'deduction', p_description, p_reference_type, p_reference_id::UUID, v_new_balance);

  RETURN json_build_object(
    'success', true,
    'new_balance', v_new_balance,
    'amount_spent', p_amount
  );
END;
$$;


ALTER FUNCTION public.spend_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_reference_type text, p_reference_id text) OWNER TO postgres;

--
-- Name: storage_upload_public(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.storage_upload_public(p_bucket_name text, p_file_path text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_bucket_id text;
  v_result json;
BEGIN
  -- R√©cup√©rer l'ID du bucket
  SELECT id INTO v_bucket_id
  FROM storage.buckets
  WHERE name = p_bucket_name;
  
  IF v_bucket_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Bucket not found: ' || p_bucket_name
    );
  END IF;
  
  -- Ins√©rer dans storage.objects (contourne RLS car SECURITY DEFINER)
  INSERT INTO storage.objects (
    bucket_id,
    name,
    owner,
    created_at,
    updated_at,
    last_accessed_at,
    metadata
  ) VALUES (
    v_bucket_id,
    p_file_path,
    auth.uid(),
    now(),
    now(),
    now(),
    '{}'::jsonb
  )
  ON CONFLICT (bucket_id, name) 
  DO UPDATE SET
    updated_at = now(),
    last_accessed_at = now();
  
  RETURN json_build_object(
    'success', true,
    'bucket_id', v_bucket_id,
    'path', p_file_path
  );
END;
$$;


ALTER FUNCTION public.storage_upload_public(p_bucket_name text, p_file_path text) OWNER TO postgres;

--
-- Name: sync_client_data_to_invoice(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.sync_client_data_to_invoice() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.client_id IS NOT NULL THEN
    -- R√©cup√©rer les donn√©es du client
    SELECT 
      name,
      email,
      address,
      siret
    INTO 
      NEW.client_name,
      NEW.client_email,
      NEW.client_address,
      NEW.client_siret
    FROM clients
    WHERE id = NEW.client_id;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.sync_client_data_to_invoice() OWNER TO postgres;

--
-- Name: FUNCTION sync_client_data_to_invoice(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.sync_client_data_to_invoice() IS 'Synchronise automatiquement les donn√©es client depuis la table clients vers invoices quand client_id est d√©fini';


--
-- Name: sync_client_data_to_quote(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.sync_client_data_to_quote() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.client_id IS NOT NULL THEN
    -- R√©cup√©rer les donn√©es du client
    SELECT 
      name,
      email,
      address,
      siret
    INTO 
      NEW.client_name,
      NEW.client_email,
      NEW.client_address,
      NEW.client_siret
    FROM clients
    WHERE id = NEW.client_id;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.sync_client_data_to_quote() OWNER TO postgres;

--
-- Name: FUNCTION sync_client_data_to_quote(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.sync_client_data_to_quote() IS 'Synchronise automatiquement les donn√©es client depuis la table clients vers quotes quand client_id est d√©fini';


--
-- Name: sync_credits_bidirectional(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.sync_credits_bidirectional() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    IF TG_TABLE_NAME = 'profiles' THEN
        -- profiles.credits modifi√© ‚Üí mettre √† jour user_credits.balance
        UPDATE user_credits
        SET balance = NEW.credits
        WHERE user_id = NEW.id;
        
        -- Si user_credits n'existe pas, cr√©er
        IF NOT FOUND THEN
            INSERT INTO user_credits (user_id, balance)
            VALUES (NEW.id, NEW.credits)
            ON CONFLICT (user_id) DO UPDATE SET balance = NEW.credits;
        END IF;
        
    ELSIF TG_TABLE_NAME = 'user_credits' THEN
        -- user_credits.balance modifi√© ‚Üí mettre √† jour profiles.credits
        UPDATE profiles
        SET credits = NEW.balance
        WHERE id = NEW.user_id;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.sync_credits_bidirectional() OWNER TO postgres;

--
-- Name: sync_invoice_date(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.sync_invoice_date() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.invoice_date IS NOT NULL AND NEW.issue_date IS NULL THEN
    NEW.issue_date := NEW.invoice_date;
  ELSIF NEW.issue_date IS NOT NULL AND NEW.invoice_date IS NULL THEN
    NEW.invoice_date := NEW.issue_date;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.sync_invoice_date() OWNER TO postgres;

--
-- Name: sync_profile_credits_from_user_credits(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.sync_profile_credits_from_user_credits() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Mettre √† jour profiles.credits quand user_credits.balance change
    UPDATE profiles
    SET credits = NEW.balance
    WHERE id = NEW.user_id;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.sync_profile_credits_from_user_credits() OWNER TO postgres;

--
-- Name: test_tracking_simulation(uuid, uuid, double precision, double precision, double precision, double precision, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test_tracking_simulation(p_mission_id uuid, p_user_id uuid, p_start_lat double precision, p_start_lng double precision, p_end_lat double precision, p_end_lng double precision, p_steps integer DEFAULT 10) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_lat_step DOUBLE PRECISION;
  v_lng_step DOUBLE PRECISION;
  v_current_lat DOUBLE PRECISION;
  v_current_lng DOUBLE PRECISION;
  v_step INTEGER;
BEGIN
  -- Calculer les incr√©ments
  v_lat_step := (p_end_lat - p_start_lat) / p_steps;
  v_lng_step := (p_end_lng - p_start_lng) / p_steps;
  
  -- Simuler d√©placement
  FOR v_step IN 0..p_steps LOOP
    v_current_lat := p_start_lat + (v_lat_step * v_step);
    v_current_lng := p_start_lng + (v_lng_step * v_step);
    
    -- Upsert position
    INSERT INTO mission_tracking_live (
      mission_id, 
      user_id, 
      latitude, 
      longitude, 
      speed, 
      bearing,
      battery_level,
      last_update,
      is_active
    )
    VALUES (
      p_mission_id,
      p_user_id,
      v_current_lat,
      v_current_lng,
      15.0 + (random() * 10),  -- Vitesse 15-25 m/s (~54-90 km/h)
      (random() * 360)::INTEGER,
      100 - (v_step * 5),  -- Batterie diminue
      NOW(),
      true
    )
    ON CONFLICT (mission_id, user_id)
    DO UPDATE SET
      latitude = EXCLUDED.latitude,
      longitude = EXCLUDED.longitude,
      speed = EXCLUDED.speed,
      bearing = EXCLUDED.bearing,
      battery_level = EXCLUDED.battery_level,
      last_update = EXCLUDED.last_update,
      is_active = EXCLUDED.is_active;
    
    -- Ajouter snapshot √† l'historique
    INSERT INTO mission_tracking_history (
      mission_id, 
      user_id, 
      latitude, 
      longitude, 
      speed, 
      bearing,
      recorded_at
    )
    VALUES (
      p_mission_id,
      p_user_id,
      v_current_lat,
      v_current_lng,
      15.0 + (random() * 10),
      (random() * 360)::INTEGER,
      NOW()
    );
    
    -- Pause simul√©e
    PERFORM pg_sleep(0.1);
  END LOOP;
  
  RAISE NOTICE '‚úÖ Simulation termin√©e: % positions g√©n√©r√©es', p_steps + 1;
END;
$$;


ALTER FUNCTION public.test_tracking_simulation(p_mission_id uuid, p_user_id uuid, p_start_lat double precision, p_start_lng double precision, p_end_lat double precision, p_end_lng double precision, p_steps integer) OWNER TO postgres;

--
-- Name: toggle_auto_renew(uuid, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.toggle_auto_renew(p_user_id uuid, p_enable boolean) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_subscription_id uuid;
    v_plan text;
    v_email text;
BEGIN
    -- R√©cup√©rer l'abonnement actif
    SELECT s.id, s.plan, p.email
    INTO v_subscription_id, v_plan, v_email
    FROM subscriptions s
    JOIN profiles p ON p.id = s.user_id
    WHERE s.user_id = p_user_id
    AND s.status = 'active'
    AND (s.current_period_end IS NULL OR s.current_period_end > NOW());
    
    IF v_subscription_id IS NULL THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Aucun abonnement actif trouv√©'
        );
    END IF;
    
    -- Mettre √† jour auto_renew
    UPDATE subscriptions
    SET auto_renew = p_enable
    WHERE id = v_subscription_id;
    
    RETURN json_build_object(
        'success', true,
        'user_id', p_user_id,
        'email', v_email,
        'plan', v_plan,
        'auto_renew', p_enable,
        'message', CASE 
            WHEN p_enable THEN 'Renouvellement automatique activ√©'
            ELSE 'Renouvellement automatique d√©sactiv√©'
        END
    );
END;
$$;


ALTER FUNCTION public.toggle_auto_renew(p_user_id uuid, p_enable boolean) OWNER TO postgres;

--
-- Name: FUNCTION toggle_auto_renew(p_user_id uuid, p_enable boolean); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.toggle_auto_renew(p_user_id uuid, p_enable boolean) IS 'Active/d√©sactive le renouvellement automatique pour un utilisateur';


--
-- Name: trigger_combined_pdf_generation(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.trigger_combined_pdf_generation() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_complete BOOLEAN;
  v_both_complete BOOLEAN;
  v_function_url TEXT;
  v_internal_secret TEXT;
  v_mission_id UUID;
  v_departure_id UUID;
  v_arrival_id UUID;
  v_pdf_already_exists BOOLEAN;
BEGIN
  -- V√©rifier si cette inspection est compl√®te
  v_complete := is_inspection_complete(NEW.id);
  
  IF NOT v_complete THEN
    RETURN NEW;
  END IF;

  v_mission_id := NEW.mission_id;

  -- V√©rifier si la mission a les 2 inspections compl√®tes
  v_both_complete := mission_has_both_inspections(v_mission_id);

  IF NOT v_both_complete THEN
    RAISE NOTICE 'Mission % : une seule inspection compl√®te, attente de la seconde', v_mission_id;
    RETURN NEW;
  END IF;

  -- Obtenir les IDs des 2 inspections
  SELECT departure_id, arrival_id INTO v_departure_id, v_arrival_id
  FROM get_mission_inspection_ids(v_mission_id);

  -- V√©rifier si un PDF existe d√©j√† pour cette mission
  SELECT EXISTS(
    SELECT 1 FROM inspection_pdfs 
    WHERE mission_id = v_mission_id
  ) INTO v_pdf_already_exists;

  IF v_pdf_already_exists THEN
    RAISE NOTICE 'PDF d√©j√† g√©n√©r√© pour mission %', v_mission_id;
    RETURN NEW;
  END IF;

  -- G√©n√©rer le PDF combin√©
  v_function_url := 'https://bfrkthzovwpjrvqktdjn.supabase.co/functions/v1/generate-inspection-pdf';
  v_internal_secret := 'finality_pdf_internal_2024';

  PERFORM net.http_post(
    url := v_function_url,
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'X-Internal-Secret', v_internal_secret
    ),
    body := jsonb_build_object(
      'missionId', v_mission_id,
      'departureId', v_departure_id,
      'arrivalId', v_arrival_id,
      'combined', true
    )
  );

  RAISE NOTICE 'PDF combin√© d√©clench√© pour mission % (d√©part: %, arriv√©e: %)', v_mission_id, v_departure_id, v_arrival_id;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.trigger_combined_pdf_generation() OWNER TO postgres;

--
-- Name: trigger_pdf_generation(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.trigger_pdf_generation() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_complete BOOLEAN;
  v_function_url TEXT;
  v_internal_secret TEXT;
BEGIN
  -- V√©rifier si l'inspection est compl√®te
  v_complete := is_inspection_complete(NEW.id);

  -- Si compl√®te et PDF pas encore g√©n√©r√©
  IF v_complete AND (NEW.pdf_generated IS NULL OR NEW.pdf_generated = FALSE) THEN

    -- URL hardcod√©e (pas de setting DB requis)
    v_function_url := 'https://bfrkthzovwpjrvqktdjn.supabase.co/functions/v1/generate-inspection-pdf';
    
    -- Secret interne (tu peux le changer, mais garde-le identique √† celui pos√© via CLI)
    v_internal_secret := 'finality_pdf_internal_2024';

    -- Appeler l'Edge Function de mani√®re asynchrone avec le secret
    PERFORM net.http_post(
      url := v_function_url,
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'X-Internal-Secret', v_internal_secret
      ),
      body := jsonb_build_object(
        'inspectionId', NEW.id
      )
    );

    RAISE NOTICE 'PDF generation triggered for inspection %', NEW.id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.trigger_pdf_generation() OWNER TO postgres;

--
-- Name: trigger_reset_credits_on_expiration(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.trigger_reset_credits_on_expiration() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    current_credits INTEGER;
BEGIN
    -- Si le statut passe √† 'expired'
    IF NEW.status = 'expired' AND (OLD.status IS NULL OR OLD.status != 'expired') THEN
        -- R√©cup√©rer les cr√©dits actuels
        SELECT credits INTO current_credits FROM profiles WHERE id = NEW.user_id;
        
        IF current_credits > 0 THEN
            -- Reset les cr√©dits √† 0
            UPDATE profiles SET credits = 0, updated_at = NOW() WHERE id = NEW.user_id;
            
            -- Enregistrer la transaction
            INSERT INTO credit_transactions (user_id, amount, transaction_type, description, balance_after)
            VALUES (NEW.user_id, -current_credits, 'deduction', 'Cr√©dits expir√©s - Abonnement termin√©', 0);
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.trigger_reset_credits_on_expiration() OWNER TO postgres;

--
-- Name: trigger_update_profile_completion(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.trigger_update_profile_completion() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.profile_completion_percentage := public.calculate_profile_completion(NEW.id);
    
    -- Marquer onboarding comme compl√©t√© si 100%
    IF NEW.profile_completion_percentage >= 90 AND NEW.onboarding_completed = FALSE THEN
        NEW.onboarding_completed := TRUE;
        NEW.onboarding_completed_at := NOW();
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.trigger_update_profile_completion() OWNER TO postgres;

--
-- Name: update_ai_conversation_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_ai_conversation_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
NEW.updated_at = now();
RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_ai_conversation_updated_at() OWNER TO postgres;

--
-- Name: update_alert_votes(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_alert_votes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF TG_OP = 'INSERT' THEN
IF NEW.vote_type = 'up' THEN
UPDATE navigation_alerts
SET upvotes = upvotes + 1
WHERE id = NEW.alert_id;
ELSE
UPDATE navigation_alerts
SET downvotes = downvotes + 1
WHERE id = NEW.alert_id;
END IF;
ELSIF TG_OP = 'UPDATE' THEN
IF OLD.vote_type = 'up' AND NEW.vote_type = 'down' THEN
UPDATE navigation_alerts
SET upvotes = upvotes - 1, downvotes = downvotes + 1
WHERE id = NEW.alert_id;
ELSIF OLD.vote_type = 'down' AND NEW.vote_type = 'up' THEN
UPDATE navigation_alerts
SET downvotes = downvotes - 1, upvotes = upvotes + 1
WHERE id = NEW.alert_id;
END IF;
ELSIF TG_OP = 'DELETE' THEN
IF OLD.vote_type = 'up' THEN
UPDATE navigation_alerts
SET upvotes = upvotes - 1
WHERE id = OLD.alert_id;
ELSE
UPDATE navigation_alerts
SET downvotes = downvotes - 1
WHERE id = OLD.alert_id;
END IF;
END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_alert_votes() OWNER TO postgres;

--
-- Name: update_app_versions_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_app_versions_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_app_versions_updated_at() OWNER TO postgres;

--
-- Name: update_attachments_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_attachments_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_attachments_updated_at() OWNER TO postgres;

--
-- Name: update_availability_timestamp(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_availability_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_availability_timestamp() OWNER TO postgres;

--
-- Name: update_average_rating(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_average_rating() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  avg_rating DECIMAL(3, 2);
  review_count INTEGER;
BEGIN
  -- Calculer la moyenne des notes pour le conducteur
  SELECT 
    COALESCE(AVG(rating), 0.00),
    COUNT(*)
  INTO avg_rating, review_count
  FROM covoiturage_reviews
  WHERE reviewed_id = NEW.reviewed_id;
  
  -- Mettre √† jour le profil
  INSERT INTO covoiturage_driver_profiles (user_id, average_rating, total_reviews)
  VALUES (NEW.reviewed_id, avg_rating, review_count)
  ON CONFLICT (user_id)
  DO UPDATE SET
    average_rating = avg_rating,
    total_reviews = review_count;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_average_rating() OWNER TO postgres;

--
-- Name: update_conversation_last_message(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_conversation_last_message() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE support_conversations
  SET last_message_at = NEW.created_at,
      updated_at = now()
  WHERE id = NEW.conversation_id;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_conversation_last_message() OWNER TO postgres;

--
-- Name: update_covoiturage_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_covoiturage_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_covoiturage_updated_at() OWNER TO postgres;

--
-- Name: update_driver_rating(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_driver_rating() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE contacts
SET 
rating_average = (
SELECT COALESCE(AVG(rating), 0)
FROM driver_mission_history
WHERE contact_id = NEW.contact_id
AND rating IS NOT NULL
),
missions_completed = (
SELECT COUNT(*)
FROM driver_mission_history
WHERE contact_id = NEW.contact_id
)
WHERE id = NEW.contact_id;

RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_driver_rating() OWNER TO postgres;

--
-- Name: update_driver_stats(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_driver_stats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Mettre √† jour le profil conducteur
  INSERT INTO covoiturage_driver_profiles (user_id, total_trips)
  VALUES (NEW.user_id, 1)
  ON CONFLICT (user_id) 
  DO UPDATE SET 
    total_trips = covoiturage_driver_profiles.total_trips + 1,
    total_km = covoiturage_driver_profiles.total_km + COALESCE(NEW.total_distance, 0);
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_driver_stats() OWNER TO postgres;

--
-- Name: update_inspection_damages_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_inspection_damages_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_inspection_damages_updated_at() OWNER TO postgres;

--
-- Name: update_inspection_documents_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_inspection_documents_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_inspection_documents_updated_at() OWNER TO postgres;

--
-- Name: update_navigation_sessions_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_navigation_sessions_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_navigation_sessions_updated_at() OWNER TO postgres;

--
-- Name: update_photo_metadata(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_photo_metadata() RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_photo RECORD;
  v_file_size BIGINT;
BEGIN
  FOR v_photo IN 
    SELECT id, full_url 
    FROM inspection_photos_v2 
    WHERE file_size_bytes IS NULL
    LIMIT 100 -- Traiter par batch pour √©viter timeout
  LOOP
    -- R√©cup√©rer la taille depuis storage.objects si disponible
    SELECT (metadata->>'size')::bigint INTO v_file_size
    FROM storage.objects
    WHERE name = substring(v_photo.full_url from 'inspection-photos/(.*)$')
    LIMIT 1;
    
    IF v_file_size IS NOT NULL THEN
      UPDATE inspection_photos_v2
      SET file_size_bytes = v_file_size
      WHERE id = v_photo.id;
    END IF;
  END LOOP;
  
  RAISE NOTICE 'Metadata updated for batch';
END;
$_$;


ALTER FUNCTION public.update_photo_metadata() OWNER TO postgres;

--
-- Name: update_pricing_grids_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_pricing_grids_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_pricing_grids_updated_at() OWNER TO postgres;

--
-- Name: update_public_reports_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_public_reports_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_public_reports_updated_at() OWNER TO postgres;

--
-- Name: update_push_tokens_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_push_tokens_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_push_tokens_updated_at() OWNER TO postgres;

--
-- Name: update_quote_accepted_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_quote_accepted_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.status = 'accepted' AND OLD.status != 'accepted' AND NEW.accepted_at IS NULL THEN
    NEW.accepted_at = NOW();
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_quote_accepted_at() OWNER TO postgres;

--
-- Name: update_quote_converted_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_quote_converted_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.converted_to_mission_id IS NOT NULL AND OLD.converted_to_mission_id IS NULL AND NEW.converted_at IS NULL THEN
    NEW.converted_at = NOW();
    NEW.status = 'converted';
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_quote_converted_at() OWNER TO postgres;

--
-- Name: update_quote_rejected_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_quote_rejected_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.status = 'rejected' AND OLD.status != 'rejected' AND NEW.rejected_at IS NULL THEN
    NEW.rejected_at = NOW();
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_quote_rejected_at() OWNER TO postgres;

--
-- Name: update_quote_sent_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_quote_sent_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.status = 'sent' AND OLD.status != 'sent' AND NEW.sent_at IS NULL THEN
    NEW.sent_at = NOW();
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_quote_sent_at() OWNER TO postgres;

--
-- Name: update_quotes_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_quotes_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_quotes_updated_at() OWNER TO postgres;

--
-- Name: update_shop_quote_requests_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_shop_quote_requests_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_shop_quote_requests_updated_at() OWNER TO postgres;

--
-- Name: update_subscription_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_subscription_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
NEW.updated_at = now();
RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_subscription_updated_at() OWNER TO postgres;

--
-- Name: update_tracking_session_stats(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_tracking_session_stats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE mission_tracking_sessions
SET
max_speed = GREATEST(max_speed, NEW.speed),
updated_at = now()
WHERE mission_id = NEW.mission_id
AND status = 'active';

RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_tracking_session_stats() OWNER TO postgres;

--
-- Name: update_tracking_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_tracking_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_tracking_updated_at() OWNER TO postgres;

--
-- Name: update_trip_available_seats(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_trip_available_seats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- R√©duire places disponibles lors d'une confirmation
  IF TG_OP = 'INSERT' AND NEW.status = 'confirmed' THEN
    UPDATE carpooling_trips
    SET available_seats = available_seats - NEW.seats_booked
    WHERE id = NEW.trip_id;
  END IF;
  
  -- Restaurer places lors d'une annulation
  IF TG_OP = 'UPDATE' AND OLD.status = 'confirmed' AND NEW.status IN ('cancelled', 'rejected') THEN
    UPDATE carpooling_trips
    SET available_seats = available_seats + OLD.seats_booked
    WHERE id = OLD.trip_id;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_trip_available_seats() OWNER TO postgres;

--
-- Name: update_trip_on_message(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_trip_on_message() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE carpooling_trips
  SET updated_at = NOW()
  WHERE id = NEW.trip_id;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_trip_on_message() OWNER TO postgres;

--
-- Name: update_unified_docs_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_unified_docs_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_unified_docs_updated_at() OWNER TO postgres;

--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_updated_at_column() OWNER TO postgres;

--
-- Name: update_user_ai_memory_timestamp(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_user_ai_memory_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_user_ai_memory_timestamp() OWNER TO postgres;

--
-- Name: update_user_devices_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_user_devices_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_user_devices_updated_at() OWNER TO postgres;

--
-- Name: update_user_location(double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_user_location(p_lat double precision, p_lng double precision) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  UPDATE profiles SET 
    last_lat = p_lat,
    last_lng = p_lng,
    last_location_at = now()
  WHERE id = auth.uid();
END;
$$;


ALTER FUNCTION public.update_user_location(p_lat double precision, p_lng double precision) OWNER TO postgres;

--
-- Name: FUNCTION update_user_location(p_lat double precision, p_lng double precision); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.update_user_location(p_lat double precision, p_lng double precision) IS 'Met √† jour la position live du convoyeur dans profiles';


--
-- Name: update_user_rating(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_user_rating() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE profiles
SET 
rating_average = (
SELECT AVG(rating)::decimal(3,2)
FROM covoiturage_ratings
WHERE rated_id = NEW.rated_id
),
rating_count = (
SELECT COUNT(*)
FROM covoiturage_ratings
WHERE rated_id = NEW.rated_id
)
WHERE id = NEW.rated_id;

RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_user_rating() OWNER TO postgres;

--
-- Name: update_user_stats_on_rating(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_user_stats_on_rating() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Mettre √† jour le profil avec la nouvelle moyenne
  UPDATE profiles
  SET 
    rating = (
      SELECT ROUND(AVG(rating)::numeric, 2)
      FROM carpooling_ratings
      WHERE rated_user_id = NEW.rated_user_id
    ),
    total_ratings = (
      SELECT COUNT(*)
      FROM carpooling_ratings
      WHERE rated_user_id = NEW.rated_user_id
    )
  WHERE id = NEW.rated_user_id;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_user_stats_on_rating() OWNER TO postgres;

--
-- Name: update_wallet_transaction_timestamp(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_wallet_transaction_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_wallet_transaction_timestamp() OWNER TO postgres;

--
-- Name: upload_avatar_bypass_rls(uuid, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.upload_avatar_bypass_rls(p_user_id uuid, p_file_path text, p_public_url text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_result json;
BEGIN
  -- Mettre √† jour le profil avec la nouvelle URL d'avatar
  UPDATE profiles
  SET 
    avatar_url = p_public_url,
    updated_at = now()
  WHERE id = p_user_id;
  
  -- Retourner le r√©sultat
  SELECT json_build_object(
    'success', true,
    'avatar_url', p_public_url,
    'updated_at', now()
  ) INTO v_result;
  
  RETURN v_result;
END;
$$;


ALTER FUNCTION public.upload_avatar_bypass_rls(p_user_id uuid, p_file_path text, p_public_url text) OWNER TO postgres;

--
-- Name: upsert_planning_stats(uuid, double precision, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.upsert_planning_stats(p_user_id uuid, p_km_saved double precision DEFAULT 0, p_hours_saved double precision DEFAULT 0, p_match_accepted boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_month INTEGER := EXTRACT(MONTH FROM now());
  v_year INTEGER := EXTRACT(YEAR FROM now());
BEGIN
  INSERT INTO planning_stats (user_id, month, year, plannings_published, matches_found, matches_accepted, km_saved, hours_saved, empty_trips_avoided, co2_saved_kg)
  VALUES (p_user_id, v_month, v_year, 1, 0, 
    CASE WHEN p_match_accepted THEN 1 ELSE 0 END,
    p_km_saved, p_hours_saved,
    CASE WHEN p_km_saved > 0 THEN 1 ELSE 0 END,
    p_km_saved * 0.12 -- ~120g CO2/km
  )
  ON CONFLICT (user_id, month, year)
  DO UPDATE SET
    plannings_published = planning_stats.plannings_published + 1,
    matches_accepted = planning_stats.matches_accepted + CASE WHEN p_match_accepted THEN 1 ELSE 0 END,
    km_saved = planning_stats.km_saved + p_km_saved,
    hours_saved = planning_stats.hours_saved + p_hours_saved,
    empty_trips_avoided = planning_stats.empty_trips_avoided + CASE WHEN p_km_saved > 0 THEN 1 ELSE 0 END,
    co2_saved_kg = planning_stats.co2_saved_kg + (p_km_saved * 0.12),
    updated_at = now();
END;
$$;


ALTER FUNCTION public.upsert_planning_stats(p_user_id uuid, p_km_saved double precision, p_hours_saved double precision, p_match_accepted boolean) OWNER TO postgres;

--
-- Name: upsert_push_token(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.upsert_push_token(p_token text, p_platform text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO push_tokens (user_id, token, platform, updated_at)
  VALUES (auth.uid(), p_token, p_platform, now())
  ON CONFLICT (user_id, token) DO UPDATE SET
    platform = EXCLUDED.platform,
    updated_at = now();
END;
$$;


ALTER FUNCTION public.upsert_push_token(p_token text, p_platform text) OWNER TO postgres;

--
-- Name: apply_rls(jsonb, integer); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024)) RETURNS SETOF realtime.wal_rls
    LANGUAGE plpgsql
    AS $$
declare
-- Regclass of the table e.g. public.notes
entity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;

-- I, U, D, T: insert, update ...
action realtime.action = (
    case wal ->> 'action'
        when 'I' then 'INSERT'
        when 'U' then 'UPDATE'
        when 'D' then 'DELETE'
        else 'ERROR'
    end
);

-- Is row level security enabled for the table
is_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;

subscriptions realtime.subscription[] = array_agg(subs)
    from
        realtime.subscription subs
    where
        subs.entity = entity_
        -- Filter by action early - only get subscriptions interested in this action
        -- action_filter column can be: '*' (all), 'INSERT', 'UPDATE', or 'DELETE'
        and (subs.action_filter = '*' or subs.action_filter = action::text);

-- Subscription vars
roles regrole[] = array_agg(distinct us.claims_role::text)
    from
        unnest(subscriptions) us;

working_role regrole;
claimed_role regrole;
claims jsonb;

subscription_id uuid;
subscription_has_access bool;
visible_to_subscription_ids uuid[] = '{}';

-- structured info for wal's columns
columns realtime.wal_column[];
-- previous identity values for update/delete
old_columns realtime.wal_column[];

error_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;

-- Primary jsonb output for record
output jsonb;

begin
perform set_config('role', null, true);

columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'columns') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

old_columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'identity') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

for working_role in select * from unnest(roles) loop

    -- Update `is_selectable` for columns and old_columns
    columns =
        array_agg(
            (
                c.name,
                c.type_name,
                c.type_oid,
                c.value,
                c.is_pkey,
                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
            )::realtime.wal_column
        )
        from
            unnest(columns) c;

    old_columns =
            array_agg(
                (
                    c.name,
                    c.type_name,
                    c.type_oid,
                    c.value,
                    c.is_pkey,
                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
                )::realtime.wal_column
            )
            from
                unnest(old_columns) c;

    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            -- subscriptions is already filtered by entity
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 400: Bad Request, no primary key']
        )::realtime.wal_rls;

    -- The claims role does not have SELECT permission to the primary key of entity
    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 401: Unauthorized']
        )::realtime.wal_rls;

    else
        output = jsonb_build_object(
            'schema', wal ->> 'schema',
            'table', wal ->> 'table',
            'type', action,
            'commit_timestamp', to_char(
                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),
                'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'
            ),
            'columns', (
                select
                    jsonb_agg(
                        jsonb_build_object(
                            'name', pa.attname,
                            'type', pt.typname
                        )
                        order by pa.attnum asc
                    )
                from
                    pg_attribute pa
                    join pg_type pt
                        on pa.atttypid = pt.oid
                where
                    attrelid = entity_
                    and attnum > 0
                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')
            )
        )
        -- Add "record" key for insert and update
        || case
            when action in ('INSERT', 'UPDATE') then
                jsonb_build_object(
                    'record',
                    (
                        select
                            jsonb_object_agg(
                                -- if unchanged toast, get column name and value from old record
                                coalesce((c).name, (oc).name),
                                case
                                    when (c).name is null then (oc).value
                                    else (c).value
                                end
                            )
                        from
                            unnest(columns) c
                            full outer join unnest(old_columns) oc
                                on (c).name = (oc).name
                        where
                            coalesce((c).is_selectable, (oc).is_selectable)
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                    )
                )
            else '{}'::jsonb
        end
        -- Add "old_record" key for update and delete
        || case
            when action = 'UPDATE' then
                jsonb_build_object(
                        'old_record',
                        (
                            select jsonb_object_agg((c).name, (c).value)
                            from unnest(old_columns) c
                            where
                                (c).is_selectable
                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                        )
                    )
            when action = 'DELETE' then
                jsonb_build_object(
                    'old_record',
                    (
                        select jsonb_object_agg((c).name, (c).value)
                        from unnest(old_columns) c
                        where
                            (c).is_selectable
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey
                    )
                )
            else '{}'::jsonb
        end;

        -- Create the prepared statement
        if is_rls_enabled and action <> 'DELETE' then
            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then
                deallocate walrus_rls_stmt;
            end if;
            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);
        end if;

        visible_to_subscription_ids = '{}';

        for subscription_id, claims in (
                select
                    subs.subscription_id,
                    subs.claims
                from
                    unnest(subscriptions) subs
                where
                    subs.entity = entity_
                    and subs.claims_role = working_role
                    and (
                        realtime.is_visible_through_filters(columns, subs.filters)
                        or (
                          action = 'DELETE'
                          and realtime.is_visible_through_filters(old_columns, subs.filters)
                        )
                    )
        ) loop

            if not is_rls_enabled or action = 'DELETE' then
                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
            else
                -- Check if RLS allows the role to see the record
                perform
                    -- Trim leading and trailing quotes from working_role because set_config
                    -- doesn't recognize the role as valid if they are included
                    set_config('role', trim(both '"' from working_role::text), true),
                    set_config('request.jwt.claims', claims::text, true);

                execute 'execute walrus_rls_stmt' into subscription_has_access;

                if subscription_has_access then
                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
                end if;
            end if;
        end loop;

        perform set_config('role', null, true);

        return next (
            output,
            is_rls_enabled,
            visible_to_subscription_ids,
            case
                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']
                else '{}'
            end
        )::realtime.wal_rls;

    end if;
end loop;

perform set_config('role', null, true);
end;
$$;


ALTER FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) OWNER TO supabase_admin;

--
-- Name: broadcast_changes(text, text, text, text, text, record, record, text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    -- Declare a variable to hold the JSONB representation of the row
    row_data jsonb := '{}'::jsonb;
BEGIN
    IF level = 'STATEMENT' THEN
        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';
    END IF;
    -- Check the operation type and handle accordingly
    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN
        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);
        PERFORM realtime.send (row_data, event_name, topic_name);
    ELSE
        RAISE EXCEPTION 'Unexpected operation type: %', operation;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;
END;

$$;


ALTER FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) OWNER TO supabase_admin;

--
-- Name: build_prepared_statement_sql(text, regclass, realtime.wal_column[]); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) RETURNS text
    LANGUAGE sql
    AS $$
      /*
      Builds a sql string that, if executed, creates a prepared statement to
      tests retrive a row from *entity* by its primary key columns.
      Example
          select realtime.build_prepared_statement_sql('public.notes', '{"id"}'::text[], '{"bigint"}'::text[])
      */
          select
      'prepare ' || prepared_statement_name || ' as
          select
              exists(
                  select
                      1
                  from
                      ' || entity || '
                  where
                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '
              )'
          from
              unnest(columns) pkc
          where
              pkc.is_pkey
          group by
              entity
      $$;


ALTER FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) OWNER TO supabase_admin;

--
-- Name: cast(text, regtype); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime."cast"(val text, type_ regtype) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    declare
      res jsonb;
    begin
      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;
      return res;
    end
    $$;


ALTER FUNCTION realtime."cast"(val text, type_ regtype) OWNER TO supabase_admin;

--
-- Name: check_equality_op(realtime.equality_op, regtype, text, text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
      /*
      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness
      */
      declare
          op_symbol text = (
              case
                  when op = 'eq' then '='
                  when op = 'neq' then '!='
                  when op = 'lt' then '<'
                  when op = 'lte' then '<='
                  when op = 'gt' then '>'
                  when op = 'gte' then '>='
                  when op = 'in' then '= any'
                  else 'UNKNOWN OP'
              end
          );
          res boolean;
      begin
          execute format(
              'select %L::'|| type_::text || ' ' || op_symbol
              || ' ( %L::'
              || (
                  case
                      when op = 'in' then type_::text || '[]'
                      else type_::text end
              )
              || ')', val_1, val_2) into res;
          return res;
      end;
      $$;


ALTER FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) OWNER TO supabase_admin;

--
-- Name: is_visible_through_filters(realtime.wal_column[], realtime.user_defined_filter[]); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$
    /*
    Should the record be visible (true) or filtered out (false) after *filters* are applied
    */
        select
            -- Default to allowed when no filters present
            $2 is null -- no filters. this should not happen because subscriptions has a default
            or array_length($2, 1) is null -- array length of an empty array is null
            or bool_and(
                coalesce(
                    realtime.check_equality_op(
                        op:=f.op,
                        type_:=coalesce(
                            col.type_oid::regtype, -- null when wal2json version <= 2.4
                            col.type_name::regtype
                        ),
                        -- cast jsonb to text
                        val_1:=col.value #>> '{}',
                        val_2:=f.value
                    ),
                    false -- if null, filter does not match
                )
            )
        from
            unnest(filters) f
            join unnest(columns) col
                on f.column_name = col.name;
    $_$;


ALTER FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) OWNER TO supabase_admin;

--
-- Name: list_changes(name, name, integer, integer); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) RETURNS SETOF realtime.wal_rls
    LANGUAGE sql
    SET log_min_messages TO 'fatal'
    AS $$
      with pub as (
        select
          concat_ws(
            ',',
            case when bool_or(pubinsert) then 'insert' else null end,
            case when bool_or(pubupdate) then 'update' else null end,
            case when bool_or(pubdelete) then 'delete' else null end
          ) as w2j_actions,
          coalesce(
            string_agg(
              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),
              ','
            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),
            ''
          ) w2j_add_tables
        from
          pg_publication pp
          left join pg_publication_tables ppt
            on pp.pubname = ppt.pubname
        where
          pp.pubname = publication
        group by
          pp.pubname
        limit 1
      ),
      w2j as (
        select
          x.*, pub.w2j_add_tables
        from
          pub,
          pg_logical_slot_get_changes(
            slot_name, null, max_changes,
            'include-pk', 'true',
            'include-transaction', 'false',
            'include-timestamp', 'true',
            'include-type-oids', 'true',
            'format-version', '2',
            'actions', pub.w2j_actions,
            'add-tables', pub.w2j_add_tables
          ) x
      )
      select
        xyz.wal,
        xyz.is_rls_enabled,
        xyz.subscription_ids,
        xyz.errors
      from
        w2j,
        realtime.apply_rls(
          wal := w2j.data::jsonb,
          max_record_bytes := max_record_bytes
        ) xyz(wal, is_rls_enabled, subscription_ids, errors)
      where
        w2j.w2j_add_tables <> ''
        and xyz.subscription_ids[1] is not null
    $$;


ALTER FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) OWNER TO supabase_admin;

--
-- Name: quote_wal2json(regclass); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.quote_wal2json(entity regclass) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
      select
        (
          select string_agg('' || ch,'')
          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
        )
        || '.'
        || (
          select string_agg('' || ch,'')
          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
          )
      from
        pg_class pc
        join pg_namespace nsp
          on pc.relnamespace = nsp.oid
      where
        pc.oid = entity
    $$;


ALTER FUNCTION realtime.quote_wal2json(entity regclass) OWNER TO supabase_admin;

--
-- Name: send(jsonb, text, text, boolean); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  generated_id uuid;
  final_payload jsonb;
BEGIN
  BEGIN
    -- Generate a new UUID for the id
    generated_id := gen_random_uuid();

    -- Check if payload has an 'id' key, if not, add the generated UUID
    IF payload ? 'id' THEN
      final_payload := payload;
    ELSE
      final_payload := jsonb_set(payload, '{id}', to_jsonb(generated_id));
    END IF;

    -- Set the topic configuration
    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);

    -- Attempt to insert the message
    INSERT INTO realtime.messages (id, payload, event, topic, private, extension)
    VALUES (generated_id, final_payload, event, topic, private, 'broadcast');
  EXCEPTION
    WHEN OTHERS THEN
      -- Capture and notify the error
      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;
  END;
END;
$$;


ALTER FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) OWNER TO supabase_admin;

--
-- Name: subscription_check_filters(); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.subscription_check_filters() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    /*
    Validates that the user defined filters for a subscription:
    - refer to valid columns that the claimed role may access
    - values are coercable to the correct column type
    */
    declare
        col_names text[] = coalesce(
                array_agg(c.column_name order by c.ordinal_position),
                '{}'::text[]
            )
            from
                information_schema.columns c
            where
                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity
                and pg_catalog.has_column_privilege(
                    (new.claims ->> 'role'),
                    format('%I.%I', c.table_schema, c.table_name)::regclass,
                    c.column_name,
                    'SELECT'
                );
        filter realtime.user_defined_filter;
        col_type regtype;

        in_val jsonb;
    begin
        for filter in select * from unnest(new.filters) loop
            -- Filtered column is valid
            if not filter.column_name = any(col_names) then
                raise exception 'invalid column for filter %', filter.column_name;
            end if;

            -- Type is sanitized and safe for string interpolation
            col_type = (
                select atttypid::regtype
                from pg_catalog.pg_attribute
                where attrelid = new.entity
                      and attname = filter.column_name
            );
            if col_type is null then
                raise exception 'failed to lookup type for column %', filter.column_name;
            end if;

            -- Set maximum number of entries for in filter
            if filter.op = 'in'::realtime.equality_op then
                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);
                if coalesce(jsonb_array_length(in_val), 0) > 100 then
                    raise exception 'too many values for `in` filter. Maximum 100';
                end if;
            else
                -- raises an exception if value is not coercable to type
                perform realtime.cast(filter.value, col_type);
            end if;

        end loop;

        -- Apply consistent order to filters so the unique constraint on
        -- (subscription_id, entity, filters) can't be tricked by a different filter order
        new.filters = coalesce(
            array_agg(f order by f.column_name, f.op, f.value),
            '{}'
        ) from unnest(new.filters) f;

        return new;
    end;
    $$;


ALTER FUNCTION realtime.subscription_check_filters() OWNER TO supabase_admin;

--
-- Name: to_regrole(text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.to_regrole(role_name text) RETURNS regrole
    LANGUAGE sql IMMUTABLE
    AS $$ select role_name::regrole $$;


ALTER FUNCTION realtime.to_regrole(role_name text) OWNER TO supabase_admin;

--
-- Name: topic(); Type: FUNCTION; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE FUNCTION realtime.topic() RETURNS text
    LANGUAGE sql STABLE
    AS $$
select nullif(current_setting('realtime.topic', true), '')::text;
$$;


ALTER FUNCTION realtime.topic() OWNER TO supabase_realtime_admin;

--
-- Name: can_insert_object(text, text, uuid, jsonb); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO "storage"."objects" ("bucket_id", "name", "owner", "metadata") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$$;


ALTER FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb) OWNER TO supabase_storage_admin;

--
-- Name: delete_leaf_prefixes(text[], text[]); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[]) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_rows_deleted integer;
BEGIN
    LOOP
        WITH candidates AS (
            SELECT DISTINCT
                t.bucket_id,
                unnest(storage.get_prefixes(t.name)) AS name
            FROM unnest(bucket_ids, names) AS t(bucket_id, name)
        ),
        uniq AS (
             SELECT
                 bucket_id,
                 name,
                 storage.get_level(name) AS level
             FROM candidates
             WHERE name <> ''
             GROUP BY bucket_id, name
        ),
        leaf AS (
             SELECT
                 p.bucket_id,
                 p.name,
                 p.level
             FROM storage.prefixes AS p
                  JOIN uniq AS u
                       ON u.bucket_id = p.bucket_id
                           AND u.name = p.name
                           AND u.level = p.level
             WHERE NOT EXISTS (
                 SELECT 1
                 FROM storage.objects AS o
                 WHERE o.bucket_id = p.bucket_id
                   AND o.level = p.level + 1
                   AND o.name COLLATE "C" LIKE p.name || '/%'
             )
             AND NOT EXISTS (
                 SELECT 1
                 FROM storage.prefixes AS c
                 WHERE c.bucket_id = p.bucket_id
                   AND c.level = p.level + 1
                   AND c.name COLLATE "C" LIKE p.name || '/%'
             )
        )
        DELETE
        FROM storage.prefixes AS p
            USING leaf AS l
        WHERE p.bucket_id = l.bucket_id
          AND p.name = l.name
          AND p.level = l.level;

        GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;
        EXIT WHEN v_rows_deleted = 0;
    END LOOP;
END;
$$;


ALTER FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[]) OWNER TO supabase_storage_admin;

--
-- Name: enforce_bucket_name_length(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.enforce_bucket_name_length() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if length(new.name) > 100 then
        raise exception 'bucket name "%" is too long (% characters). Max is 100.', new.name, length(new.name);
    end if;
    return new;
end;
$$;


ALTER FUNCTION storage.enforce_bucket_name_length() OWNER TO supabase_storage_admin;

--
-- Name: extension(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.extension(name text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    _parts text[];
    _filename text;
BEGIN
    SELECT string_to_array(name, '/') INTO _parts;
    SELECT _parts[array_length(_parts,1)] INTO _filename;
    RETURN reverse(split_part(reverse(_filename), '.', 1));
END
$$;


ALTER FUNCTION storage.extension(name text) OWNER TO supabase_storage_admin;

--
-- Name: filename(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.filename(name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$$;


ALTER FUNCTION storage.filename(name text) OWNER TO supabase_storage_admin;

--
-- Name: foldername(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.foldername(name text) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    _parts text[];
BEGIN
    -- Split on "/" to get path segments
    SELECT string_to_array(name, '/') INTO _parts;
    -- Return everything except the last segment
    RETURN _parts[1 : array_length(_parts,1) - 1];
END
$$;


ALTER FUNCTION storage.foldername(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_common_prefix(text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_common_prefix(p_key text, p_prefix text, p_delimiter text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$
SELECT CASE
    WHEN position(p_delimiter IN substring(p_key FROM length(p_prefix) + 1)) > 0
    THEN left(p_key, length(p_prefix) + position(p_delimiter IN substring(p_key FROM length(p_prefix) + 1)))
    ELSE NULL
END;
$$;


ALTER FUNCTION storage.get_common_prefix(p_key text, p_prefix text, p_delimiter text) OWNER TO supabase_storage_admin;

--
-- Name: get_level(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_level(name text) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
SELECT array_length(string_to_array("name", '/'), 1);
$$;


ALTER FUNCTION storage.get_level(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_prefix(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_prefix(name text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
SELECT
    CASE WHEN strpos("name", '/') > 0 THEN
             regexp_replace("name", '[\/]{1}[^\/]+\/?$', '')
         ELSE
             ''
        END;
$_$;


ALTER FUNCTION storage.get_prefix(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_prefixes(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_prefixes(name text) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    parts text[];
    prefixes text[];
    prefix text;
BEGIN
    -- Split the name into parts by '/'
    parts := string_to_array("name", '/');
    prefixes := '{}';

    -- Construct the prefixes, stopping one level below the last part
    FOR i IN 1..array_length(parts, 1) - 1 LOOP
            prefix := array_to_string(parts[1:i], '/');
            prefixes := array_append(prefixes, prefix);
    END LOOP;

    RETURN prefixes;
END;
$$;


ALTER FUNCTION storage.get_prefixes(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_size_by_bucket(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_size_by_bucket() RETURNS TABLE(size bigint, bucket_id text)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    return query
        select sum((metadata->>'size')::bigint) as size, obj.bucket_id
        from "storage".objects as obj
        group by obj.bucket_id;
END
$$;


ALTER FUNCTION storage.get_size_by_bucket() OWNER TO supabase_storage_admin;

--
-- Name: list_multipart_uploads_with_delimiter(text, text, text, integer, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text) RETURNS TABLE(key text, id text, created_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(key COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))
                    ELSE
                        key
                END AS key, id, created_at
            FROM
                storage.s3_multipart_uploads
            WHERE
                bucket_id = $5 AND
                key ILIKE $1 || ''%'' AND
                CASE
                    WHEN $4 != '''' AND $6 = '''' THEN
                        CASE
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                key COLLATE "C" > $4
                            END
                    ELSE
                        true
                END AND
                CASE
                    WHEN $6 != '''' THEN
                        id COLLATE "C" > $6
                    ELSE
                        true
                    END
            ORDER BY
                key COLLATE "C" ASC, created_at ASC) as e order by key COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$_$;


ALTER FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text) OWNER TO supabase_storage_admin;

--
-- Name: list_objects_with_delimiter(text, text, text, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.list_objects_with_delimiter(_bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone)
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    v_peek_name TEXT;
    v_current RECORD;
    v_common_prefix TEXT;

    -- Configuration
    v_is_asc BOOLEAN;
    v_prefix TEXT;
    v_start TEXT;
    v_upper_bound TEXT;
    v_file_batch_size INT;

    -- Seek state
    v_next_seek TEXT;
    v_count INT := 0;

    -- Dynamic SQL for batch query only
    v_batch_query TEXT;

BEGIN
    -- ========================================================================
    -- INITIALIZATION
    -- ========================================================================
    v_is_asc := lower(coalesce(sort_order, 'asc')) = 'asc';
    v_prefix := coalesce(prefix_param, '');
    v_start := CASE WHEN coalesce(next_token, '') <> '' THEN next_token ELSE coalesce(start_after, '') END;
    v_file_batch_size := LEAST(GREATEST(max_keys * 2, 100), 1000);

    -- Calculate upper bound for prefix filtering (bytewise, using COLLATE "C")
    IF v_prefix = '' THEN
        v_upper_bound := NULL;
    ELSIF right(v_prefix, 1) = delimiter_param THEN
        v_upper_bound := left(v_prefix, -1) || chr(ascii(delimiter_param) + 1);
    ELSE
        v_upper_bound := left(v_prefix, -1) || chr(ascii(right(v_prefix, 1)) + 1);
    END IF;

    -- Build batch query (dynamic SQL - called infrequently, amortized over many rows)
    IF v_is_asc THEN
        IF v_upper_bound IS NOT NULL THEN
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE "C" >= $2 ' ||
                'AND o.name COLLATE "C" < $3 ORDER BY o.name COLLATE "C" ASC LIMIT $4';
        ELSE
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE "C" >= $2 ' ||
                'ORDER BY o.name COLLATE "C" ASC LIMIT $4';
        END IF;
    ELSE
        IF v_upper_bound IS NOT NULL THEN
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE "C" < $2 ' ||
                'AND o.name COLLATE "C" >= $3 ORDER BY o.name COLLATE "C" DESC LIMIT $4';
        ELSE
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE "C" < $2 ' ||
                'ORDER BY o.name COLLATE "C" DESC LIMIT $4';
        END IF;
    END IF;

    -- ========================================================================
    -- SEEK INITIALIZATION: Determine starting position
    -- ========================================================================
    IF v_start = '' THEN
        IF v_is_asc THEN
            v_next_seek := v_prefix;
        ELSE
            -- DESC without cursor: find the last item in range
            IF v_upper_bound IS NOT NULL THEN
                SELECT o.name INTO v_next_seek FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE "C" >= v_prefix AND o.name COLLATE "C" < v_upper_bound
                ORDER BY o.name COLLATE "C" DESC LIMIT 1;
            ELSIF v_prefix <> '' THEN
                SELECT o.name INTO v_next_seek FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE "C" >= v_prefix
                ORDER BY o.name COLLATE "C" DESC LIMIT 1;
            ELSE
                SELECT o.name INTO v_next_seek FROM storage.objects o
                WHERE o.bucket_id = _bucket_id
                ORDER BY o.name COLLATE "C" DESC LIMIT 1;
            END IF;

            IF v_next_seek IS NOT NULL THEN
                v_next_seek := v_next_seek || delimiter_param;
            ELSE
                RETURN;
            END IF;
        END IF;
    ELSE
        -- Cursor provided: determine if it refers to a folder or leaf
        IF EXISTS (
            SELECT 1 FROM storage.objects o
            WHERE o.bucket_id = _bucket_id
              AND o.name COLLATE "C" LIKE v_start || delimiter_param || '%'
            LIMIT 1
        ) THEN
            -- Cursor refers to a folder
            IF v_is_asc THEN
                v_next_seek := v_start || chr(ascii(delimiter_param) + 1);
            ELSE
                v_next_seek := v_start || delimiter_param;
            END IF;
        ELSE
            -- Cursor refers to a leaf object
            IF v_is_asc THEN
                v_next_seek := v_start || delimiter_param;
            ELSE
                v_next_seek := v_start;
            END IF;
        END IF;
    END IF;

    -- ========================================================================
    -- MAIN LOOP: Hybrid peek-then-batch algorithm
    -- Uses STATIC SQL for peek (hot path) and DYNAMIC SQL for batch
    -- ========================================================================
    LOOP
        EXIT WHEN v_count >= max_keys;

        -- STEP 1: PEEK using STATIC SQL (plan cached, very fast)
        IF v_is_asc THEN
            IF v_upper_bound IS NOT NULL THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE "C" >= v_next_seek AND o.name COLLATE "C" < v_upper_bound
                ORDER BY o.name COLLATE "C" ASC LIMIT 1;
            ELSE
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE "C" >= v_next_seek
                ORDER BY o.name COLLATE "C" ASC LIMIT 1;
            END IF;
        ELSE
            IF v_upper_bound IS NOT NULL THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE "C" < v_next_seek AND o.name COLLATE "C" >= v_prefix
                ORDER BY o.name COLLATE "C" DESC LIMIT 1;
            ELSIF v_prefix <> '' THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE "C" < v_next_seek AND o.name COLLATE "C" >= v_prefix
                ORDER BY o.name COLLATE "C" DESC LIMIT 1;
            ELSE
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE "C" < v_next_seek
                ORDER BY o.name COLLATE "C" DESC LIMIT 1;
            END IF;
        END IF;

        EXIT WHEN v_peek_name IS NULL;

        -- STEP 2: Check if this is a FOLDER or FILE
        v_common_prefix := storage.get_common_prefix(v_peek_name, v_prefix, delimiter_param);

        IF v_common_prefix IS NOT NULL THEN
            -- FOLDER: Emit and skip to next folder (no heap access needed)
            name := rtrim(v_common_prefix, delimiter_param);
            id := NULL;
            updated_at := NULL;
            created_at := NULL;
            last_accessed_at := NULL;
            metadata := NULL;
            RETURN NEXT;
            v_count := v_count + 1;

            -- Advance seek past the folder range
            IF v_is_asc THEN
                v_next_seek := left(v_common_prefix, -1) || chr(ascii(delimiter_param) + 1);
            ELSE
                v_next_seek := v_common_prefix;
            END IF;
        ELSE
            -- FILE: Batch fetch using DYNAMIC SQL (overhead amortized over many rows)
            -- For ASC: upper_bound is the exclusive upper limit (< condition)
            -- For DESC: prefix is the inclusive lower limit (>= condition)
            FOR v_current IN EXECUTE v_batch_query USING _bucket_id, v_next_seek,
                CASE WHEN v_is_asc THEN COALESCE(v_upper_bound, v_prefix) ELSE v_prefix END, v_file_batch_size
            LOOP
                v_common_prefix := storage.get_common_prefix(v_current.name, v_prefix, delimiter_param);

                IF v_common_prefix IS NOT NULL THEN
                    -- Hit a folder: exit batch, let peek handle it
                    v_next_seek := v_current.name;
                    EXIT;
                END IF;

                -- Emit file
                name := v_current.name;
                id := v_current.id;
                updated_at := v_current.updated_at;
                created_at := v_current.created_at;
                last_accessed_at := v_current.last_accessed_at;
                metadata := v_current.metadata;
                RETURN NEXT;
                v_count := v_count + 1;

                -- Advance seek past this file
                IF v_is_asc THEN
                    v_next_seek := v_current.name || delimiter_param;
                ELSE
                    v_next_seek := v_current.name;
                END IF;

                EXIT WHEN v_count >= max_keys;
            END LOOP;
        END IF;
    END LOOP;
END;
$_$;


ALTER FUNCTION storage.list_objects_with_delimiter(_bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text, sort_order text) OWNER TO supabase_storage_admin;

--
-- Name: operation(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.operation() RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN current_setting('storage.operation', true);
END;
$$;


ALTER FUNCTION storage.operation() OWNER TO supabase_storage_admin;

--
-- Name: protect_delete(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.protect_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Check if storage.allow_delete_query is set to 'true'
    IF COALESCE(current_setting('storage.allow_delete_query', true), 'false') != 'true' THEN
        RAISE EXCEPTION 'Direct deletion from storage tables is not allowed. Use the Storage API instead.'
            USING HINT = 'This prevents accidental data loss from orphaned objects.',
                  ERRCODE = '42501';
    END IF;
    RETURN NULL;
END;
$$;


ALTER FUNCTION storage.protect_delete() OWNER TO supabase_storage_admin;

--
-- Name: search(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    v_peek_name TEXT;
    v_current RECORD;
    v_common_prefix TEXT;
    v_delimiter CONSTANT TEXT := '/';

    -- Configuration
    v_limit INT;
    v_prefix TEXT;
    v_prefix_lower TEXT;
    v_is_asc BOOLEAN;
    v_order_by TEXT;
    v_sort_order TEXT;
    v_upper_bound TEXT;
    v_file_batch_size INT;

    -- Dynamic SQL for batch query only
    v_batch_query TEXT;

    -- Seek state
    v_next_seek TEXT;
    v_count INT := 0;
    v_skipped INT := 0;
BEGIN
    -- ========================================================================
    -- INITIALIZATION
    -- ========================================================================
    v_limit := LEAST(coalesce(limits, 100), 1500);
    v_prefix := coalesce(prefix, '') || coalesce(search, '');
    v_prefix_lower := lower(v_prefix);
    v_is_asc := lower(coalesce(sortorder, 'asc')) = 'asc';
    v_file_batch_size := LEAST(GREATEST(v_limit * 2, 100), 1000);

    -- Validate sort column
    CASE lower(coalesce(sortcolumn, 'name'))
        WHEN 'name' THEN v_order_by := 'name';
        WHEN 'updated_at' THEN v_order_by := 'updated_at';
        WHEN 'created_at' THEN v_order_by := 'created_at';
        WHEN 'last_accessed_at' THEN v_order_by := 'last_accessed_at';
        ELSE v_order_by := 'name';
    END CASE;

    v_sort_order := CASE WHEN v_is_asc THEN 'asc' ELSE 'desc' END;

    -- ========================================================================
    -- NON-NAME SORTING: Use path_tokens approach (unchanged)
    -- ========================================================================
    IF v_order_by != 'name' THEN
        RETURN QUERY EXECUTE format(
            $sql$
            WITH folders AS (
                SELECT path_tokens[$1] AS folder
                FROM storage.objects
                WHERE objects.name ILIKE $2 || '%%'
                  AND bucket_id = $3
                  AND array_length(objects.path_tokens, 1) <> $1
                GROUP BY folder
                ORDER BY folder %s
            )
            (SELECT folder AS "name",
                   NULL::uuid AS id,
                   NULL::timestamptz AS updated_at,
                   NULL::timestamptz AS created_at,
                   NULL::timestamptz AS last_accessed_at,
                   NULL::jsonb AS metadata FROM folders)
            UNION ALL
            (SELECT path_tokens[$1] AS "name",
                   id, updated_at, created_at, last_accessed_at, metadata
             FROM storage.objects
             WHERE objects.name ILIKE $2 || '%%'
               AND bucket_id = $3
               AND array_length(objects.path_tokens, 1) = $1
             ORDER BY %I %s)
            LIMIT $4 OFFSET $5
            $sql$, v_sort_order, v_order_by, v_sort_order
        ) USING levels, v_prefix, bucketname, v_limit, offsets;
        RETURN;
    END IF;

    -- ========================================================================
    -- NAME SORTING: Hybrid skip-scan with batch optimization
    -- ========================================================================

    -- Calculate upper bound for prefix filtering
    IF v_prefix_lower = '' THEN
        v_upper_bound := NULL;
    ELSIF right(v_prefix_lower, 1) = v_delimiter THEN
        v_upper_bound := left(v_prefix_lower, -1) || chr(ascii(v_delimiter) + 1);
    ELSE
        v_upper_bound := left(v_prefix_lower, -1) || chr(ascii(right(v_prefix_lower, 1)) + 1);
    END IF;

    -- Build batch query (dynamic SQL - called infrequently, amortized over many rows)
    IF v_is_asc THEN
        IF v_upper_bound IS NOT NULL THEN
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE "C" >= $2 ' ||
                'AND lower(o.name) COLLATE "C" < $3 ORDER BY lower(o.name) COLLATE "C" ASC LIMIT $4';
        ELSE
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE "C" >= $2 ' ||
                'ORDER BY lower(o.name) COLLATE "C" ASC LIMIT $4';
        END IF;
    ELSE
        IF v_upper_bound IS NOT NULL THEN
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE "C" < $2 ' ||
                'AND lower(o.name) COLLATE "C" >= $3 ORDER BY lower(o.name) COLLATE "C" DESC LIMIT $4';
        ELSE
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE "C" < $2 ' ||
                'ORDER BY lower(o.name) COLLATE "C" DESC LIMIT $4';
        END IF;
    END IF;

    -- Initialize seek position
    IF v_is_asc THEN
        v_next_seek := v_prefix_lower;
    ELSE
        -- DESC: find the last item in range first (static SQL)
        IF v_upper_bound IS NOT NULL THEN
            SELECT o.name INTO v_peek_name FROM storage.objects o
            WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE "C" >= v_prefix_lower AND lower(o.name) COLLATE "C" < v_upper_bound
            ORDER BY lower(o.name) COLLATE "C" DESC LIMIT 1;
        ELSIF v_prefix_lower <> '' THEN
            SELECT o.name INTO v_peek_name FROM storage.objects o
            WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE "C" >= v_prefix_lower
            ORDER BY lower(o.name) COLLATE "C" DESC LIMIT 1;
        ELSE
            SELECT o.name INTO v_peek_name FROM storage.objects o
            WHERE o.bucket_id = bucketname
            ORDER BY lower(o.name) COLLATE "C" DESC LIMIT 1;
        END IF;

        IF v_peek_name IS NOT NULL THEN
            v_next_seek := lower(v_peek_name) || v_delimiter;
        ELSE
            RETURN;
        END IF;
    END IF;

    -- ========================================================================
    -- MAIN LOOP: Hybrid peek-then-batch algorithm
    -- Uses STATIC SQL for peek (hot path) and DYNAMIC SQL for batch
    -- ========================================================================
    LOOP
        EXIT WHEN v_count >= v_limit;

        -- STEP 1: PEEK using STATIC SQL (plan cached, very fast)
        IF v_is_asc THEN
            IF v_upper_bound IS NOT NULL THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE "C" >= v_next_seek AND lower(o.name) COLLATE "C" < v_upper_bound
                ORDER BY lower(o.name) COLLATE "C" ASC LIMIT 1;
            ELSE
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE "C" >= v_next_seek
                ORDER BY lower(o.name) COLLATE "C" ASC LIMIT 1;
            END IF;
        ELSE
            IF v_upper_bound IS NOT NULL THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE "C" < v_next_seek AND lower(o.name) COLLATE "C" >= v_prefix_lower
                ORDER BY lower(o.name) COLLATE "C" DESC LIMIT 1;
            ELSIF v_prefix_lower <> '' THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE "C" < v_next_seek AND lower(o.name) COLLATE "C" >= v_prefix_lower
                ORDER BY lower(o.name) COLLATE "C" DESC LIMIT 1;
            ELSE
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE "C" < v_next_seek
                ORDER BY lower(o.name) COLLATE "C" DESC LIMIT 1;
            END IF;
        END IF;

        EXIT WHEN v_peek_name IS NULL;

        -- STEP 2: Check if this is a FOLDER or FILE
        v_common_prefix := storage.get_common_prefix(lower(v_peek_name), v_prefix_lower, v_delimiter);

        IF v_common_prefix IS NOT NULL THEN
            -- FOLDER: Handle offset, emit if needed, skip to next folder
            IF v_skipped < offsets THEN
                v_skipped := v_skipped + 1;
            ELSE
                name := split_part(rtrim(storage.get_common_prefix(v_peek_name, v_prefix, v_delimiter), v_delimiter), v_delimiter, levels);
                id := NULL;
                updated_at := NULL;
                created_at := NULL;
                last_accessed_at := NULL;
                metadata := NULL;
                RETURN NEXT;
                v_count := v_count + 1;
            END IF;

            -- Advance seek past the folder range
            IF v_is_asc THEN
                v_next_seek := lower(left(v_common_prefix, -1)) || chr(ascii(v_delimiter) + 1);
            ELSE
                v_next_seek := lower(v_common_prefix);
            END IF;
        ELSE
            -- FILE: Batch fetch using DYNAMIC SQL (overhead amortized over many rows)
            -- For ASC: upper_bound is the exclusive upper limit (< condition)
            -- For DESC: prefix_lower is the inclusive lower limit (>= condition)
            FOR v_current IN EXECUTE v_batch_query
                USING bucketname, v_next_seek,
                    CASE WHEN v_is_asc THEN COALESCE(v_upper_bound, v_prefix_lower) ELSE v_prefix_lower END, v_file_batch_size
            LOOP
                v_common_prefix := storage.get_common_prefix(lower(v_current.name), v_prefix_lower, v_delimiter);

                IF v_common_prefix IS NOT NULL THEN
                    -- Hit a folder: exit batch, let peek handle it
                    v_next_seek := lower(v_current.name);
                    EXIT;
                END IF;

                -- Handle offset skipping
                IF v_skipped < offsets THEN
                    v_skipped := v_skipped + 1;
                ELSE
                    -- Emit file
                    name := split_part(v_current.name, v_delimiter, levels);
                    id := v_current.id;
                    updated_at := v_current.updated_at;
                    created_at := v_current.created_at;
                    last_accessed_at := v_current.last_accessed_at;
                    metadata := v_current.metadata;
                    RETURN NEXT;
                    v_count := v_count + 1;
                END IF;

                -- Advance seek past this file
                IF v_is_asc THEN
                    v_next_seek := lower(v_current.name) || v_delimiter;
                ELSE
                    v_next_seek := lower(v_current.name);
                END IF;

                EXIT WHEN v_count >= v_limit;
            END LOOP;
        END IF;
    END LOOP;
END;
$_$;


ALTER FUNCTION storage.search(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text) OWNER TO supabase_storage_admin;

--
-- Name: search_by_timestamp(text, text, integer, integer, text, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_by_timestamp(p_prefix text, p_bucket_id text, p_limit integer, p_level integer, p_start_after text, p_sort_order text, p_sort_column text, p_sort_column_after text) RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    v_cursor_op text;
    v_query text;
    v_prefix text;
BEGIN
    v_prefix := coalesce(p_prefix, '');

    IF p_sort_order = 'asc' THEN
        v_cursor_op := '>';
    ELSE
        v_cursor_op := '<';
    END IF;

    v_query := format($sql$
        WITH raw_objects AS (
            SELECT
                o.name AS obj_name,
                o.id AS obj_id,
                o.updated_at AS obj_updated_at,
                o.created_at AS obj_created_at,
                o.last_accessed_at AS obj_last_accessed_at,
                o.metadata AS obj_metadata,
                storage.get_common_prefix(o.name, $1, '/') AS common_prefix
            FROM storage.objects o
            WHERE o.bucket_id = $2
              AND o.name COLLATE "C" LIKE $1 || '%%'
        ),
        -- Aggregate common prefixes (folders)
        -- Both created_at and updated_at use MIN(obj_created_at) to match the old prefixes table behavior
        aggregated_prefixes AS (
            SELECT
                rtrim(common_prefix, '/') AS name,
                NULL::uuid AS id,
                MIN(obj_created_at) AS updated_at,
                MIN(obj_created_at) AS created_at,
                NULL::timestamptz AS last_accessed_at,
                NULL::jsonb AS metadata,
                TRUE AS is_prefix
            FROM raw_objects
            WHERE common_prefix IS NOT NULL
            GROUP BY common_prefix
        ),
        leaf_objects AS (
            SELECT
                obj_name AS name,
                obj_id AS id,
                obj_updated_at AS updated_at,
                obj_created_at AS created_at,
                obj_last_accessed_at AS last_accessed_at,
                obj_metadata AS metadata,
                FALSE AS is_prefix
            FROM raw_objects
            WHERE common_prefix IS NULL
        ),
        combined AS (
            SELECT * FROM aggregated_prefixes
            UNION ALL
            SELECT * FROM leaf_objects
        ),
        filtered AS (
            SELECT *
            FROM combined
            WHERE (
                $5 = ''
                OR ROW(
                    date_trunc('milliseconds', %I),
                    name COLLATE "C"
                ) %s ROW(
                    COALESCE(NULLIF($6, '')::timestamptz, 'epoch'::timestamptz),
                    $5
                )
            )
        )
        SELECT
            split_part(name, '/', $3) AS key,
            name,
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
        FROM filtered
        ORDER BY
            COALESCE(date_trunc('milliseconds', %I), 'epoch'::timestamptz) %s,
            name COLLATE "C" %s
        LIMIT $4
    $sql$,
        p_sort_column,
        v_cursor_op,
        p_sort_column,
        p_sort_order,
        p_sort_order
    );

    RETURN QUERY EXECUTE v_query
    USING v_prefix, p_bucket_id, p_level, p_limit, p_start_after, p_sort_column_after;
END;
$_$;


ALTER FUNCTION storage.search_by_timestamp(p_prefix text, p_bucket_id text, p_limit integer, p_level integer, p_start_after text, p_sort_order text, p_sort_column text, p_sort_column_after text) OWNER TO supabase_storage_admin;

--
-- Name: search_legacy_v1(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select path_tokens[$1] as folder
           from storage.objects
             where objects.name ilike $2 || $3 || ''%''
               and bucket_id = $4
               and array_length(objects.path_tokens, 1) <> $1
           group by folder
           order by folder ' || v_sort_order || '
     )
     (select folder as "name",
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[$1] as "name",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where objects.name ilike $2 || $3 || ''%''
       and bucket_id = $4
       and array_length(objects.path_tokens, 1) = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$_$;


ALTER FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text) OWNER TO supabase_storage_admin;

--
-- Name: search_v2(text, text, integer, integer, text, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text) RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_sort_col text;
    v_sort_ord text;
    v_limit int;
BEGIN
    -- Cap limit to maximum of 1500 records
    v_limit := LEAST(coalesce(limits, 100), 1500);

    -- Validate and normalize sort_order
    v_sort_ord := lower(coalesce(sort_order, 'asc'));
    IF v_sort_ord NOT IN ('asc', 'desc') THEN
        v_sort_ord := 'asc';
    END IF;

    -- Validate and normalize sort_column
    v_sort_col := lower(coalesce(sort_column, 'name'));
    IF v_sort_col NOT IN ('name', 'updated_at', 'created_at') THEN
        v_sort_col := 'name';
    END IF;

    -- Route to appropriate implementation
    IF v_sort_col = 'name' THEN
        -- Use list_objects_with_delimiter for name sorting (most efficient: O(k * log n))
        RETURN QUERY
        SELECT
            split_part(l.name, '/', levels) AS key,
            l.name AS name,
            l.id,
            l.updated_at,
            l.created_at,
            l.last_accessed_at,
            l.metadata
        FROM storage.list_objects_with_delimiter(
            bucket_name,
            coalesce(prefix, ''),
            '/',
            v_limit,
            start_after,
            '',
            v_sort_ord
        ) l;
    ELSE
        -- Use aggregation approach for timestamp sorting
        -- Not efficient for large datasets but supports correct pagination
        RETURN QUERY SELECT * FROM storage.search_by_timestamp(
            prefix, bucket_name, v_limit, levels, start_after,
            v_sort_ord, v_sort_col, sort_column_after
        );
    END IF;
END;
$$;


ALTER FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer, levels integer, start_after text, sort_order text, sort_column text, sort_column_after text) OWNER TO supabase_storage_admin;

--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$$;


ALTER FUNCTION storage.update_updated_at_column() OWNER TO supabase_storage_admin;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: audit_log_entries; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.audit_log_entries (
    instance_id uuid,
    id uuid NOT NULL,
    payload json,
    created_at timestamp with time zone,
    ip_address character varying(64) DEFAULT ''::character varying NOT NULL
);


ALTER TABLE auth.audit_log_entries OWNER TO supabase_auth_admin;

--
-- Name: TABLE audit_log_entries; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.audit_log_entries IS 'Auth: Audit trail for user actions.';


--
-- Name: flow_state; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.flow_state (
    id uuid NOT NULL,
    user_id uuid,
    auth_code text,
    code_challenge_method auth.code_challenge_method,
    code_challenge text,
    provider_type text NOT NULL,
    provider_access_token text,
    provider_refresh_token text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    authentication_method text NOT NULL,
    auth_code_issued_at timestamp with time zone,
    invite_token text,
    referrer text,
    oauth_client_state_id uuid,
    linking_target_id uuid,
    email_optional boolean DEFAULT false NOT NULL
);


ALTER TABLE auth.flow_state OWNER TO supabase_auth_admin;

--
-- Name: TABLE flow_state; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.flow_state IS 'Stores metadata for all OAuth/SSO login flows';


--
-- Name: identities; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.identities (
    provider_id text NOT NULL,
    user_id uuid NOT NULL,
    identity_data jsonb NOT NULL,
    provider text NOT NULL,
    last_sign_in_at timestamp with time zone,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    email text GENERATED ALWAYS AS (lower((identity_data ->> 'email'::text))) STORED,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE auth.identities OWNER TO supabase_auth_admin;

--
-- Name: TABLE identities; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.identities IS 'Auth: Stores identities associated to a user.';


--
-- Name: COLUMN identities.email; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.identities.email IS 'Auth: Email is a generated column that references the optional email property in the identity_data';


--
-- Name: instances; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.instances (
    id uuid NOT NULL,
    uuid uuid,
    raw_base_config text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone
);


ALTER TABLE auth.instances OWNER TO supabase_auth_admin;

--
-- Name: TABLE instances; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.instances IS 'Auth: Manages users across multiple sites.';


--
-- Name: mfa_amr_claims; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_amr_claims (
    session_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    authentication_method text NOT NULL,
    id uuid NOT NULL
);


ALTER TABLE auth.mfa_amr_claims OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_amr_claims; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_amr_claims IS 'auth: stores authenticator method reference claims for multi factor authentication';


--
-- Name: mfa_challenges; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_challenges (
    id uuid NOT NULL,
    factor_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    verified_at timestamp with time zone,
    ip_address inet NOT NULL,
    otp_code text,
    web_authn_session_data jsonb
);


ALTER TABLE auth.mfa_challenges OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_challenges; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_challenges IS 'auth: stores metadata about challenge requests made';


--
-- Name: mfa_factors; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_factors (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    friendly_name text,
    factor_type auth.factor_type NOT NULL,
    status auth.factor_status NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    secret text,
    phone text,
    last_challenged_at timestamp with time zone,
    web_authn_credential jsonb,
    web_authn_aaguid uuid,
    last_webauthn_challenge_data jsonb
);


ALTER TABLE auth.mfa_factors OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_factors; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_factors IS 'auth: stores metadata about factors';


--
-- Name: COLUMN mfa_factors.last_webauthn_challenge_data; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.mfa_factors.last_webauthn_challenge_data IS 'Stores the latest WebAuthn challenge data including attestation/assertion for customer verification';


--
-- Name: oauth_authorizations; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.oauth_authorizations (
    id uuid NOT NULL,
    authorization_id text NOT NULL,
    client_id uuid NOT NULL,
    user_id uuid,
    redirect_uri text NOT NULL,
    scope text NOT NULL,
    state text,
    resource text,
    code_challenge text,
    code_challenge_method auth.code_challenge_method,
    response_type auth.oauth_response_type DEFAULT 'code'::auth.oauth_response_type NOT NULL,
    status auth.oauth_authorization_status DEFAULT 'pending'::auth.oauth_authorization_status NOT NULL,
    authorization_code text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone DEFAULT (now() + '00:03:00'::interval) NOT NULL,
    approved_at timestamp with time zone,
    nonce text,
    CONSTRAINT oauth_authorizations_authorization_code_length CHECK ((char_length(authorization_code) <= 255)),
    CONSTRAINT oauth_authorizations_code_challenge_length CHECK ((char_length(code_challenge) <= 128)),
    CONSTRAINT oauth_authorizations_expires_at_future CHECK ((expires_at > created_at)),
    CONSTRAINT oauth_authorizations_nonce_length CHECK ((char_length(nonce) <= 255)),
    CONSTRAINT oauth_authorizations_redirect_uri_length CHECK ((char_length(redirect_uri) <= 2048)),
    CONSTRAINT oauth_authorizations_resource_length CHECK ((char_length(resource) <= 2048)),
    CONSTRAINT oauth_authorizations_scope_length CHECK ((char_length(scope) <= 4096)),
    CONSTRAINT oauth_authorizations_state_length CHECK ((char_length(state) <= 4096))
);


ALTER TABLE auth.oauth_authorizations OWNER TO supabase_auth_admin;

--
-- Name: oauth_client_states; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.oauth_client_states (
    id uuid NOT NULL,
    provider_type text NOT NULL,
    code_verifier text,
    created_at timestamp with time zone NOT NULL
);


ALTER TABLE auth.oauth_client_states OWNER TO supabase_auth_admin;

--
-- Name: TABLE oauth_client_states; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.oauth_client_states IS 'Stores OAuth states for third-party provider authentication flows where Supabase acts as the OAuth client.';


--
-- Name: oauth_clients; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.oauth_clients (
    id uuid NOT NULL,
    client_secret_hash text,
    registration_type auth.oauth_registration_type NOT NULL,
    redirect_uris text NOT NULL,
    grant_types text NOT NULL,
    client_name text,
    client_uri text,
    logo_uri text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    client_type auth.oauth_client_type DEFAULT 'confidential'::auth.oauth_client_type NOT NULL,
    token_endpoint_auth_method text NOT NULL,
    CONSTRAINT oauth_clients_client_name_length CHECK ((char_length(client_name) <= 1024)),
    CONSTRAINT oauth_clients_client_uri_length CHECK ((char_length(client_uri) <= 2048)),
    CONSTRAINT oauth_clients_logo_uri_length CHECK ((char_length(logo_uri) <= 2048)),
    CONSTRAINT oauth_clients_token_endpoint_auth_method_check CHECK ((token_endpoint_auth_method = ANY (ARRAY['client_secret_basic'::text, 'client_secret_post'::text, 'none'::text])))
);


ALTER TABLE auth.oauth_clients OWNER TO supabase_auth_admin;

--
-- Name: oauth_consents; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.oauth_consents (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    client_id uuid NOT NULL,
    scopes text NOT NULL,
    granted_at timestamp with time zone DEFAULT now() NOT NULL,
    revoked_at timestamp with time zone,
    CONSTRAINT oauth_consents_revoked_after_granted CHECK (((revoked_at IS NULL) OR (revoked_at >= granted_at))),
    CONSTRAINT oauth_consents_scopes_length CHECK ((char_length(scopes) <= 2048)),
    CONSTRAINT oauth_consents_scopes_not_empty CHECK ((char_length(TRIM(BOTH FROM scopes)) > 0))
);


ALTER TABLE auth.oauth_consents OWNER TO supabase_auth_admin;

--
-- Name: one_time_tokens; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.one_time_tokens (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token_type auth.one_time_token_type NOT NULL,
    token_hash text NOT NULL,
    relates_to text NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT one_time_tokens_token_hash_check CHECK ((char_length(token_hash) > 0))
);


ALTER TABLE auth.one_time_tokens OWNER TO supabase_auth_admin;

--
-- Name: refresh_tokens; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.refresh_tokens (
    instance_id uuid,
    id bigint NOT NULL,
    token character varying(255),
    user_id character varying(255),
    revoked boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    parent character varying(255),
    session_id uuid
);


ALTER TABLE auth.refresh_tokens OWNER TO supabase_auth_admin;

--
-- Name: TABLE refresh_tokens; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.refresh_tokens IS 'Auth: Store of tokens used to refresh JWT tokens once they expire.';


--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE; Schema: auth; Owner: supabase_auth_admin
--

CREATE SEQUENCE auth.refresh_tokens_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE auth.refresh_tokens_id_seq OWNER TO supabase_auth_admin;

--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE OWNED BY; Schema: auth; Owner: supabase_auth_admin
--

ALTER SEQUENCE auth.refresh_tokens_id_seq OWNED BY auth.refresh_tokens.id;


--
-- Name: saml_providers; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.saml_providers (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    entity_id text NOT NULL,
    metadata_xml text NOT NULL,
    metadata_url text,
    attribute_mapping jsonb,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    name_id_format text,
    CONSTRAINT "entity_id not empty" CHECK ((char_length(entity_id) > 0)),
    CONSTRAINT "metadata_url not empty" CHECK (((metadata_url = NULL::text) OR (char_length(metadata_url) > 0))),
    CONSTRAINT "metadata_xml not empty" CHECK ((char_length(metadata_xml) > 0))
);


ALTER TABLE auth.saml_providers OWNER TO supabase_auth_admin;

--
-- Name: TABLE saml_providers; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.saml_providers IS 'Auth: Manages SAML Identity Provider connections.';


--
-- Name: saml_relay_states; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.saml_relay_states (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    request_id text NOT NULL,
    for_email text,
    redirect_to text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    flow_state_id uuid,
    CONSTRAINT "request_id not empty" CHECK ((char_length(request_id) > 0))
);


ALTER TABLE auth.saml_relay_states OWNER TO supabase_auth_admin;

--
-- Name: TABLE saml_relay_states; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.saml_relay_states IS 'Auth: Contains SAML Relay State information for each Service Provider initiated login.';


--
-- Name: schema_migrations; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.schema_migrations (
    version character varying(255) NOT NULL
);


ALTER TABLE auth.schema_migrations OWNER TO supabase_auth_admin;

--
-- Name: TABLE schema_migrations; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.schema_migrations IS 'Auth: Manages updates to the auth system.';


--
-- Name: sessions; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sessions (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    factor_id uuid,
    aal auth.aal_level,
    not_after timestamp with time zone,
    refreshed_at timestamp without time zone,
    user_agent text,
    ip inet,
    tag text,
    oauth_client_id uuid,
    refresh_token_hmac_key text,
    refresh_token_counter bigint,
    scopes text,
    CONSTRAINT sessions_scopes_length CHECK ((char_length(scopes) <= 4096))
);


ALTER TABLE auth.sessions OWNER TO supabase_auth_admin;

--
-- Name: TABLE sessions; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sessions IS 'Auth: Stores session data associated to a user.';


--
-- Name: COLUMN sessions.not_after; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.sessions.not_after IS 'Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.';


--
-- Name: COLUMN sessions.refresh_token_hmac_key; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.sessions.refresh_token_hmac_key IS 'Holds a HMAC-SHA256 key used to sign refresh tokens for this session.';


--
-- Name: COLUMN sessions.refresh_token_counter; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.sessions.refresh_token_counter IS 'Holds the ID (counter) of the last issued refresh token.';


--
-- Name: sso_domains; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sso_domains (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    domain text NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT "domain not empty" CHECK ((char_length(domain) > 0))
);


ALTER TABLE auth.sso_domains OWNER TO supabase_auth_admin;

--
-- Name: TABLE sso_domains; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sso_domains IS 'Auth: Manages SSO email address domain mapping to an SSO Identity Provider.';


--
-- Name: sso_providers; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sso_providers (
    id uuid NOT NULL,
    resource_id text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    disabled boolean,
    CONSTRAINT "resource_id not empty" CHECK (((resource_id = NULL::text) OR (char_length(resource_id) > 0)))
);


ALTER TABLE auth.sso_providers OWNER TO supabase_auth_admin;

--
-- Name: TABLE sso_providers; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sso_providers IS 'Auth: Manages SSO identity provider information; see saml_providers for SAML.';


--
-- Name: COLUMN sso_providers.resource_id; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.sso_providers.resource_id IS 'Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.';


--
-- Name: users; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.users (
    instance_id uuid,
    id uuid NOT NULL,
    aud character varying(255),
    role character varying(255),
    email character varying(255),
    encrypted_password character varying(255),
    email_confirmed_at timestamp with time zone,
    invited_at timestamp with time zone,
    confirmation_token character varying(255),
    confirmation_sent_at timestamp with time zone,
    recovery_token character varying(255),
    recovery_sent_at timestamp with time zone,
    email_change_token_new character varying(255),
    email_change character varying(255),
    email_change_sent_at timestamp with time zone,
    last_sign_in_at timestamp with time zone,
    raw_app_meta_data jsonb,
    raw_user_meta_data jsonb,
    is_super_admin boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    phone text DEFAULT NULL::character varying,
    phone_confirmed_at timestamp with time zone,
    phone_change text DEFAULT ''::character varying,
    phone_change_token character varying(255) DEFAULT ''::character varying,
    phone_change_sent_at timestamp with time zone,
    confirmed_at timestamp with time zone GENERATED ALWAYS AS (LEAST(email_confirmed_at, phone_confirmed_at)) STORED,
    email_change_token_current character varying(255) DEFAULT ''::character varying,
    email_change_confirm_status smallint DEFAULT 0,
    banned_until timestamp with time zone,
    reauthentication_token character varying(255) DEFAULT ''::character varying,
    reauthentication_sent_at timestamp with time zone,
    is_sso_user boolean DEFAULT false NOT NULL,
    deleted_at timestamp with time zone,
    is_anonymous boolean DEFAULT false NOT NULL,
    CONSTRAINT users_email_change_confirm_status_check CHECK (((email_change_confirm_status >= 0) AND (email_change_confirm_status <= 2)))
);


ALTER TABLE auth.users OWNER TO supabase_auth_admin;

--
-- Name: TABLE users; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.users IS 'Auth: Stores user login data within a secure schema.';


--
-- Name: COLUMN users.is_sso_user; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.users.is_sso_user IS 'Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.';


--
-- Name: account_creation_attempts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.account_creation_attempts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    email text NOT NULL,
    phone text,
    ip_address text,
    user_agent text,
    attempt_date timestamp with time zone DEFAULT now(),
    success boolean DEFAULT false,
    error_message text,
    duplicate_detected boolean DEFAULT false,
    existing_user_id uuid
);


ALTER TABLE public.account_creation_attempts OWNER TO postgres;

--
-- Name: user_devices; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_devices (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    player_id text NOT NULL,
    platform text,
    app_version text,
    device_model text,
    os_version text,
    last_active timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT user_devices_platform_check CHECK ((platform = ANY (ARRAY['ios'::text, 'android'::text, 'web'::text])))
);


ALTER TABLE public.user_devices OWNER TO postgres;

--
-- Name: TABLE user_devices; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.user_devices IS 'Stocke les Player IDs OneSignal associ√©s aux utilisateurs';


--
-- Name: active_devices; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.active_devices AS
 SELECT platform,
    count(DISTINCT user_id) AS unique_users,
    count(*) AS total_devices,
    max(last_active) AS most_recent_activity,
    round(avg((EXTRACT(epoch FROM (now() - last_active)) / (3600)::numeric)), 1) AS avg_hours_since_active
   FROM public.user_devices
  WHERE (last_active >= (now() - '7 days'::interval))
  GROUP BY platform;


ALTER VIEW public.active_devices OWNER TO postgres;

--
-- Name: VIEW active_devices; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.active_devices IS 'Devices actifs dans les 7 derniers jours';


--
-- Name: mission_tracking_live; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mission_tracking_live (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    mission_id uuid NOT NULL,
    user_id uuid NOT NULL,
    latitude double precision NOT NULL,
    longitude double precision NOT NULL,
    accuracy double precision,
    altitude double precision,
    bearing double precision,
    speed double precision,
    last_update timestamp with time zone DEFAULT now() NOT NULL,
    battery_level integer,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.mission_tracking_live OWNER TO postgres;

--
-- Name: TABLE mission_tracking_live; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.mission_tracking_live IS 'Position GPS en temps r√©el - UN seul enregistrement par mission (UPDATE, pas INSERT)';


--
-- Name: missions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.missions (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    reference text NOT NULL,
    status text DEFAULT 'pending'::text,
    vehicle_brand text NOT NULL,
    vehicle_model text NOT NULL,
    vehicle_plate text,
    vehicle_vin text,
    vehicle_year integer,
    vehicle_color text,
    pickup_address text NOT NULL,
    pickup_lat numeric(10,8),
    pickup_lng numeric(11,8),
    delivery_address text NOT NULL,
    delivery_lat numeric(10,8),
    delivery_lng numeric(11,8),
    pickup_date timestamp with time zone,
    delivery_date timestamp with time zone,
    client_name text,
    client_phone text,
    client_email text,
    price numeric(10,2) DEFAULT 0,
    distance_km numeric(10,2),
    notes text,
    special_instructions text,
    tracking_code text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    pickup_contact_name text,
    pickup_contact_phone text,
    delivery_contact_name text,
    delivery_contact_phone text,
    vehicle_image_url text,
    driver_id uuid,
    driver_commission numeric DEFAULT 0,
    company_commission numeric DEFAULT 0,
    bonus_amount numeric DEFAULT 0,
    mission_total_ht numeric DEFAULT 0,
    provider_amount_ht numeric DEFAULT 0,
    completed_at timestamp with time zone,
    report_id uuid,
    vehicle_type character varying(2) DEFAULT 'VL'::character varying,
    assigned_user_id uuid,
    archived boolean DEFAULT false,
    share_code character varying(10),
    completed_by uuid,
    completed_via text,
    completed_reason text,
    normalized_share_code text GENERATED ALWAYS AS (upper(regexp_replace((share_code)::text, '[^A-Za-z0-9]'::text, ''::text, 'g'::text))) STORED,
    driver_phone text,
    driver_name text,
    public_tracking_link text,
    pickup_city text,
    delivery_city text,
    pickup_postal_code text,
    delivery_postal_code text,
    started_at timestamp with time zone,
    agent_name text,
    mandataire_name text,
    mandataire_company text,
    has_restitution boolean DEFAULT false,
    restitution_pickup_address text,
    restitution_pickup_city text,
    restitution_pickup_postal_code text,
    restitution_pickup_lat double precision,
    restitution_pickup_lng double precision,
    restitution_pickup_date timestamp with time zone,
    restitution_pickup_contact_name text,
    restitution_pickup_contact_phone text,
    restitution_delivery_address text,
    restitution_delivery_city text,
    restitution_delivery_postal_code text,
    restitution_delivery_lat double precision,
    restitution_delivery_lng double precision,
    restitution_delivery_contact_name text,
    restitution_delivery_contact_phone text,
    restitution_delivery_date timestamp with time zone,
    restitution_vehicle_brand text,
    restitution_vehicle_model text,
    restitution_vehicle_plate text,
    CONSTRAINT check_vehicle_type CHECK (((vehicle_type)::text = ANY ((ARRAY['VL'::character varying, 'VU'::character varying, 'PL'::character varying])::text[]))),
    CONSTRAINT missions_completed_via_check CHECK (((completed_via IS NULL) OR (completed_via = ANY (ARRAY['web'::text, 'mobile'::text, 'rpc'::text, 'backend'::text, 'admin'::text, 'system'::text])))),
    CONSTRAINT missions_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'in_progress'::text, 'completed'::text, 'cancelled'::text])))
);


ALTER TABLE public.missions OWNER TO postgres;

--
-- Name: COLUMN missions.pickup_contact_phone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.pickup_contact_phone IS 'Num√©ro de t√©l√©phone du contact √† l''enl√®vement';


--
-- Name: COLUMN missions.delivery_contact_phone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.delivery_contact_phone IS 'Num√©ro de t√©l√©phone du contact √† la livraison';


--
-- Name: COLUMN missions.driver_commission; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.driver_commission IS 'Commission for the driver (typically price - company_commission)';


--
-- Name: COLUMN missions.company_commission; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.company_commission IS 'Commission/revenu du donneur d''ordre (HT)';


--
-- Name: COLUMN missions.bonus_amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.bonus_amount IS 'Bonus awarded to driver upon assignment';


--
-- Name: COLUMN missions.mission_total_ht; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.mission_total_ht IS 'Montant total de la mission (HT) pour donneur d''ordre';


--
-- Name: COLUMN missions.provider_amount_ht; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.provider_amount_ht IS 'Montant vers√© au prestataire (HT)';


--
-- Name: COLUMN missions.completed_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.completed_at IS 'Timestamp when mission was marked as completed';


--
-- Name: COLUMN missions.report_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.report_id IS 'ID du rapport de mission si disponible';


--
-- Name: COLUMN missions.completed_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.completed_by IS 'UID de l''utilisateur ayant compl√©t√© la mission (auth.uid())';


--
-- Name: COLUMN missions.completed_via; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.completed_via IS 'Origine de la compl√©tion: web|mobile|rpc|backend|admin|system';


--
-- Name: COLUMN missions.completed_reason; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.completed_reason IS 'Raison ou commentaire de la compl√©tion';


--
-- Name: COLUMN missions.public_tracking_link; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.public_tracking_link IS 'Shareable public tracking URL for this mission';


--
-- Name: COLUMN missions.pickup_city; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.pickup_city IS 'City of pickup location (extracted from pickup_address)';


--
-- Name: COLUMN missions.delivery_city; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.delivery_city IS 'City of delivery location (extracted from delivery_address)';


--
-- Name: COLUMN missions.pickup_postal_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.pickup_postal_code IS 'Postal code of pickup location';


--
-- Name: COLUMN missions.delivery_postal_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.delivery_postal_code IS 'Postal code of delivery location';


--
-- Name: COLUMN missions.started_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.started_at IS 'Timestamp when mission actually started (first inspection)';


--
-- Name: COLUMN missions.agent_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.agent_name IS 'Nom du mandataire ou agent repr√©sentant pour cette mission de convoyage';


--
-- Name: COLUMN missions.mandataire_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.mandataire_name IS 'Nom du mandataire qui cr√©e la mission';


--
-- Name: COLUMN missions.mandataire_company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.missions.mandataire_company IS 'Nom de la soci√©t√© qui mandate le transport';


--
-- Name: profiles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.profiles (
    id uuid NOT NULL,
    email text NOT NULL,
    first_name text,
    last_name text,
    full_name text GENERATED ALWAYS AS (COALESCE(((first_name || ' '::text) || last_name), email)) STORED,
    phone text,
    avatar_url text,
    company_name text,
    company_siret text,
    company_address text,
    is_admin boolean DEFAULT false,
    is_verified boolean DEFAULT false,
    rating_average numeric(3,2) DEFAULT 0,
    rating_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    user_role text DEFAULT 'client'::text,
    driver_licenses text[] DEFAULT '{}'::text[],
    availability_status text DEFAULT 'offline'::text,
    current_latitude numeric(10,8),
    current_longitude numeric(11,8),
    missions_as_driver integer DEFAULT 0,
    last_location_update timestamp with time zone,
    user_type text DEFAULT 'donneur_ordre'::text,
    address text,
    legal_form text,
    capital_social numeric(12,2),
    rcs_city text,
    tva_number text,
    tva_applicable boolean DEFAULT true,
    tva_regime text DEFAULT 'normal'::text,
    payment_conditions text DEFAULT '30 jours fin de mois'::text,
    late_penalty_rate numeric(5,2) DEFAULT 10,
    recovery_fee numeric(8,2) DEFAULT 40,
    discount_early_payment text,
    insurance_name text,
    insurance_address text,
    insurance_coverage text,
    logo_url text,
    blocked_credits integer DEFAULT 0,
    credits integer DEFAULT 0,
    wallet_balance numeric DEFAULT 0 NOT NULL,
    company text,
    siret text,
    legal_address text,
    bank_iban text,
    phone_verified boolean DEFAULT false,
    email_verified boolean DEFAULT false,
    siret_verified boolean DEFAULT false,
    device_fingerprint text,
    registration_ip text,
    suspicious_flag boolean DEFAULT false,
    profile_completion_percentage integer DEFAULT 0,
    onboarding_completed boolean DEFAULT false,
    onboarding_completed_at timestamp with time zone,
    company_size text,
    fleet_size integer DEFAULT 0,
    app_role text DEFAULT 'convoyeur'::text,
    billing_meta jsonb DEFAULT '{}'::jsonb,
    last_lat double precision,
    last_lng double precision,
    last_location_at timestamp with time zone,
    location_permission text DEFAULT 'none'::text,
    base_city text,
    base_postal_code text,
    base_lat double precision,
    base_lng double precision,
    max_detour_km double precision DEFAULT 15,
    CONSTRAINT profiles_app_role_check CHECK ((app_role = ANY (ARRAY['admin'::text, 'donneur_d_ordre'::text, 'convoyeur'::text]))),
    CONSTRAINT profiles_blocked_credits_check CHECK ((blocked_credits >= 0)),
    CONSTRAINT profiles_company_size_check CHECK ((company_size = ANY (ARRAY['solo'::text, 'small'::text, 'medium'::text, 'large'::text]))),
    CONSTRAINT profiles_credits_check CHECK ((credits >= 0)),
    CONSTRAINT profiles_location_permission_check CHECK ((location_permission = ANY (ARRAY['none'::text, 'while_in_use'::text, 'always'::text])))
);


ALTER TABLE public.profiles OWNER TO postgres;

--
-- Name: COLUMN profiles.blocked_credits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profiles.blocked_credits IS 'Cr√©dits bloqu√©s pour r√©servations covoiturage en attente (remboursables si annulation > 24h)';


--
-- Name: COLUMN profiles.siret; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profiles.siret IS 'Num√©ro SIRET valid√© via API INSEE';


--
-- Name: COLUMN profiles.device_fingerprint; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profiles.device_fingerprint IS 'Empreinte unique de l''appareil pour d√©tecter comptes multiples';


--
-- Name: COLUMN profiles.registration_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profiles.registration_ip IS 'Adresse IP lors de l''inscription';


--
-- Name: COLUMN profiles.suspicious_flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profiles.suspicious_flag IS 'Flag automatique si comportement suspect d√©tect√©';


--
-- Name: COLUMN profiles.profile_completion_percentage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profiles.profile_completion_percentage IS 'Calcul√© automatiquement via trigger (0-100)';


--
-- Name: COLUMN profiles.billing_meta; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profiles.billing_meta IS 'Billing profile: billing_address, billing_postal_code, billing_city, billing_email, iban, tva_number, payment_terms, company_logo_url, billing_profile_complete';


--
-- Name: COLUMN profiles.base_city; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profiles.base_city IS 'Ville de base du convoyeur (domicile/entreprise) ‚Äî utilis√© pour le retour auto';


--
-- Name: COLUMN profiles.max_detour_km; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profiles.max_detour_km IS 'D√©tour max accept√© en km pour prendre/d√©poser un passager';


--
-- Name: ride_offers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ride_offers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    mission_id uuid,
    origin_city text NOT NULL,
    origin_postal_code text,
    origin_lat double precision,
    origin_lng double precision,
    destination_city text NOT NULL,
    destination_postal_code text,
    destination_lat double precision,
    destination_lng double precision,
    route_geometry jsonb,
    route_cities jsonb DEFAULT '[]'::jsonb,
    route_distance_km double precision,
    route_duration_min integer,
    departure_date date NOT NULL,
    departure_time time without time zone,
    estimated_arrival_time time without time zone,
    flexibility_minutes integer DEFAULT 30,
    max_detour_km double precision DEFAULT 15,
    seats_available integer DEFAULT 1,
    vehicle_type text DEFAULT 'car'::text,
    status text DEFAULT 'active'::text NOT NULL,
    needs_return boolean DEFAULT false,
    return_to_city text,
    return_to_lat double precision,
    return_to_lng double precision,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone,
    CONSTRAINT ride_offers_status_check CHECK ((status = ANY (ARRAY['active'::text, 'paused'::text, 'en_route'::text, 'completed'::text, 'cancelled'::text, 'expired'::text])))
);


ALTER TABLE public.ride_offers OWNER TO postgres;

--
-- Name: TABLE ride_offers; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ride_offers IS 'Offres de place ‚Äî conducteur avec v√©hicule qui propose un si√®ge passager';


--
-- Name: active_drivers_on_road; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.active_drivers_on_road AS
 SELECT mtl.mission_id,
    mtl.user_id AS driver_id,
    mtl.latitude AS current_lat,
    mtl.longitude AS current_lng,
    mtl.speed,
    mtl.bearing,
    mtl.last_update,
    mtl.battery_level,
    m.reference,
    m.pickup_address,
    m.pickup_city,
    m.delivery_address,
    m.delivery_city,
    m.vehicle_brand,
    m.vehicle_model,
    m.vehicle_type,
    p.first_name,
    p.last_name,
    p.company_name,
    p.avatar_url,
    ro.id AS offer_id,
    ro.seats_available,
    ro.max_detour_km,
    ro.route_cities,
    EXTRACT(epoch FROM (now() - mtl.last_update)) AS seconds_since_update,
        CASE
            WHEN (EXTRACT(epoch FROM (now() - mtl.last_update)) < (120)::numeric) THEN 'live'::text
            WHEN (EXTRACT(epoch FROM (now() - mtl.last_update)) < (600)::numeric) THEN 'recent'::text
            ELSE 'stale'::text
        END AS freshness
   FROM (((public.mission_tracking_live mtl
     JOIN public.missions m ON ((m.id = mtl.mission_id)))
     JOIN public.profiles p ON ((p.id = mtl.user_id)))
     JOIN public.ride_offers ro ON (((ro.mission_id = mtl.mission_id) AND (ro.status = ANY (ARRAY['active'::text, 'en_route'::text])))))
  WHERE ((mtl.is_active = true) AND (m.status = 'in_progress'::text))
  ORDER BY mtl.last_update DESC;


ALTER VIEW public.active_drivers_on_road OWNER TO postgres;

--
-- Name: VIEW active_drivers_on_road; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.active_drivers_on_road IS 'Conducteurs en route ayant publi√© une offre de place ‚Äî seuls les convoyeurs inscrits au r√©seau planning apparaissent';


--
-- Name: subscriptions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.subscriptions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    plan text NOT NULL,
    status text DEFAULT 'active'::text NOT NULL,
    current_period_start timestamp with time zone DEFAULT now(),
    current_period_end timestamp with time zone,
    cancel_at_period_end boolean DEFAULT false,
    payment_method text,
    assigned_by uuid,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    auto_renew boolean DEFAULT false,
    CONSTRAINT subscriptions_plan_check CHECK ((plan = ANY (ARRAY['free'::text, 'starter'::text, 'essentiel'::text, 'basic'::text, 'pro'::text, 'business'::text, 'enterprise'::text]))),
    CONSTRAINT subscriptions_status_check CHECK ((status = ANY (ARRAY['active'::text, 'canceled'::text, 'expired'::text, 'trial'::text])))
);


ALTER TABLE public.subscriptions OWNER TO postgres;

--
-- Name: COLUMN subscriptions.auto_renew; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.subscriptions.auto_renew IS 'Si true, l''abonnement recevra automatiquement des cr√©dits mensuels';


--
-- Name: admin_auto_renew_status; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.admin_auto_renew_status AS
 SELECT p.id AS user_id,
    p.email,
    s.plan,
    s.status,
    s.auto_renew,
    s.current_period_end,
    p.credits AS credits_actuels,
        CASE s.plan
            WHEN 'starter'::text THEN 10
            WHEN 'basic'::text THEN 25
            WHEN 'pro'::text THEN 100
            WHEN 'business'::text THEN 500
            WHEN 'enterprise'::text THEN 500
            ELSE 0
        END AS credits_mensuels,
        CASE
            WHEN s.auto_renew THEN '‚úÖ Activ√©'::text
            ELSE '‚ùå D√©sactiv√©'::text
        END AS statut_auto_renew
   FROM (public.profiles p
     JOIN public.subscriptions s ON ((s.user_id = p.id)))
  WHERE ((s.status = 'active'::text) AND ((s.current_period_end IS NULL) OR (s.current_period_end > now())))
  ORDER BY s.auto_renew DESC, s.plan DESC, p.email;


ALTER VIEW public.admin_auto_renew_status OWNER TO postgres;

--
-- Name: VIEW admin_auto_renew_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.admin_auto_renew_status IS 'Vue admin pour g√©rer les renouvellements automatiques';


--
-- Name: app_versions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.app_versions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    version_name text NOT NULL,
    version_code integer NOT NULL,
    apk_url text NOT NULL,
    file_size bigint NOT NULL,
    release_notes text,
    is_mandatory boolean DEFAULT false,
    is_active boolean DEFAULT true,
    min_supported_version integer,
    uploaded_by uuid,
    download_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.app_versions OWNER TO postgres;

--
-- Name: attachments; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.attachments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    file_name text NOT NULL,
    file_type text NOT NULL,
    file_size integer NOT NULL,
    storage_path text NOT NULL,
    category text,
    related_to text,
    related_type text,
    description text,
    public_url text,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT attachments_category_check CHECK ((category = ANY (ARRAY['invoice'::text, 'quote'::text, 'contract'::text, 'report'::text, 'photo'::text, 'other'::text]))),
    CONSTRAINT attachments_related_type_check CHECK ((related_type = ANY (ARRAY['invoice'::text, 'quote'::text, 'mission'::text, 'inspection'::text, 'client'::text])))
);


ALTER TABLE public.attachments OWNER TO postgres;

--
-- Name: TABLE attachments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.attachments IS 'Table pour stocker les m√©tadonn√©es des pi√®ces jointes upload√©es par les utilisateurs';


--
-- Name: COLUMN attachments.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.attachments.user_id IS 'ID de l''utilisateur propri√©taire du fichier';


--
-- Name: COLUMN attachments.file_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.attachments.file_name IS 'Nom original du fichier';


--
-- Name: COLUMN attachments.file_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.attachments.file_type IS 'Type MIME du fichier (ex: image/png)';


--
-- Name: COLUMN attachments.file_size; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.attachments.file_size IS 'Taille du fichier en octets';


--
-- Name: COLUMN attachments.storage_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.attachments.storage_path IS 'Chemin du fichier dans Supabase Storage';


--
-- Name: COLUMN attachments.category; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.attachments.category IS 'Cat√©gorie du fichier (invoice, quote, contract, etc.)';


--
-- Name: COLUMN attachments.related_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.attachments.related_to IS 'ID du document li√© (facture, mission, etc.)';


--
-- Name: COLUMN attachments.related_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.attachments.related_type IS 'Type du document li√©';


--
-- Name: COLUMN attachments.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.attachments.description IS 'Description optionnelle du fichier';


--
-- Name: COLUMN attachments.public_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.attachments.public_url IS 'URL publique du fichier';


--
-- Name: availability_calendar; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.availability_calendar (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    date date NOT NULL,
    status text NOT NULL,
    start_time time without time zone,
    end_time time without time zone,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT availability_calendar_status_check CHECK ((status = ANY (ARRAY['available'::text, 'unavailable'::text, 'partially_available'::text])))
);


ALTER TABLE public.availability_calendar OWNER TO postgres;

--
-- Name: calendar_events; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.calendar_events (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    owner_id uuid NOT NULL,
    created_by_id uuid,
    title text NOT NULL,
    description text,
    event_type text DEFAULT 'other'::text NOT NULL,
    start_time timestamp with time zone NOT NULL,
    end_time timestamp with time zone NOT NULL,
    location text,
    mission_id uuid,
    color text DEFAULT '#3b82f6'::text NOT NULL,
    is_all_day boolean DEFAULT false NOT NULL,
    reminder_minutes integer DEFAULT 15,
    status text DEFAULT 'scheduled'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE public.calendar_events OWNER TO postgres;

--
-- Name: calendar_permissions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.calendar_permissions (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    owner_id uuid NOT NULL,
    shared_with_id uuid NOT NULL,
    permission_level text DEFAULT 'view'::text NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE public.calendar_permissions OWNER TO postgres;

--
-- Name: carpooling_messages; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.carpooling_messages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    trip_id uuid NOT NULL,
    sender_id uuid NOT NULL,
    receiver_id uuid NOT NULL,
    message text NOT NULL,
    is_read boolean DEFAULT false,
    read_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.carpooling_messages OWNER TO postgres;

--
-- Name: TABLE carpooling_messages; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.carpooling_messages IS 'Messages entre conducteurs et passagers pour un trajet de covoiturage';


--
-- Name: carpooling_trips; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.carpooling_trips (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    driver_id uuid NOT NULL,
    departure_address text NOT NULL,
    departure_city text NOT NULL,
    departure_datetime timestamp with time zone NOT NULL,
    arrival_address text NOT NULL,
    arrival_city text NOT NULL,
    total_seats integer NOT NULL,
    available_seats integer NOT NULL,
    price_per_seat numeric(10,2) NOT NULL,
    status text DEFAULT 'active'::text NOT NULL,
    allows_pets boolean DEFAULT false,
    allows_smoking boolean DEFAULT false,
    allows_music boolean DEFAULT true,
    chat_level text DEFAULT 'blabla'::text,
    max_two_back boolean DEFAULT false,
    luggage_size text DEFAULT 'medium'::text,
    instant_booking boolean DEFAULT false,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT carpooling_trips_available_seats_check CHECK ((available_seats >= 0)),
    CONSTRAINT carpooling_trips_chat_level_check CHECK ((chat_level = ANY (ARRAY['bla'::text, 'blabla'::text, 'blablabla'::text]))),
    CONSTRAINT carpooling_trips_luggage_size_check CHECK ((luggage_size = ANY (ARRAY['small'::text, 'medium'::text, 'large'::text, 'xl'::text]))),
    CONSTRAINT carpooling_trips_price_per_seat_check CHECK ((price_per_seat >= 2.00)),
    CONSTRAINT carpooling_trips_status_check CHECK ((status = ANY (ARRAY['active'::text, 'cancelled'::text, 'completed'::text, 'full'::text]))),
    CONSTRAINT carpooling_trips_total_seats_check CHECK (((total_seats >= 1) AND (total_seats <= 8)))
);


ALTER TABLE public.carpooling_trips OWNER TO postgres;

--
-- Name: TABLE carpooling_trips; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.carpooling_trips IS 'Trajets de covoiturage publi√©s par les conducteurs';


--
-- Name: COLUMN carpooling_trips.price_per_seat; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.carpooling_trips.price_per_seat IS 'Prix minimum 2‚Ç¨ par place (r√®gle BlaBlaCar)';


--
-- Name: COLUMN carpooling_trips.chat_level; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.carpooling_trips.chat_level IS 'Niveau bavardage : bla (silencieux), blabla (normal), blablabla (tr√®s bavard)';


--
-- Name: COLUMN carpooling_trips.instant_booking; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.carpooling_trips.instant_booking IS 'R√©servation instantan√©e sans validation conducteur';


--
-- Name: carpooling_active_conversations; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.carpooling_active_conversations AS
 WITH latest_messages AS (
         SELECT DISTINCT ON (carpooling_messages.trip_id, LEAST(carpooling_messages.sender_id, carpooling_messages.receiver_id), GREATEST(carpooling_messages.sender_id, carpooling_messages.receiver_id)) carpooling_messages.id,
            carpooling_messages.trip_id,
            carpooling_messages.sender_id,
            carpooling_messages.receiver_id,
            carpooling_messages.message,
            carpooling_messages.created_at,
            carpooling_messages.is_read
           FROM public.carpooling_messages
          ORDER BY carpooling_messages.trip_id, LEAST(carpooling_messages.sender_id, carpooling_messages.receiver_id), GREATEST(carpooling_messages.sender_id, carpooling_messages.receiver_id), carpooling_messages.created_at DESC
        )
 SELECT lm.id,
    lm.trip_id,
    lm.sender_id,
    lm.receiver_id,
    lm.message AS last_message,
    lm.created_at AS last_message_at,
    lm.is_read AS last_message_read,
    t.departure_city,
    t.arrival_city,
    t.departure_datetime
   FROM (latest_messages lm
     JOIN public.carpooling_trips t ON ((t.id = lm.trip_id)));


ALTER VIEW public.carpooling_active_conversations OWNER TO postgres;

--
-- Name: VIEW carpooling_active_conversations; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.carpooling_active_conversations IS 'Derniers messages par conversation (trip + 2 utilisateurs)';


--
-- Name: carpooling_bookings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.carpooling_bookings (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    trip_id uuid NOT NULL,
    passenger_id uuid NOT NULL,
    seats_booked integer NOT NULL,
    total_price numeric(10,2) NOT NULL,
    trip_price numeric(10,2) NOT NULL,
    credit_cost integer DEFAULT 2,
    status text DEFAULT 'pending'::text NOT NULL,
    message text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT carpooling_bookings_credit_cost_check CHECK ((credit_cost >= 0)),
    CONSTRAINT carpooling_bookings_message_check CHECK ((char_length(message) >= 20)),
    CONSTRAINT carpooling_bookings_seats_booked_check CHECK ((seats_booked >= 1)),
    CONSTRAINT carpooling_bookings_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'confirmed'::text, 'rejected'::text, 'cancelled'::text, 'completed'::text, 'no_show'::text])))
);


ALTER TABLE public.carpooling_bookings OWNER TO postgres;

--
-- Name: TABLE carpooling_bookings; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.carpooling_bookings IS 'R√©servations de covoiturage par les passagers';


--
-- Name: COLUMN carpooling_bookings.total_price; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.carpooling_bookings.total_price IS 'Prix total en esp√®ces √† payer au conducteur le jour du trajet';


--
-- Name: COLUMN carpooling_bookings.credit_cost; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.carpooling_bookings.credit_cost IS 'Nombre de cr√©dits bloqu√©s pour cette r√©servation (2 par d√©faut)';


--
-- Name: COLUMN carpooling_bookings.message; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.carpooling_bookings.message IS 'Message au conducteur (minimum 20 caract√®res obligatoire)';


--
-- Name: invoices; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoices (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    invoice_number text NOT NULL,
    client_name text,
    client_email text,
    client_phone text,
    client_address text,
    client_siret text,
    issue_date date DEFAULT CURRENT_DATE NOT NULL,
    due_date date,
    paid_date date,
    subtotal numeric(10,2) DEFAULT 0 NOT NULL,
    tax_rate numeric(5,2) DEFAULT 20,
    tax_amount numeric(10,2) DEFAULT 0,
    discount_amount numeric(10,2) DEFAULT 0,
    total numeric(10,2) DEFAULT 0 NOT NULL,
    status text DEFAULT 'draft'::text,
    notes text,
    payment_terms text,
    pdf_url text,
    mission_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    client_id uuid,
    vat_liable boolean DEFAULT true,
    vat_regime text DEFAULT 'normal'::text,
    legal_mentions text,
    client_vat_number text,
    client_legal_form text,
    client_activity_code text,
    payment_method text,
    paid_at timestamp with time zone,
    sent_at timestamp with time zone,
    client_info jsonb,
    invoice_date date,
    CONSTRAINT invoices_status_check CHECK ((status = ANY (ARRAY['draft'::text, 'pending'::text, 'sent'::text, 'paid'::text, 'overdue'::text, 'cancelled'::text]))),
    CONSTRAINT invoices_vat_regime_check CHECK ((vat_regime = ANY (ARRAY['normal'::text, 'franchise'::text, 'micro'::text])))
);


ALTER TABLE public.invoices OWNER TO postgres;

--
-- Name: COLUMN invoices.client_phone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.client_phone IS 'Num√©ro de t√©l√©phone du client';


--
-- Name: COLUMN invoices.client_siret; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.client_siret IS 'Num√©ro SIRET du client (14 chiffres) - d√©j√† existant';


--
-- Name: COLUMN invoices.mission_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.mission_id IS 'R√©f√©rence vers la mission de convoyage (optionnel)';


--
-- Name: COLUMN invoices.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.client_id IS 'R√©f√©rence vers le client (optionnel)';


--
-- Name: COLUMN invoices.vat_liable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.vat_liable IS 'Indique si l''entreprise est assujettie √† la TVA (true = TVA appliqu√©e, false = pas de TVA)';


--
-- Name: COLUMN invoices.vat_regime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.vat_regime IS 'R√©gime fiscal: normal (TVA normale), franchise (franchise en base TVA), micro (micro-entreprise)';


--
-- Name: COLUMN invoices.legal_mentions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.legal_mentions IS 'Mentions l√©gales obligatoires automatiques ou personnalis√©es';


--
-- Name: COLUMN invoices.client_vat_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.client_vat_number IS 'Num√©ro de TVA intracommunautaire (FRxx xxxxxxxxx)';


--
-- Name: COLUMN invoices.client_legal_form; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.client_legal_form IS 'Forme juridique (SARL, SAS, etc.)';


--
-- Name: COLUMN invoices.client_activity_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.client_activity_code IS 'Code NAF/APE';


--
-- Name: COLUMN invoices.payment_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.payment_method IS 'M√©thode de paiement utilis√©e (carte, virement, esp√®ces, etc.)';


--
-- Name: COLUMN invoices.paid_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.paid_at IS 'Date et heure du paiement';


--
-- Name: COLUMN invoices.sent_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.sent_at IS 'Timestamp when invoice was sent to client';


--
-- Name: COLUMN invoices.client_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.client_info IS 'Informations client au format JSONB (name, email, phone, address, siret, vat_number, payment_terms, etc.)';


--
-- Name: COLUMN invoices.invoice_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.invoice_date IS 'Date de la facture (alias de issue_date)';


--
-- Name: client_companies; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.client_companies AS
 SELECT client_siret AS siret,
    client_vat_number AS vat_number,
    client_name AS company_name,
    client_legal_form AS legal_form,
    client_activity_code AS activity_code,
    client_address AS address,
    client_email AS email,
    client_phone AS phone,
    count(id) AS total_documents,
    sum(total) AS total_amount,
    max(COALESCE(issue_date, (created_at)::date)) AS last_activity_date
   FROM public.invoices
  WHERE ((client_siret IS NOT NULL) AND (client_siret <> ''::text))
  GROUP BY client_siret, client_vat_number, client_name, client_legal_form, client_activity_code, client_address, client_email, client_phone
  ORDER BY (max(COALESCE(issue_date, (created_at)::date))) DESC;


ALTER VIEW public.client_companies OWNER TO postgres;

--
-- Name: clients; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.clients (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    name text NOT NULL,
    email text,
    phone text,
    company_name text,
    siret text,
    siren text,
    address text,
    postal_code text,
    city text,
    country text DEFAULT 'France'::text,
    notes text,
    is_company boolean DEFAULT false,
    is_favorite boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    payment_terms integer DEFAULT 30,
    tva_number text,
    website text
);


ALTER TABLE public.clients OWNER TO postgres;

--
-- Name: contacts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.contacts (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    name text NOT NULL,
    company text,
    email text,
    phone text,
    address text,
    notes text,
    category text DEFAULT 'client'::text,
    is_favorite boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    has_calendar_access boolean DEFAULT false,
    role text DEFAULT 'driver'::text,
    is_active boolean DEFAULT true,
    is_driver boolean DEFAULT false,
    driver_licenses text[] DEFAULT '{}'::text[],
    current_latitude numeric(10,8),
    current_longitude numeric(11,8),
    availability_status text DEFAULT 'offline'::text,
    preferred_zones text[] DEFAULT '{}'::text[],
    rating_average numeric(3,2) DEFAULT 0,
    missions_completed integer DEFAULT 0,
    last_location_update timestamp with time zone,
    invitation_status text DEFAULT 'pending'::text,
    invited_by uuid,
    invited_user_id uuid,
    invitation_sent_at timestamp with time zone DEFAULT now(),
    invitation_responded_at timestamp with time zone,
    type text DEFAULT 'customer'::text NOT NULL,
    CONSTRAINT contacts_category_check CHECK ((category = ANY (ARRAY['client'::text, 'supplier'::text, 'partner'::text, 'other'::text]))),
    CONSTRAINT contacts_invitation_status_check CHECK ((invitation_status = ANY (ARRAY['pending'::text, 'accepted'::text, 'rejected'::text]))),
    CONSTRAINT contacts_type_check CHECK ((type = ANY (ARRAY['customer'::text, 'driver'::text, 'supplier'::text])))
);


ALTER TABLE public.contacts OWNER TO postgres;

--
-- Name: COLUMN contacts.invitation_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contacts.invitation_status IS 'Status of contact invitation: pending, accepted, or rejected';


--
-- Name: COLUMN contacts.invited_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contacts.invited_by IS 'User who sent the invitation';


--
-- Name: COLUMN contacts.invited_user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contacts.invited_user_id IS 'User who received the invitation';


--
-- Name: COLUMN contacts.invitation_sent_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contacts.invitation_sent_at IS 'When the invitation was sent';


--
-- Name: COLUMN contacts.invitation_responded_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contacts.invitation_responded_at IS 'When the invitation was accepted/rejected';


--
-- Name: contact_availability; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.contact_availability AS
 SELECT c.id AS contact_id,
    c.user_id AS viewer_id,
    c.invited_user_id AS contact_user_id,
    c.name AS contact_name,
    c.email AS contact_email,
    c.type AS contact_type,
    c.has_calendar_access,
    ac.id AS availability_id,
    ac.date,
    ac.status,
    ac.start_time,
    ac.end_time,
    ac.notes,
    ac.created_at,
    ac.updated_at
   FROM (public.contacts c
     LEFT JOIN public.availability_calendar ac ON ((c.invited_user_id = ac.user_id)))
  WHERE ((c.invitation_status = 'accepted'::text) AND (c.has_calendar_access = true));


ALTER VIEW public.contact_availability OWNER TO postgres;

--
-- Name: contact_invitations_received; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.contact_invitations_received AS
 SELECT c.id,
    c.user_id,
    c.name,
    c.company,
    c.email,
    c.phone,
    c.address,
    c.notes,
    c.category,
    c.is_favorite,
    c.created_at,
    c.updated_at,
    c.has_calendar_access,
    c.role,
    c.is_active,
    c.is_driver,
    c.driver_licenses,
    c.current_latitude,
    c.current_longitude,
    c.availability_status,
    c.preferred_zones,
    c.rating_average,
    c.missions_completed,
    c.last_location_update,
    c.invitation_status,
    c.invited_by,
    c.invited_user_id,
    c.invitation_sent_at,
    c.invitation_responded_at,
    p.full_name AS inviter_name,
    p.email AS inviter_email,
    p.phone AS inviter_phone
   FROM (public.contacts c
     LEFT JOIN public.profiles p ON ((c.invited_by = p.id)))
  WHERE (c.invitation_status = 'pending'::text);


ALTER VIEW public.contact_invitations_received OWNER TO postgres;

--
-- Name: contact_invitations_sent; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.contact_invitations_sent AS
 SELECT c.id,
    c.user_id,
    c.name,
    c.company,
    c.email,
    c.phone,
    c.address,
    c.notes,
    c.category,
    c.is_favorite,
    c.created_at,
    c.updated_at,
    c.has_calendar_access,
    c.role,
    c.is_active,
    c.is_driver,
    c.driver_licenses,
    c.current_latitude,
    c.current_longitude,
    c.availability_status,
    c.preferred_zones,
    c.rating_average,
    c.missions_completed,
    c.last_location_update,
    c.invitation_status,
    c.invited_by,
    c.invited_user_id,
    c.invitation_sent_at,
    c.invitation_responded_at,
    p.full_name AS invited_name,
    p.email AS invited_email,
    p.phone AS invited_phone
   FROM (public.contacts c
     LEFT JOIN public.profiles p ON ((c.invited_user_id = p.id)))
  WHERE (c.invitation_status = 'pending'::text);


ALTER VIEW public.contact_invitations_sent OWNER TO postgres;

--
-- Name: contact_requests; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.contact_requests (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    requester_id uuid NOT NULL,
    target_email text NOT NULL,
    target_name text,
    status text DEFAULT 'pending'::text NOT NULL,
    message text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    accepted_at timestamp with time zone,
    CONSTRAINT contact_requests_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'rejected'::text, 'cancelled'::text])))
);


ALTER TABLE public.contact_requests OWNER TO postgres;

--
-- Name: TABLE contact_requests; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.contact_requests IS 'Demandes d''ajout de contacts entre utilisateurs';


--
-- Name: COLUMN contact_requests.requester_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contact_requests.requester_id IS 'ID de l''utilisateur qui demande l''ajout';


--
-- Name: COLUMN contact_requests.target_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contact_requests.target_email IS 'Email du contact √† ajouter';


--
-- Name: COLUMN contact_requests.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contact_requests.status IS 'pending, accepted, rejected, cancelled';


--
-- Name: convoy_plannings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.convoy_plannings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    title text NOT NULL,
    description text,
    planning_date date NOT NULL,
    start_time time without time zone NOT NULL,
    end_time time without time zone NOT NULL,
    flexibility_minutes integer DEFAULT 30,
    origin_city text NOT NULL,
    origin_postal_code text,
    origin_lat double precision,
    origin_lng double precision,
    destination_city text NOT NULL,
    destination_postal_code text,
    destination_lat double precision,
    destination_lng double precision,
    status text DEFAULT 'published'::text NOT NULL,
    is_return_trip boolean DEFAULT false,
    vehicle_category text DEFAULT 'all'::text,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone,
    current_waypoint_index integer DEFAULT 0,
    return_city text,
    return_postal_code text,
    return_lat double precision,
    return_lng double precision,
    CONSTRAINT convoy_plannings_status_check CHECK ((status = ANY (ARRAY['draft'::text, 'published'::text, 'completed'::text, 'cancelled'::text]))),
    CONSTRAINT convoy_plannings_vehicle_category_check CHECK ((vehicle_category = ANY (ARRAY['all'::text, 'car'::text, 'utility'::text, 'truck'::text, 'motorcycle'::text])))
);


ALTER TABLE public.convoy_plannings OWNER TO postgres;

--
-- Name: TABLE convoy_plannings; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.convoy_plannings IS 'Plannings publi√©s par les convoyeurs pour synchronisation de trajets';


--
-- Name: COLUMN convoy_plannings.return_city; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.convoy_plannings.return_city IS 'Ville de retour du convoyeur (o√π il rentre √† vide)';


--
-- Name: COLUMN convoy_plannings.return_lat; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.convoy_plannings.return_lat IS 'Latitude de la ville de retour';


--
-- Name: COLUMN convoy_plannings.return_lng; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.convoy_plannings.return_lng IS 'Longitude de la ville de retour';


--
-- Name: covoiturage_trips; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.covoiturage_trips (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    departure_city character varying(255) NOT NULL,
    departure_address text,
    departure_lat numeric(10,8),
    departure_lng numeric(11,8),
    arrival_city character varying(255) NOT NULL,
    arrival_address text,
    arrival_lat numeric(10,8),
    arrival_lng numeric(11,8),
    departure_date date NOT NULL,
    departure_time time without time zone NOT NULL,
    arrival_time time without time zone,
    duration integer,
    available_seats integer DEFAULT 1 NOT NULL,
    price_per_seat numeric(10,2) NOT NULL,
    total_distance integer,
    comfort_level character varying(50) DEFAULT 'basic'::character varying,
    features text[],
    vehicle_brand character varying(100),
    vehicle_model character varying(100),
    vehicle_color character varying(50),
    vehicle_plate character varying(20),
    max_detour integer DEFAULT 0,
    instant_booking boolean DEFAULT false,
    women_only boolean DEFAULT false,
    status character varying(50) DEFAULT 'published'::character varying,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.covoiturage_trips OWNER TO postgres;

--
-- Name: TABLE covoiturage_trips; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.covoiturage_trips IS 'Trajets de covoiturage publi√©s par les conducteurs';


--
-- Name: credit_transactions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.credit_transactions (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    transaction_type text NOT NULL,
    amount integer NOT NULL,
    balance_after integer NOT NULL,
    description text,
    reference_id uuid,
    reference_type text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT credit_transactions_transaction_type_check CHECK ((transaction_type = ANY (ARRAY['addition'::text, 'deduction'::text])))
);


ALTER TABLE public.credit_transactions OWNER TO postgres;

--
-- Name: deletion_requests; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.deletion_requests (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    reason text,
    requested_at timestamp with time zone DEFAULT now(),
    processed_at timestamp with time zone,
    status text DEFAULT 'pending'::text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT deletion_requests_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text, 'completed'::text])))
);


ALTER TABLE public.deletion_requests OWNER TO postgres;

--
-- Name: documents; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.documents (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    mission_id uuid,
    inspection_id uuid,
    document_type text NOT NULL,
    file_name text NOT NULL,
    file_url text NOT NULL,
    file_size integer,
    mime_type text,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT documents_document_type_check CHECK ((document_type = ANY (ARRAY['inspection_report'::text, 'invoice'::text, 'quote'::text, 'photo'::text, 'signature'::text, 'other'::text])))
);


ALTER TABLE public.documents OWNER TO postgres;

--
-- Name: gps_location_points; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.gps_location_points (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    session_id uuid NOT NULL,
    latitude numeric(10,8) NOT NULL,
    longitude numeric(11,8) NOT NULL,
    altitude numeric(8,2),
    accuracy numeric(8,2),
    speed_kmh numeric(5,2),
    heading numeric(5,2),
    recorded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    location public.geometry(Point,4326),
    is_valid boolean DEFAULT true
);


ALTER TABLE public.gps_location_points OWNER TO postgres;

--
-- Name: gps_tracking_sessions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.gps_tracking_sessions (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    mission_id uuid NOT NULL,
    driver_id uuid NOT NULL,
    departure_inspection_id uuid,
    arrival_inspection_id uuid,
    start_latitude numeric(10,8),
    start_longitude numeric(11,8),
    start_address text,
    end_latitude numeric(10,8),
    end_longitude numeric(11,8),
    end_address text,
    total_distance_km numeric(10,2),
    total_duration_minutes integer,
    average_speed_kmh numeric(5,2),
    max_speed_kmh numeric(5,2),
    status text DEFAULT 'active'::text,
    started_at timestamp with time zone DEFAULT now(),
    completed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.gps_tracking_sessions OWNER TO postgres;

--
-- Name: inspection_damages; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.inspection_damages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    inspection_id uuid NOT NULL,
    damage_type text NOT NULL,
    severity text DEFAULT 'minor'::text NOT NULL,
    location text,
    description text,
    photo_url text,
    detected_by text,
    confidence numeric(3,2),
    repaired boolean DEFAULT false,
    repair_cost numeric(10,2),
    repair_date timestamp with time zone,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.inspection_damages OWNER TO postgres;

--
-- Name: TABLE inspection_damages; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.inspection_damages IS 'Dommages d√©tect√©s lors des inspections v√©hicules';


--
-- Name: COLUMN inspection_damages.damage_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspection_damages.damage_type IS 'Type de dommage: scratch, dent, crack, missing_part, etc.';


--
-- Name: COLUMN inspection_damages.severity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspection_damages.severity IS 'Gravit√©: minor, moderate, severe';


--
-- Name: COLUMN inspection_damages.confidence; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspection_damages.confidence IS 'Score de confiance AI (0.00 √† 1.00) si d√©tect√© automatiquement';


--
-- Name: inspection_documents; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.inspection_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    inspection_id uuid,
    document_type text NOT NULL,
    document_title text DEFAULT 'Document'::text,
    document_url text NOT NULL,
    pages_count integer DEFAULT 1,
    file_size_kb integer,
    scanned_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    user_id uuid,
    extracted_text text,
    uploaded_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.inspection_documents OWNER TO postgres;

--
-- Name: TABLE inspection_documents; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.inspection_documents IS 'Documents scann√©s lors des inspections (PV livraison, rapports dommages, etc.)';


--
-- Name: COLUMN inspection_documents.document_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspection_documents.document_type IS 'Type: delivery_receipt (PV livraison), damage_report (constat dommages), other (autre)';


--
-- Name: COLUMN inspection_documents.document_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspection_documents.document_url IS 'URL publique du document stock√© dans Supabase Storage';


--
-- Name: COLUMN inspection_documents.extracted_text; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspection_documents.extracted_text IS 'Texte extrait par OCR (Google ML Kit)';


--
-- Name: inspection_expenses; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.inspection_expenses (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    inspection_id uuid NOT NULL,
    expense_type text NOT NULL,
    amount numeric(10,2) NOT NULL,
    description text,
    receipt_url text,
    receipt_pages_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT inspection_expenses_amount_check CHECK ((amount >= (0)::numeric)),
    CONSTRAINT inspection_expenses_expense_type_check CHECK ((expense_type = ANY (ARRAY['carburant'::text, 'peage'::text, 'transport'::text, 'imprevu'::text])))
);


ALTER TABLE public.inspection_expenses OWNER TO postgres;

--
-- Name: TABLE inspection_expenses; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.inspection_expenses IS 'Frais engag√©s pendant la mission (carburant, p√©ages, etc.)';


--
-- Name: COLUMN inspection_expenses.expense_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspection_expenses.expense_type IS 'Type de frais: carburant, peage, transport, imprevu';


--
-- Name: COLUMN inspection_expenses.amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspection_expenses.amount IS 'Montant en euros (ex: 45.50)';


--
-- Name: COLUMN inspection_expenses.receipt_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspection_expenses.receipt_url IS 'URL du justificatif scann√© (ticket, facture)';


--
-- Name: inspection_pdfs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.inspection_pdfs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    inspection_id uuid NOT NULL,
    pdf_url text NOT NULL,
    file_size_bytes bigint,
    page_count integer DEFAULT 1,
    version integer DEFAULT 1,
    generated_at timestamp with time zone DEFAULT now(),
    last_downloaded_at timestamp with time zone,
    mission_id uuid
);


ALTER TABLE public.inspection_pdfs OWNER TO postgres;

--
-- Name: TABLE inspection_pdfs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.inspection_pdfs IS 'Cache des PDFs g√©n√©r√©s server-side pour √©viter reg√©n√©ration';


--
-- Name: inspection_photos_v2; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.inspection_photos_v2 (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    inspection_id uuid NOT NULL,
    photo_type text NOT NULL,
    thumbnail_url text,
    full_url text NOT NULL,
    file_size_bytes bigint,
    width integer,
    height integer,
    mime_type text DEFAULT 'image/webp'::text,
    latitude numeric(10,8),
    longitude numeric(11,8),
    taken_at timestamp with time zone DEFAULT now(),
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.inspection_photos_v2 OWNER TO postgres;

--
-- Name: TABLE inspection_photos_v2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.inspection_photos_v2 IS 'Version 2: Photos optimis√©es avec thumbnails et m√©tadonn√©es compl√®tes';


--
-- Name: COLUMN inspection_photos_v2.thumbnail_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspection_photos_v2.thumbnail_url IS 'URL thumbnail 400px WebP pour affichage rapide';


--
-- Name: COLUMN inspection_photos_v2.full_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspection_photos_v2.full_url IS 'URL photo compl√®te 1920px WebP pour zoom';


--
-- Name: inspection_photos; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.inspection_photos AS
 SELECT id,
    inspection_id,
    photo_type,
    full_url AS photo_url,
    latitude,
    longitude,
    taken_at,
    created_at
   FROM public.inspection_photos_v2;


ALTER VIEW public.inspection_photos OWNER TO postgres;

--
-- Name: VIEW inspection_photos; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.inspection_photos IS 'Vue de compatibilit√© pendant migration. Pointe vers inspection_photos_v2';


--
-- Name: inspection_report_shares; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.inspection_report_shares (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    mission_id uuid NOT NULL,
    user_id uuid NOT NULL,
    share_token text NOT NULL,
    report_type text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone,
    access_count integer DEFAULT 0,
    last_accessed_at timestamp with time zone,
    is_active boolean DEFAULT true,
    CONSTRAINT inspection_report_shares_report_type_check CHECK ((report_type = ANY (ARRAY['departure'::text, 'arrival'::text, 'complete'::text, 'both'::text, 'restitution_departure'::text, 'restitution_arrival'::text, 'restitution_complete'::text])))
);


ALTER TABLE public.inspection_report_shares OWNER TO postgres;

--
-- Name: inspections; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.inspections (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    mission_id uuid NOT NULL,
    user_id uuid NOT NULL,
    inspection_type text NOT NULL,
    overall_condition text,
    mileage integer,
    fuel_level integer,
    has_damages boolean DEFAULT false,
    damage_description text,
    photos jsonb DEFAULT '[]'::jsonb,
    signature_url text,
    pdf_url text,
    pdf_generated_at timestamp with time zone,
    notes text,
    latitude numeric(10,8),
    longitude numeric(11,8),
    created_at timestamp with time zone DEFAULT now(),
    completed_at timestamp with time zone,
    status text DEFAULT 'draft'::text,
    locked_at timestamp with time zone,
    driver_signature text,
    client_signature text,
    driver_signed_at timestamp with time zone,
    client_signed_at timestamp with time zone,
    use_ai boolean DEFAULT true,
    CONSTRAINT inspections_fuel_level_check CHECK (((fuel_level >= 0) AND (fuel_level <= 100))),
    CONSTRAINT inspections_inspection_type_check CHECK ((inspection_type = ANY (ARRAY['pickup'::text, 'delivery'::text]))),
    CONSTRAINT inspections_status_check CHECK ((status = ANY (ARRAY['draft'::text, 'locked'::text])))
);


ALTER TABLE public.inspections OWNER TO postgres;

--
-- Name: COLUMN inspections.use_ai; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.inspections.use_ai IS 'Indique si l''assistant IA Gemini est activ√© pour cette inspection. TRUE = descriptions IA g√©n√©r√©es, FALSE = mode manuel/hors ligne';


--
-- Name: invoice_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_items (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    invoice_id uuid NOT NULL,
    description text NOT NULL,
    quantity numeric(10,2) DEFAULT 1,
    unit_price numeric(10,2) NOT NULL,
    tax_rate numeric(5,2) DEFAULT 20,
    amount numeric(10,2) NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    sort_order integer DEFAULT 0
);


ALTER TABLE public.invoice_items OWNER TO postgres;

--
-- Name: mission_assignments; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mission_assignments (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    mission_id uuid NOT NULL,
    contact_id uuid,
    user_id uuid NOT NULL,
    assigned_by uuid,
    payment_ht numeric(10,2) DEFAULT 0.00,
    commission numeric(10,2) DEFAULT 0.00,
    notes text,
    status text DEFAULT 'assigned'::text NOT NULL,
    assigned_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT mission_assignments_status_check CHECK ((status = ANY (ARRAY['assigned'::text, 'in_progress'::text, 'completed'::text, 'cancelled'::text])))
);


ALTER TABLE public.mission_assignments OWNER TO postgres;

--
-- Name: TABLE mission_assignments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.mission_assignments IS 'Assignations de missions aux contacts de l''√©quipe';


--
-- Name: COLUMN mission_assignments.payment_ht; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mission_assignments.payment_ht IS 'Montant HT pay√© au contact pour cette mission';


--
-- Name: COLUMN mission_assignments.commission; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mission_assignments.commission IS 'Commission pr√©lev√©e sur la mission';


--
-- Name: COLUMN mission_assignments.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mission_assignments.status IS 'Statut de l''assignation';


--
-- Name: mission_locations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mission_locations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    mission_id uuid NOT NULL,
    latitude numeric(10,8) NOT NULL,
    longitude numeric(11,8) NOT NULL,
    accuracy numeric(10,2),
    altitude numeric(10,2),
    speed numeric(10,2),
    heading numeric(10,2),
    recorded_at timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE public.mission_locations OWNER TO postgres;

--
-- Name: TABLE mission_locations; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.mission_locations IS 'Historique des positions GPS pendant les missions pour tracking en temps r√©el';


--
-- Name: COLUMN mission_locations.mission_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mission_locations.mission_id IS 'ID de la mission track√©e';


--
-- Name: COLUMN mission_locations.latitude; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mission_locations.latitude IS 'Latitude de la position';


--
-- Name: COLUMN mission_locations.longitude; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mission_locations.longitude IS 'Longitude de la position';


--
-- Name: COLUMN mission_locations.accuracy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mission_locations.accuracy IS 'Pr√©cision de la position en m√®tres';


--
-- Name: COLUMN mission_locations.recorded_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mission_locations.recorded_at IS 'Date/heure d''enregistrement de la position';


--
-- Name: mission_revenue_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mission_revenue_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    mission_id uuid NOT NULL,
    user_id uuid NOT NULL,
    mission_reference text NOT NULL,
    revenue_type text NOT NULL,
    amount numeric DEFAULT 0 NOT NULL,
    description text,
    month_key text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT mission_revenue_logs_revenue_type_check CHECK ((revenue_type = ANY (ARRAY['received_mission'::text, 'assigned_commission'::text])))
);


ALTER TABLE public.mission_revenue_logs OWNER TO postgres;

--
-- Name: TABLE mission_revenue_logs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.mission_revenue_logs IS 'Historique des revenus g√©n√©r√©s par les missions';


--
-- Name: COLUMN mission_revenue_logs.revenue_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mission_revenue_logs.revenue_type IS 'received_mission: revenu mission re√ßue, assigned_commission: commission mission assign√©e';


--
-- Name: COLUMN mission_revenue_logs.amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mission_revenue_logs.amount IS 'Montant du revenu en euros HT';


--
-- Name: mission_tracking_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mission_tracking_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    mission_id uuid NOT NULL,
    user_id uuid NOT NULL,
    latitude double precision NOT NULL,
    longitude double precision NOT NULL,
    accuracy double precision,
    speed double precision,
    bearing double precision,
    altitude double precision,
    recorded_at timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.mission_tracking_history OWNER TO postgres;

--
-- Name: TABLE mission_tracking_history; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.mission_tracking_history IS 'Historique GPS - Snapshots toutes les 5 minutes - Nettoyage auto apr√®s 7 jours';


--
-- Name: missions_with_active_tracking; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.missions_with_active_tracking AS
 SELECT m.id,
    m.reference,
    m.status,
    m.pickup_address,
    m.delivery_address,
    mtl.latitude,
    mtl.longitude,
    mtl.speed,
    mtl.bearing,
    mtl.last_update,
    mtl.battery_level,
    EXTRACT(epoch FROM (now() - mtl.last_update)) AS seconds_since_update,
        CASE
            WHEN (EXTRACT(epoch FROM (now() - mtl.last_update)) < (300)::numeric) THEN 'live'::text
            WHEN (EXTRACT(epoch FROM (now() - mtl.last_update)) < (600)::numeric) THEN 'delayed'::text
            ELSE 'inactive'::text
        END AS tracking_status
   FROM (public.missions m
     JOIN public.mission_tracking_live mtl ON ((m.id = mtl.mission_id)))
  WHERE (mtl.is_active = true)
  ORDER BY mtl.last_update DESC;


ALTER VIEW public.missions_with_active_tracking OWNER TO postgres;

--
-- Name: VIEW missions_with_active_tracking; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.missions_with_active_tracking IS 'Vue des missions avec tracking GPS actif - Statut live/delayed/inactive';


--
-- Name: navigation_sessions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.navigation_sessions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    mission_id uuid NOT NULL,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    ended_at timestamp with time zone,
    status text DEFAULT 'active'::text,
    distance_meters numeric,
    estimated_duration_seconds integer,
    distance_remaining_meters numeric,
    duration_remaining_seconds integer,
    percent_complete numeric DEFAULT 0,
    last_update timestamp with time zone,
    from_cache boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT navigation_sessions_status_check CHECK ((status = ANY (ARRAY['active'::text, 'completed'::text, 'cancelled'::text])))
);


ALTER TABLE public.navigation_sessions OWNER TO postgres;

--
-- Name: TABLE navigation_sessions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.navigation_sessions IS 'Sessions de navigation GPS Mapbox avec monitoring quota';


--
-- Name: COLUMN navigation_sessions.from_cache; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.navigation_sessions.from_cache IS 'True si route r√©cup√©r√©e du cache (√©conomie API)';


--
-- Name: navigation_alerts; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.navigation_alerts AS
 SELECT ns.id,
    ns.mission_id,
    m.reference AS mission_reference,
    ns.status,
    ns.started_at,
    ns.ended_at,
    (EXTRACT(epoch FROM (COALESCE(ns.ended_at, now()) - ns.started_at)) / (60)::numeric) AS duree_minutes,
    (ns.distance_meters / (1000)::numeric) AS distance_km,
    ns.percent_complete,
        CASE
            WHEN ((ns.status = 'active'::text) AND (ns.started_at < (now() - '02:00:00'::interval))) THEN '‚ö†Ô∏è Session active > 2h'::text
            WHEN (ns.status = 'cancelled'::text) THEN '‚ùå Navigation annul√©e'::text
            WHEN ((ns.status = 'completed'::text) AND (ns.percent_complete < (80)::numeric)) THEN '‚ö†Ô∏è Compl√©t√©e mais < 80%'::text
            ELSE '‚úÖ OK'::text
        END AS alerte,
    ns.from_cache
   FROM (public.navigation_sessions ns
     JOIN public.missions m ON ((m.id = ns.mission_id)))
  WHERE ((ns.created_at >= (now() - '7 days'::interval)) AND (((ns.status = 'active'::text) AND (ns.started_at < (now() - '02:00:00'::interval))) OR (ns.status = 'cancelled'::text) OR ((ns.status = 'completed'::text) AND (ns.percent_complete < (80)::numeric))))
  ORDER BY ns.started_at DESC;


ALTER VIEW public.navigation_alerts OWNER TO postgres;

--
-- Name: VIEW navigation_alerts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.navigation_alerts IS 'Sessions n√©cessitant attention - 7 derniers jours';


--
-- Name: navigation_current_month_dashboard; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.navigation_current_month_dashboard AS
 SELECT count(*) AS total_sessions,
    count(*) FILTER (WHERE (status = 'active'::text)) AS sessions_actives,
    count(*) FILTER (WHERE (status = 'completed'::text)) AS sessions_completees,
    count(*) FILTER (WHERE (status = 'cancelled'::text)) AS sessions_annulees,
    count(*) FILTER (WHERE (from_cache = true)) AS sessions_cache,
    count(*) FILTER (WHERE (from_cache = false)) AS sessions_api,
    round((((count(*) FILTER (WHERE (from_cache = true)))::numeric / (NULLIF(count(*), 0))::numeric) * (100)::numeric), 1) AS cache_hit_rate_percent,
    round((sum(distance_meters) / (1000)::numeric), 1) AS distance_totale_km,
    round((avg(distance_meters) / (1000)::numeric), 1) AS distance_moyenne_km,
    round((min(distance_meters) / (1000)::numeric), 1) AS distance_min_km,
    round((max(distance_meters) / (1000)::numeric), 1) AS distance_max_km,
    round(((sum(estimated_duration_seconds) / 3600))::numeric, 1) AS duree_totale_heures,
    round((avg(estimated_duration_seconds) / (60)::numeric), 1) AS duree_moyenne_minutes,
    count(*) FILTER (WHERE (from_cache = false)) AS mapbox_quota_utilise,
    (25000 - count(*) FILTER (WHERE (from_cache = false))) AS mapbox_quota_restant,
    round((((count(*) FILTER (WHERE (from_cache = false)))::numeric / (25000)::numeric) * (100)::numeric), 2) AS mapbox_quota_percent,
        CASE
            WHEN (count(*) FILTER (WHERE (from_cache = false)) > 25000) THEN round((((count(*) FILTER (WHERE (from_cache = false)) - 25000))::numeric * 0.50), 2)
            ELSE (0)::numeric
        END AS cout_additionnel_usd,
        CASE
            WHEN (count(*) FILTER (WHERE (from_cache = false)) >= 25000) THEN 'üö® CRITIQUE - Quota d√©pass√©'::text
            WHEN (count(*) FILTER (WHERE (from_cache = false)) >= 24000) THEN '‚ö†Ô∏è ALERTE - 96% utilis√©'::text
            WHEN (count(*) FILTER (WHERE (from_cache = false)) >= 20000) THEN '‚ö†Ô∏è WARNING - 80% utilis√©'::text
            WHEN (count(*) FILTER (WHERE (from_cache = false)) >= 15000) THEN '‚úÖ OK - 60% utilis√©'::text
            ELSE '‚úÖ OK - Sous 60%'::text
        END AS statut_quota,
    (date_trunc('month'::text, now()))::date AS mois,
    (now())::date AS derniere_mise_a_jour
   FROM public.navigation_sessions
  WHERE (created_at >= date_trunc('month'::text, now()));


ALTER VIEW public.navigation_current_month_dashboard OWNER TO postgres;

--
-- Name: VIEW navigation_current_month_dashboard; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.navigation_current_month_dashboard IS 'Dashboard temps r√©el - Quota et m√©triques du mois en cours';


--
-- Name: navigation_daily_stats; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.navigation_daily_stats AS
 SELECT date(created_at) AS jour,
    date_part('dow'::text, created_at) AS jour_semaine,
    count(*) AS total_sessions,
    count(*) FILTER (WHERE (from_cache = true)) AS sessions_cache,
    count(*) FILTER (WHERE (from_cache = false)) AS sessions_api,
    round((((count(*) FILTER (WHERE (from_cache = true)))::numeric / (NULLIF(count(*), 0))::numeric) * (100)::numeric), 1) AS cache_hit_rate,
    count(*) FILTER (WHERE (status = 'completed'::text)) AS completees,
    count(*) FILTER (WHERE (status = 'cancelled'::text)) AS annulees,
    round((avg(distance_meters) / (1000)::numeric), 1) AS distance_moyenne_km,
    round((avg(estimated_duration_seconds) / (60)::numeric), 1) AS duree_moyenne_min,
    round((sum(distance_meters) / (1000)::numeric), 1) AS distance_totale_km
   FROM public.navigation_sessions
  WHERE (created_at >= (now() - '30 days'::interval))
  GROUP BY (date(created_at)), (date_part('dow'::text, created_at))
  ORDER BY (date(created_at)) DESC;


ALTER VIEW public.navigation_daily_stats OWNER TO postgres;

--
-- Name: VIEW navigation_daily_stats; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.navigation_daily_stats IS 'Statistiques journali√®res - 30 derniers jours';


--
-- Name: navigation_hourly_patterns; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.navigation_hourly_patterns AS
 SELECT (date_part('hour'::text, created_at))::integer AS heure,
    count(*) AS total_sessions,
    count(*) FILTER (WHERE (from_cache = false)) AS sessions_api,
    round((avg(distance_meters) / (1000)::numeric), 1) AS distance_moyenne_km,
    count(DISTINCT date(created_at)) AS jours_concernes
   FROM public.navigation_sessions
  WHERE (created_at >= (now() - '30 days'::interval))
  GROUP BY (date_part('hour'::text, created_at))
  ORDER BY ((date_part('hour'::text, created_at))::integer);


ALTER VIEW public.navigation_hourly_patterns OWNER TO postgres;

--
-- Name: VIEW navigation_hourly_patterns; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.navigation_hourly_patterns IS 'Patterns d''utilisation par heure - 30 derniers jours';


--
-- Name: navigation_mission_stats; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.navigation_mission_stats AS
 SELECT m.id AS mission_id,
    m.reference,
    m.status AS mission_status,
    count(ns.id) AS navigation_attempts,
    max(ns.created_at) AS last_navigation_at,
    sum(
        CASE
            WHEN (ns.status = 'completed'::text) THEN 1
            ELSE 0
        END) AS completed_navigations,
    avg(ns.distance_meters) AS avg_distance_meters,
    avg(ns.estimated_duration_seconds) AS avg_duration_seconds
   FROM (public.missions m
     LEFT JOIN public.navigation_sessions ns ON ((ns.mission_id = m.id)))
  GROUP BY m.id, m.reference, m.status;


ALTER VIEW public.navigation_mission_stats OWNER TO postgres;

--
-- Name: navigation_monthly_stats; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.navigation_monthly_stats AS
 SELECT date_trunc('month'::text, created_at) AS month,
    count(*) AS total_sessions,
    count(*) FILTER (WHERE (status = 'active'::text)) AS active_sessions,
    count(*) FILTER (WHERE (status = 'completed'::text)) AS completed_sessions,
    count(*) FILTER (WHERE (status = 'cancelled'::text)) AS cancelled_sessions,
    count(*) FILTER (WHERE (from_cache = true)) AS cached_sessions,
    count(*) FILTER (WHERE (from_cache = false)) AS api_sessions,
    sum(distance_meters) AS total_distance_meters,
    avg(distance_meters) AS avg_distance_meters,
    sum(estimated_duration_seconds) AS total_duration_seconds,
    avg(estimated_duration_seconds) AS avg_duration_seconds,
    count(*) FILTER (WHERE (from_cache = false)) AS mapbox_sessions_used,
    (25000 - count(*) FILTER (WHERE (from_cache = false))) AS mapbox_quota_remaining,
    round((((count(*) FILTER (WHERE (from_cache = false)))::numeric / (25000)::numeric) * (100)::numeric), 2) AS mapbox_quota_percent_used,
        CASE
            WHEN (count(*) FILTER (WHERE (from_cache = false)) > 25000) THEN (((count(*) FILTER (WHERE (from_cache = false)) - 25000))::numeric * 0.50)
            ELSE (0)::numeric
        END AS mapbox_overage_cost_usd
   FROM public.navigation_sessions
  GROUP BY (date_trunc('month'::text, created_at))
  ORDER BY (date_trunc('month'::text, created_at)) DESC;


ALTER VIEW public.navigation_monthly_stats OWNER TO postgres;

--
-- Name: VIEW navigation_monthly_stats; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.navigation_monthly_stats IS 'Statistiques mensuelles avec monitoring quota Mapbox (25k free tier)';


--
-- Name: navigation_top_missions; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.navigation_top_missions AS
 SELECT m.id,
    m.reference,
    m.status,
    m.pickup_address,
    m.delivery_address,
    count(ns.id) AS total_navigations,
    count(*) FILTER (WHERE (ns.status = 'completed'::text)) AS navigations_completees,
    count(*) FILTER (WHERE (ns.from_cache = true)) AS navigations_cache,
    round((avg(ns.distance_meters) / (1000)::numeric), 1) AS distance_moyenne_km,
    round((avg(ns.estimated_duration_seconds) / (60)::numeric), 1) AS duree_moyenne_min,
    max(ns.created_at) AS derniere_navigation,
    round((((count(*) FILTER (WHERE (ns.status = 'completed'::text)))::numeric / (NULLIF(count(ns.id), 0))::numeric) * (100)::numeric), 1) AS taux_completion
   FROM (public.missions m
     JOIN public.navigation_sessions ns ON ((ns.mission_id = m.id)))
  WHERE (ns.created_at >= (now() - '30 days'::interval))
  GROUP BY m.id, m.reference, m.status, m.pickup_address, m.delivery_address
 HAVING (count(ns.id) > 0)
  ORDER BY (count(ns.id)) DESC
 LIMIT 20;


ALTER VIEW public.navigation_top_missions OWNER TO postgres;

--
-- Name: VIEW navigation_top_missions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.navigation_top_missions IS 'Top 20 missions les plus navigu√©es - 30 derniers jours';


--
-- Name: notifications; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.notifications (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    title text NOT NULL,
    message text NOT NULL,
    notification_type text NOT NULL,
    is_read boolean DEFAULT false,
    action_url text,
    reference_id uuid,
    reference_type text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT notifications_notification_type_check CHECK ((notification_type = ANY (ARRAY['mission'::text, 'covoiturage'::text, 'invoice'::text, 'system'::text, 'other'::text])))
);


ALTER TABLE public.notifications OWNER TO postgres;

--
-- Name: pending_contact_requests; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.pending_contact_requests AS
 SELECT cr.id,
    cr.requester_id,
    cr.target_email,
    cr.target_name,
    cr.status,
    cr.message,
    cr.created_at,
    cr.updated_at,
    cr.accepted_at,
    p.email AS requester_email,
    p.first_name AS requester_first_name,
    p.last_name AS requester_last_name
   FROM (public.contact_requests cr
     JOIN public.profiles p ON ((cr.requester_id = p.id)))
  WHERE (cr.status = 'pending'::text)
  ORDER BY cr.created_at DESC;


ALTER VIEW public.pending_contact_requests OWNER TO postgres;

--
-- Name: phone_verifications; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.phone_verifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    phone text NOT NULL,
    code text NOT NULL,
    verified boolean DEFAULT false,
    attempts integer DEFAULT 0,
    expires_at timestamp with time zone NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.phone_verifications OWNER TO postgres;

--
-- Name: planning_matches; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.planning_matches (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    planning_a_id uuid NOT NULL,
    planning_b_id uuid NOT NULL,
    user_a_id uuid NOT NULL,
    user_b_id uuid NOT NULL,
    match_score integer DEFAULT 0 NOT NULL,
    match_type text NOT NULL,
    distance_km double precision,
    time_overlap_minutes integer,
    potential_km_saved double precision,
    status text DEFAULT 'pending'::text NOT NULL,
    notified_a boolean DEFAULT false,
    notified_b boolean DEFAULT false,
    match_details jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT planning_matches_match_type_check CHECK ((match_type = ANY (ARRAY['same_route'::text, 'return_opportunity'::text, 'nearby_route'::text, 'time_overlap'::text]))),
    CONSTRAINT planning_matches_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'declined'::text, 'expired'::text])))
);


ALTER TABLE public.planning_matches OWNER TO postgres;

--
-- Name: TABLE planning_matches; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.planning_matches IS 'Matchs IA entre plannings compatibles';


--
-- Name: planning_messages; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.planning_messages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    match_id uuid NOT NULL,
    sender_id uuid NOT NULL,
    content text NOT NULL,
    is_read boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.planning_messages OWNER TO postgres;

--
-- Name: TABLE planning_messages; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.planning_messages IS 'Messages de chat entre convoyeurs match√©s - uniquement pour les matchs accept√©s';


--
-- Name: planning_notifications; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.planning_notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    type text NOT NULL,
    title text NOT NULL,
    body text NOT NULL,
    data jsonb DEFAULT '{}'::jsonb,
    is_read boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT planning_notifications_type_check CHECK ((type = ANY (ARRAY['new_match'::text, 'match_accepted'::text, 'match_declined'::text, 'new_message'::text, 'planning_expired'::text])))
);


ALTER TABLE public.planning_notifications OWNER TO postgres;

--
-- Name: TABLE planning_notifications; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.planning_notifications IS 'Notifications push pour le r√©seau planning (matchs, messages, expirations)';


--
-- Name: planning_stats; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.planning_stats (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    month integer NOT NULL,
    year integer NOT NULL,
    plannings_published integer DEFAULT 0,
    matches_found integer DEFAULT 0,
    matches_accepted integer DEFAULT 0,
    km_saved double precision DEFAULT 0,
    hours_saved double precision DEFAULT 0,
    empty_trips_avoided integer DEFAULT 0,
    co2_saved_kg double precision DEFAULT 0,
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.planning_stats OWNER TO postgres;

--
-- Name: TABLE planning_stats; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.planning_stats IS 'Statistiques mensuelles d optimisation par utilisateur';


--
-- Name: planning_waypoints; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.planning_waypoints (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    planning_id uuid NOT NULL,
    city text NOT NULL,
    postal_code text,
    lat double precision,
    lng double precision,
    arrival_time time without time zone,
    sort_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    estimated_arrival timestamp with time zone,
    eta_minutes integer
);


ALTER TABLE public.planning_waypoints OWNER TO postgres;

--
-- Name: TABLE planning_waypoints; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.planning_waypoints IS 'Points de passage interm√©diaires des plannings';


--
-- Name: pricing_grids; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.pricing_grids (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    client_id uuid,
    is_global boolean DEFAULT false,
    name character varying(255) NOT NULL,
    tier_1_50_light numeric(10,2) DEFAULT 0,
    tier_51_100_light numeric(10,2) DEFAULT 0,
    tier_101_150_light numeric(10,2) DEFAULT 0,
    tier_151_300_light numeric(10,2) DEFAULT 0,
    rate_per_km_light numeric(10,2) DEFAULT 0,
    tier_1_50_utility numeric(10,2) DEFAULT 0,
    tier_51_100_utility numeric(10,2) DEFAULT 0,
    tier_101_150_utility numeric(10,2) DEFAULT 0,
    tier_151_300_utility numeric(10,2) DEFAULT 0,
    rate_per_km_utility numeric(10,2) DEFAULT 0,
    tier_1_50_heavy numeric(10,2) DEFAULT 0,
    tier_51_100_heavy numeric(10,2) DEFAULT 0,
    tier_101_150_heavy numeric(10,2) DEFAULT 0,
    tier_151_300_heavy numeric(10,2) DEFAULT 0,
    rate_per_km_heavy numeric(10,2) DEFAULT 0,
    margin_percentage numeric(5,2) DEFAULT 0,
    fixed_supplement numeric(10,2) DEFAULT 0,
    supplement_notes text,
    vat_rate numeric(5,2) DEFAULT 20.00,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.pricing_grids OWNER TO postgres;

--
-- Name: TABLE pricing_grids; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.pricing_grids IS 'Grilles tarifaires personnalis√©es par client pour calcul automatique de devis';


--
-- Name: COLUMN pricing_grids.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.pricing_grids.client_id IS 'NULL pour grille globale, ID client pour grille sp√©cifique';


--
-- Name: COLUMN pricing_grids.is_global; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.pricing_grids.is_global IS 'True si grille par d√©faut pour tous les clients du user';


--
-- Name: COLUMN pricing_grids.margin_percentage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.pricing_grids.margin_percentage IS 'Marge en pourcentage √† appliquer sur le prix de base';


--
-- Name: COLUMN pricing_grids.fixed_supplement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.pricing_grids.fixed_supplement IS 'Suppl√©ment fixe en euros (p√©ages, urgence, etc.)';


--
-- Name: COLUMN pricing_grids.vat_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.pricing_grids.vat_rate IS 'Taux de TVA en pourcentage (par d√©faut 20%)';


--
-- Name: public_inspection_reports; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.public_inspection_reports (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    share_token text DEFAULT SUBSTRING(md5(((random())::text || (clock_timestamp())::text)) FROM 1 FOR 12) NOT NULL,
    mission_id uuid NOT NULL,
    departure_inspection_id uuid,
    arrival_inspection_id uuid,
    created_by uuid,
    expires_at timestamp with time zone,
    view_count integer DEFAULT 0,
    last_viewed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.public_inspection_reports OWNER TO postgres;

--
-- Name: TABLE public_inspection_reports; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.public_inspection_reports IS 'Rapports d''inspection partag√©s publiquement via un lien unique. Permet aux clients de consulter les rapports sans authentification.';


--
-- Name: COLUMN public_inspection_reports.share_token; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.public_inspection_reports.share_token IS 'Token unique utilis√© dans l''URL publique (ex: https://xcrackz.com/rapport/ABC123XYZ)';


--
-- Name: COLUMN public_inspection_reports.expires_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.public_inspection_reports.expires_at IS 'Date d''expiration du lien (NULL = jamais expire)';


--
-- Name: public_tracking_links; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.public_tracking_links (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    mission_id uuid NOT NULL,
    token text DEFAULT replace(replace(replace(encode(extensions.gen_random_bytes(24), 'base64'::text), '+'::text, '-'::text), '/'::text, '_'::text), '='::text, ''::text) NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone NOT NULL,
    last_accessed_at timestamp with time zone,
    access_count integer DEFAULT 0,
    is_active boolean DEFAULT true,
    max_accesses integer DEFAULT 1000
);


ALTER TABLE public.public_tracking_links OWNER TO postgres;

--
-- Name: TABLE public_tracking_links; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.public_tracking_links IS 'Liens publics s√©curis√©s pour suivi client - Expiration auto 48h apr√®s mission';


--
-- Name: push_tokens; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.push_tokens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    token text NOT NULL,
    platform text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT push_tokens_platform_check CHECK ((platform = ANY (ARRAY['ios'::text, 'android'::text, 'web'::text])))
);


ALTER TABLE public.push_tokens OWNER TO postgres;

--
-- Name: quote_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.quote_items (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    quote_id uuid NOT NULL,
    description text NOT NULL,
    quantity numeric(10,2) DEFAULT 1,
    unit_price numeric(10,2) NOT NULL,
    tax_rate numeric(5,2) DEFAULT 20,
    amount numeric(10,2) NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.quote_items OWNER TO postgres;

--
-- Name: quotes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.quotes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    quote_number character varying(50) NOT NULL,
    user_id uuid NOT NULL,
    client_id uuid NOT NULL,
    pricing_grid_id uuid,
    quote_date date DEFAULT CURRENT_DATE NOT NULL,
    validity_days integer DEFAULT 30,
    valid_until date GENERATED ALWAYS AS ((quote_date + ((validity_days)::double precision * '1 day'::interval))) STORED,
    items jsonb DEFAULT '[]'::jsonb NOT NULL,
    total_ht numeric(10,2) DEFAULT 0 NOT NULL,
    total_ttc numeric(10,2) DEFAULT 0 NOT NULL,
    total_distance numeric(10,2) DEFAULT 0,
    additional_notes text,
    terms_and_conditions text,
    status character varying(20) DEFAULT 'draft'::character varying,
    sent_at timestamp with time zone,
    accepted_at timestamp with time zone,
    rejected_at timestamp with time zone,
    rejection_reason text,
    converted_to_mission_id uuid,
    converted_at timestamp with time zone,
    client_signature text,
    signed_at timestamp with time zone,
    pdf_url text,
    pdf_generated_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    client_siret text,
    client_vat_number text,
    client_legal_form text,
    client_activity_code text,
    client_phone text,
    mission_id uuid,
    terms text,
    converted_invoice_id uuid,
    CONSTRAINT quotes_status_check CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'sent'::character varying, 'accepted'::character varying, 'rejected'::character varying, 'expired'::character varying, 'converted'::character varying])::text[])))
);


ALTER TABLE public.quotes OWNER TO postgres;

--
-- Name: TABLE quotes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.quotes IS 'Devis avec calcul automatique de distance via OpenRouteService et tarification via pricing_grids';


--
-- Name: COLUMN quotes.quote_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.quote_number IS 'Num√©ro unique du devis (ex: DEV-202510-0001)';


--
-- Name: COLUMN quotes.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.client_id IS 'Reference to billing client';


--
-- Name: COLUMN quotes.valid_until; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.valid_until IS 'Date limite de validit√© calcul√©e automatiquement (quote_date + validity_days)';


--
-- Name: COLUMN quotes.items; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.items IS 'Trajets en JSON avec adresses, coordonn√©es GPS, distances, dur√©es et prix';


--
-- Name: COLUMN quotes.total_distance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.total_distance IS 'Distance totale calcul√©e automatiquement depuis items';


--
-- Name: COLUMN quotes.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.status IS 'draft: brouillon, sent: envoy√© au client, accepted: accept√©, rejected: refus√©, expired: expir√©, converted: converti en mission';


--
-- Name: COLUMN quotes.sent_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.sent_at IS 'When quote was sent to client';


--
-- Name: COLUMN quotes.accepted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.accepted_at IS 'When quote was accepted by client';


--
-- Name: COLUMN quotes.rejected_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.rejected_at IS 'When quote was rejected by client';


--
-- Name: COLUMN quotes.converted_to_mission_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.converted_to_mission_id IS 'ID de la mission cr√©√©e depuis ce devis (si accept√©)';


--
-- Name: COLUMN quotes.converted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.converted_at IS 'When quote was converted to invoice';


--
-- Name: COLUMN quotes.client_signature; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.client_signature IS 'Image de signature du client en base64';


--
-- Name: COLUMN quotes.pdf_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.pdf_url IS 'URL du PDF g√©n√©r√© (stockage Supabase Storage)';


--
-- Name: COLUMN quotes.client_siret; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.client_siret IS 'Num√©ro SIRET du client (14 chiffres)';


--
-- Name: COLUMN quotes.client_vat_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.client_vat_number IS 'Num√©ro de TVA intracommunautaire (FRxx xxxxxxxxx)';


--
-- Name: COLUMN quotes.client_legal_form; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.client_legal_form IS 'Forme juridique (SARL, SAS, etc.)';


--
-- Name: COLUMN quotes.client_activity_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.client_activity_code IS 'Code NAF/APE';


--
-- Name: COLUMN quotes.client_phone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.client_phone IS 'Client phone number';


--
-- Name: COLUMN quotes.mission_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.mission_id IS 'Optional link to associated mission';


--
-- Name: COLUMN quotes.terms; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.terms IS 'Quote terms and conditions';


--
-- Name: COLUMN quotes.converted_invoice_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.quotes.converted_invoice_id IS 'ID of invoice created from this quote';


--
-- Name: quote_statistics; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.quote_statistics AS
 SELECT user_id,
    count(*) AS total_quotes,
    count(*) FILTER (WHERE ((status)::text = 'draft'::text)) AS draft_count,
    count(*) FILTER (WHERE ((status)::text = 'sent'::text)) AS sent_count,
    count(*) FILTER (WHERE ((status)::text = 'accepted'::text)) AS accepted_count,
    count(*) FILTER (WHERE ((status)::text = 'rejected'::text)) AS rejected_count,
    count(*) FILTER (WHERE ((status)::text = 'expired'::text)) AS expired_count,
    count(*) FILTER (WHERE ((status)::text = 'converted'::text)) AS converted_count,
    sum(total_ht) FILTER (WHERE ((status)::text = 'accepted'::text)) AS total_revenue_ht,
    sum(total_ttc) FILTER (WHERE ((status)::text = 'accepted'::text)) AS total_revenue_ttc,
    sum(total_distance) FILTER (WHERE ((status)::text = 'accepted'::text)) AS total_distance_km,
    round((((count(*) FILTER (WHERE ((status)::text = 'accepted'::text)))::numeric / NULLIF((count(*) FILTER (WHERE ((status)::text = ANY ((ARRAY['sent'::character varying, 'accepted'::character varying, 'rejected'::character varying])::text[]))))::numeric, (0)::numeric)) * (100)::numeric), 2) AS acceptance_rate_percentage,
    avg(total_ht) FILTER (WHERE ((status)::text = 'accepted'::text)) AS avg_quote_value_ht
   FROM public.quotes
  GROUP BY user_id;


ALTER VIEW public.quote_statistics OWNER TO postgres;

--
-- Name: VIEW quote_statistics; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.quote_statistics IS 'Statistiques des devis par utilisateur: taux d''acceptation, CA g√©n√©r√©, distance totale';


--
-- Name: ride_matches; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ride_matches (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    offer_id uuid NOT NULL,
    request_id uuid NOT NULL,
    driver_id uuid NOT NULL,
    passenger_id uuid NOT NULL,
    pickup_city text,
    pickup_lat double precision,
    pickup_lng double precision,
    dropoff_city text,
    dropoff_lat double precision,
    dropoff_lng double precision,
    detour_km double precision,
    distance_covered_km double precision,
    match_score integer DEFAULT 0,
    match_type text DEFAULT 'on_route'::text,
    status text DEFAULT 'proposed'::text NOT NULL,
    rendezvous_time timestamp with time zone,
    rendezvous_address text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT ride_matches_match_type_check CHECK ((match_type = ANY (ARRAY['on_route'::text, 'small_detour'::text, 'partial'::text, 'return_match'::text]))),
    CONSTRAINT ride_matches_status_check CHECK ((status = ANY (ARRAY['proposed'::text, 'accepted'::text, 'in_transit'::text, 'completed'::text, 'declined'::text, 'cancelled'::text, 'expired'::text])))
);


ALTER TABLE public.ride_matches OWNER TO postgres;

--
-- Name: TABLE ride_matches; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ride_matches IS 'Matchs entre offres de place et demandes de trajet ‚Äî scoring route-based';


--
-- Name: ride_messages; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ride_messages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    match_id uuid NOT NULL,
    sender_id uuid NOT NULL,
    content text NOT NULL,
    is_read boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.ride_messages OWNER TO postgres;

--
-- Name: TABLE ride_messages; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ride_messages IS 'Chat entre conducteur et passager match√©s';


--
-- Name: ride_ratings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ride_ratings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    match_id uuid NOT NULL,
    rater_id uuid NOT NULL,
    rated_id uuid NOT NULL,
    rating integer NOT NULL,
    comment text,
    badges jsonb DEFAULT '[]'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT ride_ratings_rating_check CHECK (((rating >= 1) AND (rating <= 5)))
);


ALTER TABLE public.ride_ratings OWNER TO postgres;

--
-- Name: TABLE ride_ratings; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ride_ratings IS 'Notations mutuelles apr√®s chaque covoiturage ‚Äî 1 √† 5 √©toiles + badges';


--
-- Name: ride_requests; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ride_requests (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    completed_mission_id uuid,
    pickup_city text NOT NULL,
    pickup_postal_code text,
    pickup_lat double precision,
    pickup_lng double precision,
    destination_city text NOT NULL,
    destination_postal_code text,
    destination_lat double precision,
    destination_lng double precision,
    needed_date date NOT NULL,
    time_window_start time without time zone,
    time_window_end time without time zone,
    flexibility_minutes integer DEFAULT 60,
    max_detour_km double precision DEFAULT 20,
    accept_partial boolean DEFAULT true,
    request_type text DEFAULT 'return'::text,
    status text DEFAULT 'active'::text NOT NULL,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone,
    CONSTRAINT ride_requests_request_type_check CHECK ((request_type = ANY (ARRAY['return'::text, 'pickup_point'::text, 'custom'::text]))),
    CONSTRAINT ride_requests_status_check CHECK ((status = ANY (ARRAY['active'::text, 'matched'::text, 'completed'::text, 'cancelled'::text, 'expired'::text])))
);


ALTER TABLE public.ride_requests OWNER TO postgres;

--
-- Name: TABLE ride_requests; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ride_requests IS 'Demandes de trajet ‚Äî convoyeur √† pied qui cherche un lift vers sa base ou un point d''enl√®vement';


--
-- Name: shop_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.shop_items (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    name text NOT NULL,
    description text,
    item_type text NOT NULL,
    credits_amount integer DEFAULT 0,
    price numeric(10,2) NOT NULL,
    currency text DEFAULT 'EUR'::text,
    is_active boolean DEFAULT true,
    features jsonb DEFAULT '[]'::jsonb,
    display_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT shop_items_item_type_check CHECK ((item_type = ANY (ARRAY['credits'::text, 'subscription'::text, 'feature'::text])))
);


ALTER TABLE public.shop_items OWNER TO postgres;

--
-- Name: shop_quote_requests; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.shop_quote_requests (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    company_name text NOT NULL,
    email text NOT NULL,
    phone text NOT NULL,
    expected_volume text,
    message text NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    admin_notes text,
    responded_at timestamp with time zone,
    responded_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    package_id uuid,
    CONSTRAINT shop_quote_requests_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'contacted'::text, 'quoted'::text, 'closed'::text, 'rejected'::text])))
);


ALTER TABLE public.shop_quote_requests OWNER TO postgres;

--
-- Name: TABLE shop_quote_requests; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.shop_quote_requests IS 'Demandes de devis pour offres personnalis√©es depuis la boutique';


--
-- Name: COLUMN shop_quote_requests.expected_volume; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.shop_quote_requests.expected_volume IS 'Volume mensuel estim√© (texte libre)';


--
-- Name: COLUMN shop_quote_requests.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.shop_quote_requests.status IS 'pending: en attente, contacted: contact√©, quoted: devis envoy√©, closed: accept√©, rejected: refus√©';


--
-- Name: COLUMN shop_quote_requests.admin_notes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.shop_quote_requests.admin_notes IS 'Notes internes pour le suivi admin';


--
-- Name: COLUMN shop_quote_requests.responded_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.shop_quote_requests.responded_by IS 'ID de l''admin qui a r√©pondu';


--
-- Name: COLUMN shop_quote_requests.package_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.shop_quote_requests.package_id IS 'ID du package de cr√©dits demand√© (facultatif)';


--
-- Name: signup_attempts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.signup_attempts (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    email text NOT NULL,
    phone text,
    device_fingerprint text,
    ip_address text NOT NULL,
    user_agent text,
    step_reached integer DEFAULT 1,
    success boolean DEFAULT false,
    failure_reason text,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.signup_attempts OWNER TO postgres;

--
-- Name: TABLE signup_attempts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.signup_attempts IS 'Toutes les tentatives d''inscription (succ√®s et √©checs)';


--
-- Name: storage_stats; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.storage_stats AS
 SELECT user_id,
    count(*) AS total_files,
    sum(file_size) AS total_size,
    avg(file_size) AS avg_file_size,
    max(file_size) AS max_file_size,
    min(uploaded_at) AS first_upload,
    max(uploaded_at) AS last_upload
   FROM public.attachments
  GROUP BY user_id;


ALTER VIEW public.storage_stats OWNER TO postgres;

--
-- Name: support_conversations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.support_conversations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    subject text NOT NULL,
    status text DEFAULT 'open'::text,
    priority text DEFAULT 'medium'::text,
    category text DEFAULT 'general'::text,
    last_message_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT support_conversations_category_check CHECK ((category = ANY (ARRAY['technical'::text, 'billing'::text, 'general'::text, 'feature_request'::text, 'bug'::text, 'account'::text]))),
    CONSTRAINT support_conversations_priority_check CHECK ((priority = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text, 'urgent'::text]))),
    CONSTRAINT support_conversations_status_check CHECK ((status = ANY (ARRAY['open'::text, 'pending'::text, 'resolved'::text, 'closed'::text])))
);


ALTER TABLE public.support_conversations OWNER TO postgres;

--
-- Name: support_messages; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.support_messages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    conversation_id uuid NOT NULL,
    sender_id uuid,
    sender_type text DEFAULT 'user'::text,
    message text NOT NULL,
    is_automated boolean DEFAULT false,
    read_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT support_messages_sender_type_check CHECK ((sender_type = ANY (ARRAY['user'::text, 'admin'::text, 'bot'::text])))
);


ALTER TABLE public.support_messages OWNER TO postgres;

--
-- Name: support_tickets; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.support_tickets (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    title text NOT NULL,
    description text NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    priority text DEFAULT 'medium'::text NOT NULL,
    category text DEFAULT 'general'::text,
    assigned_to uuid,
    conversation_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    resolved_at timestamp with time zone,
    closed_at timestamp with time zone,
    CONSTRAINT support_tickets_category_check CHECK ((category = ANY (ARRAY['general'::text, 'technical'::text, 'billing'::text, 'feature'::text, 'bug'::text]))),
    CONSTRAINT support_tickets_priority_check CHECK ((priority = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text, 'urgent'::text]))),
    CONSTRAINT support_tickets_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'in_progress'::text, 'resolved'::text, 'closed'::text])))
);


ALTER TABLE public.support_tickets OWNER TO postgres;

--
-- Name: suspicious_accounts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.suspicious_accounts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    email text NOT NULL,
    phone text,
    reason text NOT NULL,
    severity text DEFAULT 'medium'::text,
    detected_at timestamp with time zone DEFAULT now(),
    reviewed boolean DEFAULT false,
    reviewed_at timestamp with time zone,
    reviewed_by uuid,
    notes text,
    CONSTRAINT suspicious_accounts_severity_check CHECK ((severity = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text, 'critical'::text])))
);


ALTER TABLE public.suspicious_accounts OWNER TO postgres;

--
-- Name: tracking_performance_stats; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.tracking_performance_stats AS
 SELECT count(DISTINCT mission_id) AS active_missions,
    avg(EXTRACT(epoch FROM (now() - last_update))) AS avg_delay_seconds,
    max(EXTRACT(epoch FROM (now() - last_update))) AS max_delay_seconds,
    count(*) FILTER (WHERE (last_update > (now() - '00:01:00'::interval))) AS positions_last_minute,
    count(*) FILTER (WHERE (last_update > (now() - '00:05:00'::interval))) AS positions_last_5_minutes,
    avg(battery_level) FILTER (WHERE (battery_level IS NOT NULL)) AS avg_battery_level,
    min(battery_level) FILTER (WHERE (battery_level IS NOT NULL)) AS min_battery_level
   FROM public.mission_tracking_live
  WHERE (is_active = true);


ALTER VIEW public.tracking_performance_stats OWNER TO postgres;

--
-- Name: VIEW tracking_performance_stats; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.tracking_performance_stats IS 'Statistiques de performance du tracking GPS en temps r√©el';


--
-- Name: transactions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.transactions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    package_id uuid,
    amount numeric(10,2) NOT NULL,
    credits integer NOT NULL,
    payment_id text,
    payment_status text DEFAULT 'pending'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.transactions OWNER TO postgres;

--
-- Name: unified_scanned_documents; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.unified_scanned_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    name text NOT NULL,
    file_path text NOT NULL,
    public_url text NOT NULL,
    filter_type text NOT NULL,
    document_type text,
    inspection_id uuid,
    platform text NOT NULL,
    file_size integer,
    width integer,
    height integer,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT unified_scanned_documents_document_type_check CHECK ((document_type = ANY (ARRAY['registration'::text, 'insurance'::text, 'receipt'::text, 'generic'::text]))),
    CONSTRAINT unified_scanned_documents_filter_type_check CHECK ((filter_type = ANY (ARRAY['bw'::text, 'grayscale'::text, 'color'::text]))),
    CONSTRAINT unified_scanned_documents_platform_check CHECK ((platform = ANY (ARRAY['web'::text, 'mobile'::text])))
);


ALTER TABLE public.unified_scanned_documents OWNER TO postgres;

--
-- Name: TABLE unified_scanned_documents; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.unified_scanned_documents IS 'Documents scann√©s synchronis√©s entre web et mobile';


--
-- Name: COLUMN unified_scanned_documents.filter_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.unified_scanned_documents.filter_type IS 'Type de filtre appliqu√©: bw (noir et blanc), grayscale (niveaux de gris), color (couleur)';


--
-- Name: COLUMN unified_scanned_documents.document_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.unified_scanned_documents.document_type IS 'Type de document: registration (carte grise), insurance (assurance), receipt (re√ßu), generic (g√©n√©rique)';


--
-- Name: COLUMN unified_scanned_documents.inspection_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.unified_scanned_documents.inspection_id IS 'ID de l''inspection li√©e (optionnel)';


--
-- Name: COLUMN unified_scanned_documents.platform; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.unified_scanned_documents.platform IS 'Plateforme d''origine: web ou mobile';


--
-- Name: user_consents; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_consents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    analytics boolean DEFAULT false,
    marketing boolean DEFAULT false,
    functional boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.user_consents OWNER TO postgres;

--
-- Name: user_credits; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_credits (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    balance integer DEFAULT 0,
    total_earned integer DEFAULT 0,
    total_spent integer DEFAULT 0,
    updated_at timestamp with time zone DEFAULT now(),
    subscription_expires_at timestamp with time zone,
    last_subscription_package_id uuid,
    CONSTRAINT user_credits_balance_check CHECK ((balance >= 0))
);


ALTER TABLE public.user_credits OWNER TO postgres;

--
-- Name: user_document_stats; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.user_document_stats AS
 SELECT user_id,
    count(*) AS total_documents,
    count(DISTINCT inspection_id) AS linked_inspections,
    sum(file_size) AS total_storage_bytes,
    count(*) FILTER (WHERE (platform = 'web'::text)) AS web_documents,
    count(*) FILTER (WHERE (platform = 'mobile'::text)) AS mobile_documents,
    count(*) FILTER (WHERE (filter_type = 'bw'::text)) AS bw_documents,
    count(*) FILTER (WHERE (filter_type = 'grayscale'::text)) AS gray_documents,
    count(*) FILTER (WHERE (filter_type = 'color'::text)) AS color_documents,
    max(created_at) AS last_scan_date
   FROM public.unified_scanned_documents
  GROUP BY user_id;


ALTER VIEW public.user_document_stats OWNER TO postgres;

--
-- Name: user_monthly_revenue_stats; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.user_monthly_revenue_stats AS
 SELECT user_id,
    month_key,
    revenue_type,
    sum(amount) AS total_revenue,
    count(DISTINCT mission_id) AS mission_count
   FROM public.mission_revenue_logs
  GROUP BY user_id, month_key, revenue_type
  ORDER BY month_key DESC, user_id;


ALTER VIEW public.user_monthly_revenue_stats OWNER TO postgres;

--
-- Name: user_push_tokens; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_push_tokens (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    push_token text NOT NULL,
    platform text NOT NULL,
    device_name text,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT user_push_tokens_platform_check CHECK ((platform = ANY (ARRAY['ios'::text, 'android'::text])))
);


ALTER TABLE public.user_push_tokens OWNER TO postgres;

--
-- Name: TABLE user_push_tokens; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.user_push_tokens IS 'Stocke les tokens Expo Push pour les notifications mobiles';


--
-- Name: vehicle_inspections; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.vehicle_inspections (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    mission_id uuid NOT NULL,
    inspector_id uuid,
    inspection_type text NOT NULL,
    vehicle_info jsonb DEFAULT '{}'::jsonb,
    overall_condition text,
    fuel_level integer,
    mileage_km integer,
    damages jsonb DEFAULT '[]'::jsonb,
    notes text,
    inspector_signature text,
    client_signature text,
    latitude numeric(10,8),
    longitude numeric(11,8),
    location_address text,
    status text DEFAULT 'in_progress'::text,
    completed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    keys_count integer DEFAULT 0,
    has_vehicle_documents boolean DEFAULT false,
    has_registration_card boolean DEFAULT false,
    vehicle_is_full boolean DEFAULT false,
    windshield_condition text DEFAULT 'bon'::text,
    signature_client_departure text,
    signature_client_departure_name text,
    signature_client_arrival text,
    signature_client_arrival_name text,
    scanned_document_url text,
    client_name text,
    external_cleanliness character varying(50) DEFAULT 'propre'::character varying,
    internal_cleanliness character varying(50) DEFAULT 'propre'::character varying,
    has_spare_wheel boolean DEFAULT false,
    has_repair_kit boolean DEFAULT false,
    photo_time character varying(50) DEFAULT 'jour'::character varying,
    photo_location character varying(50) DEFAULT 'parking'::character varying,
    photo_weather character varying(50) DEFAULT 'beau-temps'::character varying,
    condition text DEFAULT 'good'::text,
    driver_signature text,
    driver_name text,
    pdf_generated boolean DEFAULT false,
    pdf_generated_at timestamp with time zone,
    last_synced_at timestamp with time zone DEFAULT now(),
    client_email text,
    has_security_kit boolean DEFAULT false,
    has_inflation_kit boolean DEFAULT false,
    has_fuel_card boolean DEFAULT false,
    is_loaded boolean DEFAULT false,
    has_confided_object boolean DEFAULT false,
    confided_object_description text,
    fuel_level_numeric numeric(3,1),
    fuel_level_percentage integer,
    mileage_km_start integer,
    mileage_km_end integer,
    odometer_km integer,
    started_at timestamp with time zone,
    signature_driver_url text,
    signature_client_url text,
    CONSTRAINT vehicle_inspections_condition_check CHECK ((condition = ANY (ARRAY['good'::text, 'fair'::text, 'poor'::text]))),
    CONSTRAINT vehicle_inspections_inspection_type_check CHECK ((inspection_type = ANY (ARRAY['departure'::text, 'arrival'::text, 'restitution_departure'::text, 'restitution_arrival'::text])))
);


ALTER TABLE public.vehicle_inspections OWNER TO postgres;

--
-- Name: COLUMN vehicle_inspections.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.status IS 'Statut: draft, validated, sent';


--
-- Name: COLUMN vehicle_inspections.external_cleanliness; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.external_cleanliness IS 'Propret√© externe: tres-propre, propre, moyen, sale, tres-sale';


--
-- Name: COLUMN vehicle_inspections.internal_cleanliness; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.internal_cleanliness IS 'Propret√© interne: tres-propre, propre, moyen, sale, tres-sale';


--
-- Name: COLUMN vehicle_inspections.has_spare_wheel; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.has_spare_wheel IS 'Roue de secours pr√©sente';


--
-- Name: COLUMN vehicle_inspections.has_repair_kit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.has_repair_kit IS 'Kit de r√©paration pr√©sent';


--
-- Name: COLUMN vehicle_inspections.photo_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.photo_time IS 'Moment des photos: jour, nuit, aube-crepuscule';


--
-- Name: COLUMN vehicle_inspections.photo_location; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.photo_location IS 'Lieu des photos: parking, interieur, exterieur';


--
-- Name: COLUMN vehicle_inspections.photo_weather; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.photo_weather IS 'M√©t√©o lors des photos: beau-temps, nuageux, pluie, neige';


--
-- Name: COLUMN vehicle_inspections.driver_signature; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.driver_signature IS 'Signature du convoyeur en format base64';


--
-- Name: COLUMN vehicle_inspections.driver_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.driver_name IS 'Nom complet du convoyeur qui effectue l''inspection';


--
-- Name: COLUMN vehicle_inspections.pdf_generated; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.pdf_generated IS 'Indique si le PDF a √©t√© g√©n√©r√© server-side';


--
-- Name: COLUMN vehicle_inspections.last_synced_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.last_synced_at IS 'Derni√®re sync mobile ‚Üí web pour realtime';


--
-- Name: COLUMN vehicle_inspections.client_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.client_email IS 'Email du client qui recevra automatiquement le rapport d''inspection (PDF + photos ZIP)';


--
-- Name: COLUMN vehicle_inspections.fuel_level_numeric; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.fuel_level_numeric IS 'Numeric fuel level (liters) - preferred over fuel_level string';


--
-- Name: COLUMN vehicle_inspections.fuel_level_percentage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.fuel_level_percentage IS 'Fuel level as percentage (0-100) for consistency';


--
-- Name: COLUMN vehicle_inspections.mileage_km_start; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.mileage_km_start IS 'Odometer reading at start of journey';


--
-- Name: COLUMN vehicle_inspections.mileage_km_end; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.mileage_km_end IS 'Odometer reading at end of journey';


--
-- Name: COLUMN vehicle_inspections.odometer_km; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.odometer_km IS 'Current odometer reading (primary field for mileage)';


--
-- Name: COLUMN vehicle_inspections.started_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.started_at IS 'When the inspection process was started';


--
-- Name: COLUMN vehicle_inspections.signature_driver_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.signature_driver_url IS 'URL to driver signature image';


--
-- Name: COLUMN vehicle_inspections.signature_client_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vehicle_inspections.signature_client_url IS 'URL to client signature image';


--
-- Name: v_inspection_reports; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.v_inspection_reports AS
 SELECT vi.id AS inspection_id,
    vi.mission_id,
    vi.inspection_type,
    vi.overall_condition,
    vi.mileage_km,
    vi.fuel_level,
    vi.client_name,
    vi.driver_name,
    vi.created_at AS inspection_date,
    vi.pdf_generated,
    m.reference AS mission_reference,
    m.vehicle_brand,
    m.vehicle_model,
    m.vehicle_plate,
    m.pickup_address,
    m.delivery_address,
    count(DISTINCT ip.id) AS photo_count,
    ipdf.pdf_url,
    ipdf.generated_at AS pdf_generated_at,
    json_agg(jsonb_build_object('id', ip.id, 'type', ip.photo_type, 'thumbnail', ip.thumbnail_url, 'full', ip.full_url, 'taken_at', ip.taken_at) ORDER BY ip.taken_at) FILTER (WHERE (ip.id IS NOT NULL)) AS photos
   FROM (((public.vehicle_inspections vi
     LEFT JOIN public.missions m ON ((m.id = vi.mission_id)))
     LEFT JOIN public.inspection_photos_v2 ip ON ((ip.inspection_id = vi.id)))
     LEFT JOIN LATERAL ( SELECT inspection_pdfs.pdf_url,
            inspection_pdfs.generated_at
           FROM public.inspection_pdfs
          WHERE (inspection_pdfs.inspection_id = vi.id)
          ORDER BY inspection_pdfs.version DESC
         LIMIT 1) ipdf ON (true))
  GROUP BY vi.id, vi.mission_id, vi.inspection_type, vi.overall_condition, vi.mileage_km, vi.fuel_level, vi.client_name, vi.driver_name, vi.created_at, vi.pdf_generated, m.reference, m.vehicle_brand, m.vehicle_model, m.vehicle_plate, m.pickup_address, m.delivery_address, ipdf.pdf_url, ipdf.generated_at;


ALTER VIEW public.v_inspection_reports OWNER TO postgres;

--
-- Name: VIEW v_inspection_reports; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.v_inspection_reports IS 'Vue optimis√©e avec toutes les donn√©es n√©cessaires pour affichage rapports';


--
-- Name: messages; Type: TABLE; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE TABLE realtime.messages (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
)
PARTITION BY RANGE (inserted_at);


ALTER TABLE realtime.messages OWNER TO supabase_realtime_admin;

--
-- Name: messages_2026_02_15; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2026_02_15 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2026_02_15 OWNER TO supabase_admin;

--
-- Name: messages_2026_02_16; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2026_02_16 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2026_02_16 OWNER TO supabase_admin;

--
-- Name: messages_2026_02_17; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2026_02_17 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2026_02_17 OWNER TO supabase_admin;

--
-- Name: messages_2026_02_18; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2026_02_18 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2026_02_18 OWNER TO supabase_admin;

--
-- Name: messages_2026_02_19; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2026_02_19 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2026_02_19 OWNER TO supabase_admin;

--
-- Name: messages_2026_02_20; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2026_02_20 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2026_02_20 OWNER TO supabase_admin;

--
-- Name: messages_2026_02_21; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2026_02_21 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2026_02_21 OWNER TO supabase_admin;

--
-- Name: schema_migrations; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.schema_migrations (
    version bigint NOT NULL,
    inserted_at timestamp(0) without time zone
);


ALTER TABLE realtime.schema_migrations OWNER TO supabase_admin;

--
-- Name: subscription; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.subscription (
    id bigint NOT NULL,
    subscription_id uuid NOT NULL,
    entity regclass NOT NULL,
    filters realtime.user_defined_filter[] DEFAULT '{}'::realtime.user_defined_filter[] NOT NULL,
    claims jsonb NOT NULL,
    claims_role regrole GENERATED ALWAYS AS (realtime.to_regrole((claims ->> 'role'::text))) STORED NOT NULL,
    created_at timestamp without time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    action_filter text DEFAULT '*'::text,
    CONSTRAINT subscription_action_filter_check CHECK ((action_filter = ANY (ARRAY['*'::text, 'INSERT'::text, 'UPDATE'::text, 'DELETE'::text])))
);


ALTER TABLE realtime.subscription OWNER TO supabase_admin;

--
-- Name: subscription_id_seq; Type: SEQUENCE; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE realtime.subscription ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME realtime.subscription_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: buckets; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.buckets (
    id text NOT NULL,
    name text NOT NULL,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    public boolean DEFAULT false,
    avif_autodetection boolean DEFAULT false,
    file_size_limit bigint,
    allowed_mime_types text[],
    owner_id text,
    type storage.buckettype DEFAULT 'STANDARD'::storage.buckettype NOT NULL
);


ALTER TABLE storage.buckets OWNER TO supabase_storage_admin;

--
-- Name: COLUMN buckets.owner; Type: COMMENT; Schema: storage; Owner: supabase_storage_admin
--

COMMENT ON COLUMN storage.buckets.owner IS 'Field is deprecated, use owner_id instead';


--
-- Name: buckets_analytics; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.buckets_analytics (
    name text NOT NULL,
    type storage.buckettype DEFAULT 'ANALYTICS'::storage.buckettype NOT NULL,
    format text DEFAULT 'ICEBERG'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    deleted_at timestamp with time zone
);


ALTER TABLE storage.buckets_analytics OWNER TO supabase_storage_admin;

--
-- Name: buckets_vectors; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.buckets_vectors (
    id text NOT NULL,
    type storage.buckettype DEFAULT 'VECTOR'::storage.buckettype NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE storage.buckets_vectors OWNER TO supabase_storage_admin;

--
-- Name: migrations; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.migrations (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    hash character varying(40) NOT NULL,
    executed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE storage.migrations OWNER TO supabase_storage_admin;

--
-- Name: objects; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.objects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bucket_id text,
    name text,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    last_accessed_at timestamp with time zone DEFAULT now(),
    metadata jsonb,
    path_tokens text[] GENERATED ALWAYS AS (string_to_array(name, '/'::text)) STORED,
    version text,
    owner_id text,
    user_metadata jsonb
);


ALTER TABLE storage.objects OWNER TO supabase_storage_admin;

--
-- Name: COLUMN objects.owner; Type: COMMENT; Schema: storage; Owner: supabase_storage_admin
--

COMMENT ON COLUMN storage.objects.owner IS 'Field is deprecated, use owner_id instead';


--
-- Name: s3_multipart_uploads; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.s3_multipart_uploads (
    id text NOT NULL,
    in_progress_size bigint DEFAULT 0 NOT NULL,
    upload_signature text NOT NULL,
    bucket_id text NOT NULL,
    key text NOT NULL COLLATE pg_catalog."C",
    version text NOT NULL,
    owner_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_metadata jsonb
);


ALTER TABLE storage.s3_multipart_uploads OWNER TO supabase_storage_admin;

--
-- Name: s3_multipart_uploads_parts; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.s3_multipart_uploads_parts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    upload_id text NOT NULL,
    size bigint DEFAULT 0 NOT NULL,
    part_number integer NOT NULL,
    bucket_id text NOT NULL,
    key text NOT NULL COLLATE pg_catalog."C",
    etag text NOT NULL,
    owner_id text,
    version text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE storage.s3_multipart_uploads_parts OWNER TO supabase_storage_admin;

--
-- Name: vector_indexes; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.vector_indexes (
    id text DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL COLLATE pg_catalog."C",
    bucket_id text NOT NULL,
    data_type text NOT NULL,
    dimension integer NOT NULL,
    distance_metric text NOT NULL,
    metadata_configuration jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE storage.vector_indexes OWNER TO supabase_storage_admin;

--
-- Name: schema_migrations; Type: TABLE; Schema: supabase_migrations; Owner: postgres
--

CREATE TABLE supabase_migrations.schema_migrations (
    version text NOT NULL,
    statements text[],
    name text
);


ALTER TABLE supabase_migrations.schema_migrations OWNER TO postgres;

--
-- Name: seed_files; Type: TABLE; Schema: supabase_migrations; Owner: postgres
--

CREATE TABLE supabase_migrations.seed_files (
    path text NOT NULL,
    hash text NOT NULL
);


ALTER TABLE supabase_migrations.seed_files OWNER TO postgres;

--
-- Name: messages_2026_02_15; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2026_02_15 FOR VALUES FROM ('2026-02-15 00:00:00') TO ('2026-02-16 00:00:00');


--
-- Name: messages_2026_02_16; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2026_02_16 FOR VALUES FROM ('2026-02-16 00:00:00') TO ('2026-02-17 00:00:00');


--
-- Name: messages_2026_02_17; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2026_02_17 FOR VALUES FROM ('2026-02-17 00:00:00') TO ('2026-02-18 00:00:00');


--
-- Name: messages_2026_02_18; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2026_02_18 FOR VALUES FROM ('2026-02-18 00:00:00') TO ('2026-02-19 00:00:00');


--
-- Name: messages_2026_02_19; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2026_02_19 FOR VALUES FROM ('2026-02-19 00:00:00') TO ('2026-02-20 00:00:00');


--
-- Name: messages_2026_02_20; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2026_02_20 FOR VALUES FROM ('2026-02-20 00:00:00') TO ('2026-02-21 00:00:00');


--
-- Name: messages_2026_02_21; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2026_02_21 FOR VALUES FROM ('2026-02-21 00:00:00') TO ('2026-02-22 00:00:00');


--
-- Name: refresh_tokens id; Type: DEFAULT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens ALTER COLUMN id SET DEFAULT nextval('auth.refresh_tokens_id_seq'::regclass);


--
-- Name: mfa_amr_claims amr_id_pk; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT amr_id_pk PRIMARY KEY (id);


--
-- Name: audit_log_entries audit_log_entries_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.audit_log_entries
    ADD CONSTRAINT audit_log_entries_pkey PRIMARY KEY (id);


--
-- Name: flow_state flow_state_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.flow_state
    ADD CONSTRAINT flow_state_pkey PRIMARY KEY (id);


--
-- Name: identities identities_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_pkey PRIMARY KEY (id);


--
-- Name: identities identities_provider_id_provider_unique; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_provider_id_provider_unique UNIQUE (provider_id, provider);


--
-- Name: instances instances_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.instances
    ADD CONSTRAINT instances_pkey PRIMARY KEY (id);


--
-- Name: mfa_amr_claims mfa_amr_claims_session_id_authentication_method_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey UNIQUE (session_id, authentication_method);


--
-- Name: mfa_challenges mfa_challenges_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_pkey PRIMARY KEY (id);


--
-- Name: mfa_factors mfa_factors_last_challenged_at_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_last_challenged_at_key UNIQUE (last_challenged_at);


--
-- Name: mfa_factors mfa_factors_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_pkey PRIMARY KEY (id);


--
-- Name: oauth_authorizations oauth_authorizations_authorization_code_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_authorization_code_key UNIQUE (authorization_code);


--
-- Name: oauth_authorizations oauth_authorizations_authorization_id_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_authorization_id_key UNIQUE (authorization_id);


--
-- Name: oauth_authorizations oauth_authorizations_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_pkey PRIMARY KEY (id);


--
-- Name: oauth_client_states oauth_client_states_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_client_states
    ADD CONSTRAINT oauth_client_states_pkey PRIMARY KEY (id);


--
-- Name: oauth_clients oauth_clients_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_clients
    ADD CONSTRAINT oauth_clients_pkey PRIMARY KEY (id);


--
-- Name: oauth_consents oauth_consents_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_pkey PRIMARY KEY (id);


--
-- Name: oauth_consents oauth_consents_user_client_unique; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_user_client_unique UNIQUE (user_id, client_id);


--
-- Name: one_time_tokens one_time_tokens_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_pkey PRIMARY KEY (id);


--
-- Name: refresh_tokens refresh_tokens_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_pkey PRIMARY KEY (id);


--
-- Name: refresh_tokens refresh_tokens_token_unique; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_token_unique UNIQUE (token);


--
-- Name: saml_providers saml_providers_entity_id_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_entity_id_key UNIQUE (entity_id);


--
-- Name: saml_providers saml_providers_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_pkey PRIMARY KEY (id);


--
-- Name: saml_relay_states saml_relay_states_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_pkey PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: sessions sessions_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_pkey PRIMARY KEY (id);


--
-- Name: sso_domains sso_domains_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_domains
    ADD CONSTRAINT sso_domains_pkey PRIMARY KEY (id);


--
-- Name: sso_providers sso_providers_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_providers
    ADD CONSTRAINT sso_providers_pkey PRIMARY KEY (id);


--
-- Name: users users_phone_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.users
    ADD CONSTRAINT users_phone_key UNIQUE (phone);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: account_creation_attempts account_creation_attempts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.account_creation_attempts
    ADD CONSTRAINT account_creation_attempts_pkey PRIMARY KEY (id);


--
-- Name: app_versions app_versions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.app_versions
    ADD CONSTRAINT app_versions_pkey PRIMARY KEY (id);


--
-- Name: app_versions app_versions_version_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.app_versions
    ADD CONSTRAINT app_versions_version_name_key UNIQUE (version_name);


--
-- Name: attachments attachments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attachments
    ADD CONSTRAINT attachments_pkey PRIMARY KEY (id);


--
-- Name: attachments attachments_storage_path_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attachments
    ADD CONSTRAINT attachments_storage_path_key UNIQUE (storage_path);


--
-- Name: availability_calendar availability_calendar_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.availability_calendar
    ADD CONSTRAINT availability_calendar_pkey PRIMARY KEY (id);


--
-- Name: availability_calendar availability_calendar_user_id_date_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.availability_calendar
    ADD CONSTRAINT availability_calendar_user_id_date_key UNIQUE (user_id, date);


--
-- Name: calendar_events calendar_events_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.calendar_events
    ADD CONSTRAINT calendar_events_pkey PRIMARY KEY (id);


--
-- Name: calendar_permissions calendar_permissions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.calendar_permissions
    ADD CONSTRAINT calendar_permissions_pkey PRIMARY KEY (id);


--
-- Name: calendar_permissions calendar_permissions_unique; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.calendar_permissions
    ADD CONSTRAINT calendar_permissions_unique UNIQUE (owner_id, shared_with_id);


--
-- Name: carpooling_bookings carpooling_bookings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carpooling_bookings
    ADD CONSTRAINT carpooling_bookings_pkey PRIMARY KEY (id);


--
-- Name: carpooling_bookings carpooling_bookings_trip_id_passenger_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carpooling_bookings
    ADD CONSTRAINT carpooling_bookings_trip_id_passenger_id_key UNIQUE (trip_id, passenger_id);


--
-- Name: carpooling_messages carpooling_messages_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carpooling_messages
    ADD CONSTRAINT carpooling_messages_pkey PRIMARY KEY (id);


--
-- Name: carpooling_trips carpooling_trips_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carpooling_trips
    ADD CONSTRAINT carpooling_trips_pkey PRIMARY KEY (id);


--
-- Name: clients clients_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.clients
    ADD CONSTRAINT clients_pkey PRIMARY KEY (id);


--
-- Name: contact_requests contact_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contact_requests
    ADD CONSTRAINT contact_requests_pkey PRIMARY KEY (id);


--
-- Name: contacts contacts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contacts
    ADD CONSTRAINT contacts_pkey PRIMARY KEY (id);


--
-- Name: convoy_plannings convoy_plannings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.convoy_plannings
    ADD CONSTRAINT convoy_plannings_pkey PRIMARY KEY (id);


--
-- Name: covoiturage_trips covoiturage_trips_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.covoiturage_trips
    ADD CONSTRAINT covoiturage_trips_pkey PRIMARY KEY (id);


--
-- Name: credit_transactions credit_transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.credit_transactions
    ADD CONSTRAINT credit_transactions_pkey PRIMARY KEY (id);


--
-- Name: deletion_requests deletion_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.deletion_requests
    ADD CONSTRAINT deletion_requests_pkey PRIMARY KEY (id);


--
-- Name: documents documents_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.documents
    ADD CONSTRAINT documents_pkey PRIMARY KEY (id);


--
-- Name: gps_location_points gps_location_points_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gps_location_points
    ADD CONSTRAINT gps_location_points_pkey PRIMARY KEY (id);


--
-- Name: gps_tracking_sessions gps_tracking_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gps_tracking_sessions
    ADD CONSTRAINT gps_tracking_sessions_pkey PRIMARY KEY (id);


--
-- Name: inspection_damages inspection_damages_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_damages
    ADD CONSTRAINT inspection_damages_pkey PRIMARY KEY (id);


--
-- Name: inspection_documents inspection_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_documents
    ADD CONSTRAINT inspection_documents_pkey PRIMARY KEY (id);


--
-- Name: inspection_expenses inspection_expenses_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_expenses
    ADD CONSTRAINT inspection_expenses_pkey PRIMARY KEY (id);


--
-- Name: inspection_pdfs inspection_pdfs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_pdfs
    ADD CONSTRAINT inspection_pdfs_pkey PRIMARY KEY (id);


--
-- Name: inspection_photos_v2 inspection_photos_v2_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_photos_v2
    ADD CONSTRAINT inspection_photos_v2_pkey PRIMARY KEY (id);


--
-- Name: inspection_report_shares inspection_report_shares_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_report_shares
    ADD CONSTRAINT inspection_report_shares_pkey PRIMARY KEY (id);


--
-- Name: inspection_report_shares inspection_report_shares_share_token_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_report_shares
    ADD CONSTRAINT inspection_report_shares_share_token_key UNIQUE (share_token);


--
-- Name: inspections inspections_mission_id_inspection_type_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspections
    ADD CONSTRAINT inspections_mission_id_inspection_type_key UNIQUE (mission_id, inspection_type);


--
-- Name: inspections inspections_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspections
    ADD CONSTRAINT inspections_pkey PRIMARY KEY (id);


--
-- Name: invoice_items invoice_items_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_items
    ADD CONSTRAINT invoice_items_pkey PRIMARY KEY (id);


--
-- Name: invoices invoices_invoice_number_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_invoice_number_key UNIQUE (invoice_number);


--
-- Name: invoices invoices_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_pkey PRIMARY KEY (id);


--
-- Name: mission_assignments mission_assignments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_assignments
    ADD CONSTRAINT mission_assignments_pkey PRIMARY KEY (id);


--
-- Name: mission_locations mission_locations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_locations
    ADD CONSTRAINT mission_locations_pkey PRIMARY KEY (id);


--
-- Name: mission_revenue_logs mission_revenue_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_revenue_logs
    ADD CONSTRAINT mission_revenue_logs_pkey PRIMARY KEY (id);


--
-- Name: mission_tracking_history mission_tracking_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_tracking_history
    ADD CONSTRAINT mission_tracking_history_pkey PRIMARY KEY (id);


--
-- Name: mission_tracking_live mission_tracking_live_mission_id_user_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_tracking_live
    ADD CONSTRAINT mission_tracking_live_mission_id_user_id_key UNIQUE (mission_id, user_id);


--
-- Name: mission_tracking_live mission_tracking_live_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_tracking_live
    ADD CONSTRAINT mission_tracking_live_pkey PRIMARY KEY (id);


--
-- Name: missions missions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.missions
    ADD CONSTRAINT missions_pkey PRIMARY KEY (id);


--
-- Name: missions missions_reference_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.missions
    ADD CONSTRAINT missions_reference_key UNIQUE (reference);


--
-- Name: missions missions_share_code_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.missions
    ADD CONSTRAINT missions_share_code_key UNIQUE (share_code);


--
-- Name: missions missions_tracking_code_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.missions
    ADD CONSTRAINT missions_tracking_code_key UNIQUE (tracking_code);


--
-- Name: navigation_sessions navigation_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.navigation_sessions
    ADD CONSTRAINT navigation_sessions_pkey PRIMARY KEY (id);


--
-- Name: notifications notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_pkey PRIMARY KEY (id);


--
-- Name: phone_verifications phone_verifications_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.phone_verifications
    ADD CONSTRAINT phone_verifications_pkey PRIMARY KEY (id);


--
-- Name: planning_matches planning_matches_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_matches
    ADD CONSTRAINT planning_matches_pkey PRIMARY KEY (id);


--
-- Name: planning_messages planning_messages_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_messages
    ADD CONSTRAINT planning_messages_pkey PRIMARY KEY (id);


--
-- Name: planning_notifications planning_notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_notifications
    ADD CONSTRAINT planning_notifications_pkey PRIMARY KEY (id);


--
-- Name: planning_stats planning_stats_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_stats
    ADD CONSTRAINT planning_stats_pkey PRIMARY KEY (id);


--
-- Name: planning_waypoints planning_waypoints_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_waypoints
    ADD CONSTRAINT planning_waypoints_pkey PRIMARY KEY (id);


--
-- Name: pricing_grids pricing_grids_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pricing_grids
    ADD CONSTRAINT pricing_grids_pkey PRIMARY KEY (id);


--
-- Name: profiles profiles_email_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_email_key UNIQUE (email);


--
-- Name: profiles profiles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_pkey PRIMARY KEY (id);


--
-- Name: profiles profiles_siret_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_siret_key UNIQUE (siret);


--
-- Name: public_inspection_reports public_inspection_reports_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.public_inspection_reports
    ADD CONSTRAINT public_inspection_reports_pkey PRIMARY KEY (id);


--
-- Name: public_inspection_reports public_inspection_reports_share_token_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.public_inspection_reports
    ADD CONSTRAINT public_inspection_reports_share_token_key UNIQUE (share_token);


--
-- Name: public_tracking_links public_tracking_links_mission_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.public_tracking_links
    ADD CONSTRAINT public_tracking_links_mission_id_key UNIQUE (mission_id);


--
-- Name: public_tracking_links public_tracking_links_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.public_tracking_links
    ADD CONSTRAINT public_tracking_links_pkey PRIMARY KEY (id);


--
-- Name: public_tracking_links public_tracking_links_token_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.public_tracking_links
    ADD CONSTRAINT public_tracking_links_token_key UNIQUE (token);


--
-- Name: push_tokens push_tokens_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.push_tokens
    ADD CONSTRAINT push_tokens_pkey PRIMARY KEY (id);


--
-- Name: push_tokens push_tokens_user_id_token_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.push_tokens
    ADD CONSTRAINT push_tokens_user_id_token_key UNIQUE (user_id, token);


--
-- Name: quote_items quote_items_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.quote_items
    ADD CONSTRAINT quote_items_pkey PRIMARY KEY (id);


--
-- Name: quotes quotes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.quotes
    ADD CONSTRAINT quotes_pkey PRIMARY KEY (id);


--
-- Name: quotes quotes_quote_number_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.quotes
    ADD CONSTRAINT quotes_quote_number_key UNIQUE (quote_number);


--
-- Name: ride_matches ride_matches_offer_id_request_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_matches
    ADD CONSTRAINT ride_matches_offer_id_request_id_key UNIQUE (offer_id, request_id);


--
-- Name: ride_matches ride_matches_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_matches
    ADD CONSTRAINT ride_matches_pkey PRIMARY KEY (id);


--
-- Name: ride_messages ride_messages_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_messages
    ADD CONSTRAINT ride_messages_pkey PRIMARY KEY (id);


--
-- Name: ride_offers ride_offers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_offers
    ADD CONSTRAINT ride_offers_pkey PRIMARY KEY (id);


--
-- Name: ride_ratings ride_ratings_match_id_rater_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_ratings
    ADD CONSTRAINT ride_ratings_match_id_rater_id_key UNIQUE (match_id, rater_id);


--
-- Name: ride_ratings ride_ratings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_ratings
    ADD CONSTRAINT ride_ratings_pkey PRIMARY KEY (id);


--
-- Name: ride_requests ride_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_requests
    ADD CONSTRAINT ride_requests_pkey PRIMARY KEY (id);


--
-- Name: shop_items shop_items_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.shop_items
    ADD CONSTRAINT shop_items_pkey PRIMARY KEY (id);


--
-- Name: shop_quote_requests shop_quote_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.shop_quote_requests
    ADD CONSTRAINT shop_quote_requests_pkey PRIMARY KEY (id);


--
-- Name: signup_attempts signup_attempts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.signup_attempts
    ADD CONSTRAINT signup_attempts_pkey PRIMARY KEY (id);


--
-- Name: subscriptions subscriptions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_pkey PRIMARY KEY (id);


--
-- Name: subscriptions subscriptions_user_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_user_id_key UNIQUE (user_id);


--
-- Name: support_conversations support_conversations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.support_conversations
    ADD CONSTRAINT support_conversations_pkey PRIMARY KEY (id);


--
-- Name: support_messages support_messages_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.support_messages
    ADD CONSTRAINT support_messages_pkey PRIMARY KEY (id);


--
-- Name: support_tickets support_tickets_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.support_tickets
    ADD CONSTRAINT support_tickets_pkey PRIMARY KEY (id);


--
-- Name: suspicious_accounts suspicious_accounts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.suspicious_accounts
    ADD CONSTRAINT suspicious_accounts_pkey PRIMARY KEY (id);


--
-- Name: transactions transactions_payment_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_payment_id_key UNIQUE (payment_id);


--
-- Name: transactions transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_pkey PRIMARY KEY (id);


--
-- Name: unified_scanned_documents unified_scanned_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.unified_scanned_documents
    ADD CONSTRAINT unified_scanned_documents_pkey PRIMARY KEY (id);


--
-- Name: planning_matches unique_match; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_matches
    ADD CONSTRAINT unique_match UNIQUE (planning_a_id, planning_b_id);


--
-- Name: inspection_report_shares unique_mission_type; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_report_shares
    ADD CONSTRAINT unique_mission_type UNIQUE (mission_id, report_type);


--
-- Name: inspection_pdfs unique_pdf_per_inspection; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_pdfs
    ADD CONSTRAINT unique_pdf_per_inspection UNIQUE (inspection_id, version);


--
-- Name: inspection_photos_v2 unique_photo_per_type_v2; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_photos_v2
    ADD CONSTRAINT unique_photo_per_type_v2 UNIQUE (inspection_id, photo_type);


--
-- Name: planning_stats unique_user_month; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_stats
    ADD CONSTRAINT unique_user_month UNIQUE (user_id, month, year);


--
-- Name: user_consents user_consents_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_consents
    ADD CONSTRAINT user_consents_pkey PRIMARY KEY (id);


--
-- Name: user_credits user_credits_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_credits
    ADD CONSTRAINT user_credits_pkey PRIMARY KEY (id);


--
-- Name: user_credits user_credits_user_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_credits
    ADD CONSTRAINT user_credits_user_id_key UNIQUE (user_id);


--
-- Name: user_devices user_devices_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_devices
    ADD CONSTRAINT user_devices_pkey PRIMARY KEY (id);


--
-- Name: user_devices user_devices_player_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_devices
    ADD CONSTRAINT user_devices_player_id_key UNIQUE (player_id);


--
-- Name: user_push_tokens user_push_tokens_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_push_tokens
    ADD CONSTRAINT user_push_tokens_pkey PRIMARY KEY (id);


--
-- Name: user_push_tokens user_push_tokens_user_id_platform_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_push_tokens
    ADD CONSTRAINT user_push_tokens_user_id_platform_key UNIQUE (user_id, platform);


--
-- Name: vehicle_inspections vehicle_inspections_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vehicle_inspections
    ADD CONSTRAINT vehicle_inspections_pkey PRIMARY KEY (id);


--
-- Name: messages messages_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER TABLE ONLY realtime.messages
    ADD CONSTRAINT messages_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2026_02_15 messages_2026_02_15_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2026_02_15
    ADD CONSTRAINT messages_2026_02_15_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2026_02_16 messages_2026_02_16_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2026_02_16
    ADD CONSTRAINT messages_2026_02_16_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2026_02_17 messages_2026_02_17_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2026_02_17
    ADD CONSTRAINT messages_2026_02_17_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2026_02_18 messages_2026_02_18_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2026_02_18
    ADD CONSTRAINT messages_2026_02_18_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2026_02_19 messages_2026_02_19_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2026_02_19
    ADD CONSTRAINT messages_2026_02_19_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2026_02_20 messages_2026_02_20_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2026_02_20
    ADD CONSTRAINT messages_2026_02_20_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2026_02_21 messages_2026_02_21_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2026_02_21
    ADD CONSTRAINT messages_2026_02_21_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: subscription pk_subscription; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.subscription
    ADD CONSTRAINT pk_subscription PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: buckets_analytics buckets_analytics_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.buckets_analytics
    ADD CONSTRAINT buckets_analytics_pkey PRIMARY KEY (id);


--
-- Name: buckets buckets_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.buckets
    ADD CONSTRAINT buckets_pkey PRIMARY KEY (id);


--
-- Name: buckets_vectors buckets_vectors_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.buckets_vectors
    ADD CONSTRAINT buckets_vectors_pkey PRIMARY KEY (id);


--
-- Name: migrations migrations_name_key; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.migrations
    ADD CONSTRAINT migrations_name_key UNIQUE (name);


--
-- Name: migrations migrations_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.migrations
    ADD CONSTRAINT migrations_pkey PRIMARY KEY (id);


--
-- Name: objects objects_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.objects
    ADD CONSTRAINT objects_pkey PRIMARY KEY (id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_pkey PRIMARY KEY (id);


--
-- Name: s3_multipart_uploads s3_multipart_uploads_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_pkey PRIMARY KEY (id);


--
-- Name: vector_indexes vector_indexes_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.vector_indexes
    ADD CONSTRAINT vector_indexes_pkey PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: supabase_migrations; Owner: postgres
--

ALTER TABLE ONLY supabase_migrations.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: seed_files seed_files_pkey; Type: CONSTRAINT; Schema: supabase_migrations; Owner: postgres
--

ALTER TABLE ONLY supabase_migrations.seed_files
    ADD CONSTRAINT seed_files_pkey PRIMARY KEY (path);


--
-- Name: audit_logs_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX audit_logs_instance_id_idx ON auth.audit_log_entries USING btree (instance_id);


--
-- Name: confirmation_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX confirmation_token_idx ON auth.users USING btree (confirmation_token) WHERE ((confirmation_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: email_change_token_current_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX email_change_token_current_idx ON auth.users USING btree (email_change_token_current) WHERE ((email_change_token_current)::text !~ '^[0-9 ]*$'::text);


--
-- Name: email_change_token_new_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX email_change_token_new_idx ON auth.users USING btree (email_change_token_new) WHERE ((email_change_token_new)::text !~ '^[0-9 ]*$'::text);


--
-- Name: factor_id_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX factor_id_created_at_idx ON auth.mfa_factors USING btree (user_id, created_at);


--
-- Name: flow_state_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX flow_state_created_at_idx ON auth.flow_state USING btree (created_at DESC);


--
-- Name: identities_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX identities_email_idx ON auth.identities USING btree (email text_pattern_ops);


--
-- Name: INDEX identities_email_idx; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON INDEX auth.identities_email_idx IS 'Auth: Ensures indexed queries on the email column';


--
-- Name: identities_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX identities_user_id_idx ON auth.identities USING btree (user_id);


--
-- Name: idx_auth_code; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX idx_auth_code ON auth.flow_state USING btree (auth_code);


--
-- Name: idx_oauth_client_states_created_at; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX idx_oauth_client_states_created_at ON auth.oauth_client_states USING btree (created_at);


--
-- Name: idx_user_id_auth_method; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX idx_user_id_auth_method ON auth.flow_state USING btree (user_id, authentication_method);


--
-- Name: mfa_challenge_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX mfa_challenge_created_at_idx ON auth.mfa_challenges USING btree (created_at DESC);


--
-- Name: mfa_factors_user_friendly_name_unique; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX mfa_factors_user_friendly_name_unique ON auth.mfa_factors USING btree (friendly_name, user_id) WHERE (TRIM(BOTH FROM friendly_name) <> ''::text);


--
-- Name: mfa_factors_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX mfa_factors_user_id_idx ON auth.mfa_factors USING btree (user_id);


--
-- Name: oauth_auth_pending_exp_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_auth_pending_exp_idx ON auth.oauth_authorizations USING btree (expires_at) WHERE (status = 'pending'::auth.oauth_authorization_status);


--
-- Name: oauth_clients_deleted_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_clients_deleted_at_idx ON auth.oauth_clients USING btree (deleted_at);


--
-- Name: oauth_consents_active_client_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_consents_active_client_idx ON auth.oauth_consents USING btree (client_id) WHERE (revoked_at IS NULL);


--
-- Name: oauth_consents_active_user_client_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_consents_active_user_client_idx ON auth.oauth_consents USING btree (user_id, client_id) WHERE (revoked_at IS NULL);


--
-- Name: oauth_consents_user_order_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_consents_user_order_idx ON auth.oauth_consents USING btree (user_id, granted_at DESC);


--
-- Name: one_time_tokens_relates_to_hash_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX one_time_tokens_relates_to_hash_idx ON auth.one_time_tokens USING hash (relates_to);


--
-- Name: one_time_tokens_token_hash_hash_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX one_time_tokens_token_hash_hash_idx ON auth.one_time_tokens USING hash (token_hash);


--
-- Name: one_time_tokens_user_id_token_type_key; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX one_time_tokens_user_id_token_type_key ON auth.one_time_tokens USING btree (user_id, token_type);


--
-- Name: reauthentication_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX reauthentication_token_idx ON auth.users USING btree (reauthentication_token) WHERE ((reauthentication_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: recovery_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX recovery_token_idx ON auth.users USING btree (recovery_token) WHERE ((recovery_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: refresh_tokens_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_instance_id_idx ON auth.refresh_tokens USING btree (instance_id);


--
-- Name: refresh_tokens_instance_id_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_instance_id_user_id_idx ON auth.refresh_tokens USING btree (instance_id, user_id);


--
-- Name: refresh_tokens_parent_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_parent_idx ON auth.refresh_tokens USING btree (parent);


--
-- Name: refresh_tokens_session_id_revoked_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_session_id_revoked_idx ON auth.refresh_tokens USING btree (session_id, revoked);


--
-- Name: refresh_tokens_updated_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_updated_at_idx ON auth.refresh_tokens USING btree (updated_at DESC);


--
-- Name: saml_providers_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_providers_sso_provider_id_idx ON auth.saml_providers USING btree (sso_provider_id);


--
-- Name: saml_relay_states_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_created_at_idx ON auth.saml_relay_states USING btree (created_at DESC);


--
-- Name: saml_relay_states_for_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_for_email_idx ON auth.saml_relay_states USING btree (for_email);


--
-- Name: saml_relay_states_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_sso_provider_id_idx ON auth.saml_relay_states USING btree (sso_provider_id);


--
-- Name: sessions_not_after_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sessions_not_after_idx ON auth.sessions USING btree (not_after DESC);


--
-- Name: sessions_oauth_client_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sessions_oauth_client_id_idx ON auth.sessions USING btree (oauth_client_id);


--
-- Name: sessions_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sessions_user_id_idx ON auth.sessions USING btree (user_id);


--
-- Name: sso_domains_domain_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX sso_domains_domain_idx ON auth.sso_domains USING btree (lower(domain));


--
-- Name: sso_domains_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sso_domains_sso_provider_id_idx ON auth.sso_domains USING btree (sso_provider_id);


--
-- Name: sso_providers_resource_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX sso_providers_resource_id_idx ON auth.sso_providers USING btree (lower(resource_id));


--
-- Name: sso_providers_resource_id_pattern_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sso_providers_resource_id_pattern_idx ON auth.sso_providers USING btree (resource_id text_pattern_ops);


--
-- Name: unique_phone_factor_per_user; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX unique_phone_factor_per_user ON auth.mfa_factors USING btree (user_id, phone);


--
-- Name: user_id_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX user_id_created_at_idx ON auth.sessions USING btree (user_id, created_at);


--
-- Name: users_email_partial_key; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX users_email_partial_key ON auth.users USING btree (email) WHERE (is_sso_user = false);


--
-- Name: INDEX users_email_partial_key; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON INDEX auth.users_email_partial_key IS 'Auth: A partial unique index that applies only when is_sso_user is false';


--
-- Name: users_instance_id_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_instance_id_email_idx ON auth.users USING btree (instance_id, lower((email)::text));


--
-- Name: users_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_instance_id_idx ON auth.users USING btree (instance_id);


--
-- Name: users_is_anonymous_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_is_anonymous_idx ON auth.users USING btree (is_anonymous);


--
-- Name: idx_account_attempts_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_account_attempts_date ON public.account_creation_attempts USING btree (attempt_date DESC);


--
-- Name: idx_account_attempts_email; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_account_attempts_email ON public.account_creation_attempts USING btree (email);


--
-- Name: idx_account_attempts_phone; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_account_attempts_phone ON public.account_creation_attempts USING btree (phone) WHERE (phone IS NOT NULL);


--
-- Name: idx_app_versions_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_app_versions_created_at ON public.app_versions USING btree (created_at DESC);


--
-- Name: idx_app_versions_is_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_app_versions_is_active ON public.app_versions USING btree (is_active);


--
-- Name: idx_app_versions_version_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_app_versions_version_code ON public.app_versions USING btree (version_code DESC);


--
-- Name: idx_attachments_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_attachments_category ON public.attachments USING btree (category);


--
-- Name: idx_attachments_related; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_attachments_related ON public.attachments USING btree (related_to, related_type);


--
-- Name: idx_attachments_uploaded_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_attachments_uploaded_at ON public.attachments USING btree (uploaded_at DESC);


--
-- Name: idx_attachments_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_attachments_user_id ON public.attachments USING btree (user_id);


--
-- Name: idx_availability_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_availability_date ON public.availability_calendar USING btree (date);


--
-- Name: idx_availability_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_availability_status ON public.availability_calendar USING btree (status);


--
-- Name: idx_availability_user_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_availability_user_date ON public.availability_calendar USING btree (user_id, date);


--
-- Name: idx_cal_evt_end; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_cal_evt_end ON public.calendar_events USING btree (end_time);


--
-- Name: idx_cal_evt_owner; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_cal_evt_owner ON public.calendar_events USING btree (owner_id);


--
-- Name: idx_cal_evt_start; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_cal_evt_start ON public.calendar_events USING btree (start_time);


--
-- Name: idx_cal_perm_owner; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_cal_perm_owner ON public.calendar_permissions USING btree (owner_id);


--
-- Name: idx_cal_perm_shared; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_cal_perm_shared ON public.calendar_permissions USING btree (shared_with_id);


--
-- Name: idx_carpooling_bookings_passenger; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_bookings_passenger ON public.carpooling_bookings USING btree (passenger_id);


--
-- Name: idx_carpooling_bookings_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_bookings_status ON public.carpooling_bookings USING btree (status);


--
-- Name: idx_carpooling_bookings_trip; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_bookings_trip ON public.carpooling_bookings USING btree (trip_id);


--
-- Name: idx_carpooling_messages_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_messages_created ON public.carpooling_messages USING btree (created_at DESC);


--
-- Name: idx_carpooling_messages_receiver; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_messages_receiver ON public.carpooling_messages USING btree (receiver_id);


--
-- Name: idx_carpooling_messages_sender; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_messages_sender ON public.carpooling_messages USING btree (sender_id);


--
-- Name: idx_carpooling_messages_trip; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_messages_trip ON public.carpooling_messages USING btree (trip_id);


--
-- Name: idx_carpooling_messages_trip_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_messages_trip_id ON public.carpooling_messages USING btree (trip_id);


--
-- Name: idx_carpooling_trips_arrival_city; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_trips_arrival_city ON public.carpooling_trips USING btree (arrival_city);


--
-- Name: idx_carpooling_trips_departure_city; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_trips_departure_city ON public.carpooling_trips USING btree (departure_city);


--
-- Name: idx_carpooling_trips_departure_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_trips_departure_date ON public.carpooling_trips USING btree (departure_datetime);


--
-- Name: idx_carpooling_trips_driver; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_trips_driver ON public.carpooling_trips USING btree (driver_id);


--
-- Name: idx_carpooling_trips_search; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_trips_search ON public.carpooling_trips USING btree (departure_city, arrival_city, departure_datetime) WHERE (status = 'active'::text);


--
-- Name: idx_carpooling_trips_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_carpooling_trips_status ON public.carpooling_trips USING btree (status);


--
-- Name: idx_clients_name; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_clients_name ON public.clients USING btree (name);


--
-- Name: idx_clients_siret; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_clients_siret ON public.clients USING btree (siret);


--
-- Name: idx_clients_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_clients_user_id ON public.clients USING btree (user_id);


--
-- Name: idx_contact_requests_requester_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_contact_requests_requester_id ON public.contact_requests USING btree (requester_id);


--
-- Name: idx_contact_requests_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_contact_requests_status ON public.contact_requests USING btree (status);


--
-- Name: idx_contact_requests_target_email; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_contact_requests_target_email ON public.contact_requests USING btree (target_email);


--
-- Name: idx_contacts_availability; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_contacts_availability ON public.contacts USING btree (availability_status) WHERE (is_driver = true);


--
-- Name: idx_contacts_driver_location; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_contacts_driver_location ON public.contacts USING btree (current_latitude, current_longitude) WHERE (is_driver = true);


--
-- Name: idx_contacts_invitation_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_contacts_invitation_status ON public.contacts USING btree (invitation_status);


--
-- Name: idx_contacts_invited_by; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_contacts_invited_by ON public.contacts USING btree (invited_by);


--
-- Name: idx_contacts_invited_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_contacts_invited_user ON public.contacts USING btree (invited_user_id);


--
-- Name: idx_contacts_is_driver; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_contacts_is_driver ON public.contacts USING btree (is_driver) WHERE (is_driver = true);


--
-- Name: idx_contacts_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_contacts_user_id ON public.contacts USING btree (user_id);


--
-- Name: idx_convoy_plannings_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_convoy_plannings_date ON public.convoy_plannings USING btree (planning_date);


--
-- Name: idx_convoy_plannings_dest; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_convoy_plannings_dest ON public.convoy_plannings USING btree (destination_city);


--
-- Name: idx_convoy_plannings_geo; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_convoy_plannings_geo ON public.convoy_plannings USING btree (origin_lat, origin_lng, destination_lat, destination_lng);


--
-- Name: idx_convoy_plannings_origin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_convoy_plannings_origin ON public.convoy_plannings USING btree (origin_city);


--
-- Name: idx_convoy_plannings_return_city; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_convoy_plannings_return_city ON public.convoy_plannings USING btree (return_city) WHERE (return_city IS NOT NULL);


--
-- Name: idx_convoy_plannings_return_geo; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_convoy_plannings_return_geo ON public.convoy_plannings USING btree (return_lat, return_lng) WHERE (return_lat IS NOT NULL);


--
-- Name: idx_convoy_plannings_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_convoy_plannings_status ON public.convoy_plannings USING btree (status);


--
-- Name: idx_convoy_plannings_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_convoy_plannings_user ON public.convoy_plannings USING btree (user_id);


--
-- Name: idx_covoiturage_trips_cities; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_covoiturage_trips_cities ON public.covoiturage_trips USING btree (departure_city, arrival_city);


--
-- Name: idx_covoiturage_trips_departure_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_covoiturage_trips_departure_date ON public.covoiturage_trips USING btree (departure_date);


--
-- Name: idx_covoiturage_trips_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_covoiturage_trips_status ON public.covoiturage_trips USING btree (status);


--
-- Name: idx_covoiturage_trips_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_covoiturage_trips_user_id ON public.covoiturage_trips USING btree (user_id);


--
-- Name: idx_credit_transactions_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_credit_transactions_date ON public.credit_transactions USING btree (created_at DESC);


--
-- Name: idx_credit_transactions_transaction_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_credit_transactions_transaction_type ON public.credit_transactions USING btree (transaction_type);


--
-- Name: idx_credit_transactions_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_credit_transactions_user ON public.credit_transactions USING btree (user_id);


--
-- Name: idx_credit_transactions_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_credit_transactions_user_id ON public.credit_transactions USING btree (user_id);


--
-- Name: idx_deletion_requests_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_deletion_requests_status ON public.deletion_requests USING btree (status);


--
-- Name: idx_deletion_requests_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_deletion_requests_user_id ON public.deletion_requests USING btree (user_id);


--
-- Name: idx_documents_inspection_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_documents_inspection_id ON public.documents USING btree (inspection_id);


--
-- Name: idx_documents_mission_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_documents_mission_id ON public.documents USING btree (mission_id);


--
-- Name: idx_documents_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_documents_user_id ON public.documents USING btree (user_id);


--
-- Name: idx_gps_accuracy; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gps_accuracy ON public.gps_location_points USING btree (accuracy) WHERE (accuracy IS NOT NULL);


--
-- Name: idx_gps_location_geom; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gps_location_geom ON public.gps_location_points USING gist (location);


--
-- Name: idx_gps_session_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gps_session_time ON public.gps_location_points USING btree (session_id, recorded_at DESC);


--
-- Name: idx_gps_speed; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_gps_speed ON public.gps_location_points USING btree (speed_kmh) WHERE (speed_kmh IS NOT NULL);


--
-- Name: idx_insp_mission; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_insp_mission ON public.vehicle_inspections USING btree (mission_id);


--
-- Name: idx_insp_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_insp_type ON public.vehicle_inspections USING btree (inspection_type);


--
-- Name: idx_inspection_damages_damage_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_damages_damage_type ON public.inspection_damages USING btree (damage_type);


--
-- Name: idx_inspection_damages_inspection_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_damages_inspection_id ON public.inspection_damages USING btree (inspection_id);


--
-- Name: idx_inspection_damages_severity; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_damages_severity ON public.inspection_damages USING btree (severity);


--
-- Name: idx_inspection_documents_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_documents_created_at ON public.inspection_documents USING btree (created_at DESC);


--
-- Name: idx_inspection_documents_inspection_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_documents_inspection_id ON public.inspection_documents USING btree (inspection_id);


--
-- Name: idx_inspection_documents_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_documents_type ON public.inspection_documents USING btree (document_type);


--
-- Name: idx_inspection_documents_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_documents_user_id ON public.inspection_documents USING btree (user_id);


--
-- Name: idx_inspection_expenses_inspection_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_expenses_inspection_id ON public.inspection_expenses USING btree (inspection_id);


--
-- Name: idx_inspection_expenses_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_expenses_type ON public.inspection_expenses USING btree (expense_type);


--
-- Name: idx_inspection_pdfs_mission_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_pdfs_mission_id ON public.inspection_pdfs USING btree (mission_id);


--
-- Name: idx_inspection_report_shares_mission; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_report_shares_mission ON public.inspection_report_shares USING btree (mission_id);


--
-- Name: idx_inspection_report_shares_token; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_report_shares_token ON public.inspection_report_shares USING btree (share_token);


--
-- Name: idx_inspection_report_shares_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspection_report_shares_user ON public.inspection_report_shares USING btree (user_id);


--
-- Name: idx_inspections_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspections_created ON public.vehicle_inspections USING btree (created_at DESC);


--
-- Name: idx_inspections_locked_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspections_locked_at ON public.inspections USING btree (locked_at) WHERE (locked_at IS NOT NULL);


--
-- Name: idx_inspections_mission; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspections_mission ON public.vehicle_inspections USING btree (mission_id);


--
-- Name: idx_inspections_mission_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspections_mission_id ON public.inspections USING btree (mission_id);


--
-- Name: idx_inspections_mission_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspections_mission_status ON public.inspections USING btree (mission_id, status);


--
-- Name: idx_inspections_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspections_status ON public.inspections USING btree (status);


--
-- Name: idx_inspections_status_complete; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspections_status_complete ON public.vehicle_inspections USING btree (mission_id, inspection_type) WHERE ((client_signature IS NOT NULL) AND (driver_signature IS NOT NULL));


--
-- Name: idx_inspections_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspections_type ON public.vehicle_inspections USING btree (inspection_type);


--
-- Name: idx_inspections_use_ai; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspections_use_ai ON public.inspections USING btree (use_ai);


--
-- Name: idx_inspections_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_inspections_user_id ON public.inspections USING btree (user_id);


--
-- Name: idx_invoice_items_invoice_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoice_items_invoice_id ON public.invoice_items USING btree (invoice_id);


--
-- Name: idx_invoices_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_client_id ON public.invoices USING btree (client_id);


--
-- Name: idx_invoices_client_info_gin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_client_info_gin ON public.invoices USING gin (client_info);


--
-- Name: idx_invoices_client_legal_form; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_client_legal_form ON public.invoices USING btree (client_legal_form);


--
-- Name: idx_invoices_client_vat_number; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_client_vat_number ON public.invoices USING btree (client_vat_number);


--
-- Name: idx_invoices_invoice_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_invoice_date ON public.invoices USING btree (invoice_date DESC);


--
-- Name: idx_invoices_issue_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_issue_date ON public.invoices USING btree (issue_date DESC);


--
-- Name: idx_invoices_mission_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_mission_id ON public.invoices USING btree (mission_id);


--
-- Name: idx_invoices_number; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_number ON public.invoices USING btree (invoice_number);


--
-- Name: idx_invoices_paid_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_paid_at ON public.invoices USING btree (paid_at DESC) WHERE (paid_at IS NOT NULL);


--
-- Name: idx_invoices_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_status ON public.invoices USING btree (status);


--
-- Name: idx_invoices_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invoices_user_id ON public.invoices USING btree (user_id);


--
-- Name: idx_loc_session; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_loc_session ON public.gps_location_points USING btree (session_id);


--
-- Name: idx_loc_session_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_loc_session_time ON public.gps_location_points USING btree (session_id, recorded_at);


--
-- Name: idx_loc_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_loc_time ON public.gps_location_points USING btree (recorded_at);


--
-- Name: idx_messages_receiver; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_messages_receiver ON public.carpooling_messages USING btree (receiver_id);


--
-- Name: idx_messages_sender; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_messages_sender ON public.carpooling_messages USING btree (sender_id);


--
-- Name: idx_messages_trip; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_messages_trip ON public.carpooling_messages USING btree (trip_id);


--
-- Name: idx_mission_assignments_contact; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_mission_assignments_contact ON public.mission_assignments USING btree (contact_id);


--
-- Name: idx_mission_assignments_mission; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_mission_assignments_mission ON public.mission_assignments USING btree (mission_id);


--
-- Name: idx_mission_assignments_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_mission_assignments_status ON public.mission_assignments USING btree (status);


--
-- Name: idx_mission_assignments_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_mission_assignments_user ON public.mission_assignments USING btree (user_id);


--
-- Name: idx_mission_locations_mission_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_mission_locations_mission_id ON public.mission_locations USING btree (mission_id);


--
-- Name: idx_mission_locations_recorded_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_mission_locations_recorded_at ON public.mission_locations USING btree (recorded_at DESC);


--
-- Name: idx_mission_report; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_mission_report ON public.inspection_report_shares USING btree (mission_id, report_type);


--
-- Name: idx_mission_revenue_logs_mission_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_mission_revenue_logs_mission_id ON public.mission_revenue_logs USING btree (mission_id);


--
-- Name: idx_mission_revenue_logs_month_key; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_mission_revenue_logs_month_key ON public.mission_revenue_logs USING btree (month_key);


--
-- Name: idx_mission_revenue_logs_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_mission_revenue_logs_user_id ON public.mission_revenue_logs USING btree (user_id);


--
-- Name: idx_missions_agent_name; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_agent_name ON public.missions USING btree (agent_name) WHERE (agent_name IS NOT NULL);


--
-- Name: idx_missions_archived; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_archived ON public.missions USING btree (archived);


--
-- Name: idx_missions_assigned_to_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_assigned_to_user ON public.missions USING btree (assigned_user_id);


--
-- Name: idx_missions_assigned_to_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_assigned_to_user_id ON public.missions USING btree (assigned_user_id);


--
-- Name: idx_missions_assigned_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_assigned_user ON public.missions USING btree (assigned_user_id);


--
-- Name: idx_missions_completed_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_completed_at ON public.missions USING btree (completed_at);


--
-- Name: idx_missions_delivery_contact; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_delivery_contact ON public.missions USING btree (delivery_contact_name);


--
-- Name: idx_missions_driver_phone; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_driver_phone ON public.missions USING btree (driver_phone);


--
-- Name: idx_missions_mandataire_company; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_mandataire_company ON public.missions USING btree (mandataire_company);


--
-- Name: idx_missions_normalized_share_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_normalized_share_code ON public.missions USING btree (normalized_share_code);


--
-- Name: idx_missions_pickup_contact; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_pickup_contact ON public.missions USING btree (pickup_contact_name);


--
-- Name: idx_missions_public_tracking_link; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_public_tracking_link ON public.missions USING btree (public_tracking_link);


--
-- Name: idx_missions_share_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_share_code ON public.missions USING btree (share_code);


--
-- Name: idx_missions_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_status ON public.missions USING btree (status);


--
-- Name: idx_missions_tracking_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_tracking_code ON public.missions USING btree (tracking_code);


--
-- Name: idx_missions_user_archived; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_user_archived ON public.missions USING btree (user_id, archived);


--
-- Name: idx_missions_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_user_id ON public.missions USING btree (user_id);


--
-- Name: idx_missions_vehicle_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_missions_vehicle_type ON public.missions USING btree (vehicle_type);


--
-- Name: idx_navigation_sessions_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_navigation_sessions_active ON public.navigation_sessions USING btree (started_at DESC) WHERE (status = 'active'::text);


--
-- Name: idx_navigation_sessions_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_navigation_sessions_created ON public.navigation_sessions USING btree (created_at DESC);


--
-- Name: idx_navigation_sessions_mission; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_navigation_sessions_mission ON public.navigation_sessions USING btree (mission_id);


--
-- Name: idx_navigation_sessions_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_navigation_sessions_status ON public.navigation_sessions USING btree (status);


--
-- Name: idx_notifications_is_read; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_notifications_is_read ON public.notifications USING btree (is_read);


--
-- Name: idx_notifications_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_notifications_user_id ON public.notifications USING btree (user_id);


--
-- Name: idx_pdfs_generated; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pdfs_generated ON public.inspection_pdfs USING btree (generated_at DESC);


--
-- Name: idx_pdfs_inspection; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pdfs_inspection ON public.inspection_pdfs USING btree (inspection_id);


--
-- Name: idx_phone_verifications_expires; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_phone_verifications_expires ON public.phone_verifications USING btree (expires_at) WHERE (verified = false);


--
-- Name: idx_phone_verifications_phone; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_phone_verifications_phone ON public.phone_verifications USING btree (phone, created_at DESC);


--
-- Name: idx_photos_v2_inspection; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_photos_v2_inspection ON public.inspection_photos_v2 USING btree (inspection_id);


--
-- Name: idx_photos_v2_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_photos_v2_type ON public.inspection_photos_v2 USING btree (photo_type);


--
-- Name: idx_photos_v2_uploaded; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_photos_v2_uploaded ON public.inspection_photos_v2 USING btree (uploaded_at DESC);


--
-- Name: idx_planning_matches_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_planning_matches_status ON public.planning_matches USING btree (status);


--
-- Name: idx_planning_matches_users; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_planning_matches_users ON public.planning_matches USING btree (user_a_id, user_b_id);


--
-- Name: idx_planning_messages_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_planning_messages_created ON public.planning_messages USING btree (match_id, created_at);


--
-- Name: idx_planning_messages_match; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_planning_messages_match ON public.planning_messages USING btree (match_id);


--
-- Name: idx_planning_messages_sender; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_planning_messages_sender ON public.planning_messages USING btree (sender_id);


--
-- Name: idx_planning_notifications_unread; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_planning_notifications_unread ON public.planning_notifications USING btree (user_id) WHERE (is_read = false);


--
-- Name: idx_planning_notifications_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_planning_notifications_user ON public.planning_notifications USING btree (user_id, created_at DESC);


--
-- Name: idx_planning_stats_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_planning_stats_user ON public.planning_stats USING btree (user_id, year, month);


--
-- Name: idx_planning_waypoints_planning; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_planning_waypoints_planning ON public.planning_waypoints USING btree (planning_id);


--
-- Name: idx_pricing_grids_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_grids_client_id ON public.pricing_grids USING btree (client_id);


--
-- Name: idx_pricing_grids_global; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_grids_global ON public.pricing_grids USING btree (is_global) WHERE (is_global = true);


--
-- Name: idx_pricing_grids_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pricing_grids_user_id ON public.pricing_grids USING btree (user_id);


--
-- Name: idx_profiles_availability; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profiles_availability ON public.profiles USING btree (availability_status) WHERE (user_role = 'driver'::text);


--
-- Name: idx_profiles_billing_complete; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profiles_billing_complete ON public.profiles USING btree (((billing_meta ->> 'billing_profile_complete'::text)));


--
-- Name: idx_profiles_device_fingerprint; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profiles_device_fingerprint ON public.profiles USING btree (device_fingerprint);


--
-- Name: idx_profiles_driver_location; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profiles_driver_location ON public.profiles USING btree (current_latitude, current_longitude) WHERE (user_role = 'driver'::text);


--
-- Name: idx_profiles_driver_role; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profiles_driver_role ON public.profiles USING btree (user_role) WHERE (user_role = 'driver'::text);


--
-- Name: idx_profiles_onboarding; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profiles_onboarding ON public.profiles USING btree (onboarding_completed);


--
-- Name: idx_profiles_phone; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profiles_phone ON public.profiles USING btree (phone);


--
-- Name: idx_profiles_phone_unique; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX idx_profiles_phone_unique ON public.profiles USING btree (phone);


--
-- Name: idx_profiles_registration_ip; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profiles_registration_ip ON public.profiles USING btree (registration_ip);


--
-- Name: idx_profiles_siret; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profiles_siret ON public.profiles USING btree (siret) WHERE (siret IS NOT NULL);


--
-- Name: idx_profiles_wallet_balance; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profiles_wallet_balance ON public.profiles USING btree (wallet_balance);


--
-- Name: idx_public_reports_created_by; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_public_reports_created_by ON public.public_inspection_reports USING btree (created_by);


--
-- Name: idx_public_reports_mission_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_public_reports_mission_id ON public.public_inspection_reports USING btree (mission_id);


--
-- Name: idx_public_reports_share_token; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_public_reports_share_token ON public.public_inspection_reports USING btree (share_token);


--
-- Name: idx_push_tokens_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_push_tokens_user_id ON public.push_tokens USING btree (user_id);


--
-- Name: idx_quote_items_quote_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quote_items_quote_id ON public.quote_items USING btree (quote_id);


--
-- Name: idx_quotes_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_client_id ON public.quotes USING btree (client_id);


--
-- Name: idx_quotes_client_legal_form; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_client_legal_form ON public.quotes USING btree (client_legal_form);


--
-- Name: idx_quotes_client_siret; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_client_siret ON public.quotes USING btree (client_siret);


--
-- Name: idx_quotes_client_vat_number; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_client_vat_number ON public.quotes USING btree (client_vat_number);


--
-- Name: idx_quotes_converted_invoice; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_converted_invoice ON public.quotes USING btree (converted_invoice_id);


--
-- Name: idx_quotes_items_gin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_items_gin ON public.quotes USING gin (items);


--
-- Name: idx_quotes_mission_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_mission_id ON public.quotes USING btree (mission_id);


--
-- Name: idx_quotes_pricing_grid_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_pricing_grid_id ON public.quotes USING btree (pricing_grid_id);


--
-- Name: idx_quotes_quote_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_quote_date ON public.quotes USING btree (quote_date);


--
-- Name: idx_quotes_quote_number; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_quote_number ON public.quotes USING btree (quote_number);


--
-- Name: idx_quotes_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_status ON public.quotes USING btree (status);


--
-- Name: idx_quotes_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_user_id ON public.quotes USING btree (user_id);


--
-- Name: idx_quotes_valid_until; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_quotes_valid_until ON public.quotes USING btree (valid_until);


--
-- Name: idx_ride_matches_driver; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_matches_driver ON public.ride_matches USING btree (driver_id, status);


--
-- Name: idx_ride_matches_offer; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_matches_offer ON public.ride_matches USING btree (offer_id);


--
-- Name: idx_ride_matches_passenger; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_matches_passenger ON public.ride_matches USING btree (passenger_id, status);


--
-- Name: idx_ride_matches_request; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_matches_request ON public.ride_matches USING btree (request_id);


--
-- Name: idx_ride_matches_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_matches_status ON public.ride_matches USING btree (status);


--
-- Name: idx_ride_messages_match; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_messages_match ON public.ride_messages USING btree (match_id, created_at);


--
-- Name: idx_ride_messages_sender; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_messages_sender ON public.ride_messages USING btree (sender_id);


--
-- Name: idx_ride_offers_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_offers_date ON public.ride_offers USING btree (departure_date, status);


--
-- Name: idx_ride_offers_dest; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_offers_dest ON public.ride_offers USING btree (destination_lat, destination_lng);


--
-- Name: idx_ride_offers_mission; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_offers_mission ON public.ride_offers USING btree (mission_id);


--
-- Name: idx_ride_offers_origin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_offers_origin ON public.ride_offers USING btree (origin_lat, origin_lng);


--
-- Name: idx_ride_offers_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_offers_status ON public.ride_offers USING btree (status) WHERE (status = ANY (ARRAY['active'::text, 'en_route'::text]));


--
-- Name: idx_ride_offers_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_offers_user ON public.ride_offers USING btree (user_id);


--
-- Name: idx_ride_ratings_match; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_ratings_match ON public.ride_ratings USING btree (match_id);


--
-- Name: idx_ride_ratings_rated; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_ratings_rated ON public.ride_ratings USING btree (rated_id);


--
-- Name: idx_ride_requests_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_requests_date ON public.ride_requests USING btree (needed_date, status);


--
-- Name: idx_ride_requests_dest; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_requests_dest ON public.ride_requests USING btree (destination_lat, destination_lng);


--
-- Name: idx_ride_requests_pickup; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_requests_pickup ON public.ride_requests USING btree (pickup_lat, pickup_lng);


--
-- Name: idx_ride_requests_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_requests_status ON public.ride_requests USING btree (status) WHERE (status = 'active'::text);


--
-- Name: idx_ride_requests_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_ride_requests_user ON public.ride_requests USING btree (user_id);


--
-- Name: idx_share_token; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_share_token ON public.inspection_report_shares USING btree (share_token);


--
-- Name: idx_shop_quote_requests_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_shop_quote_requests_created_at ON public.shop_quote_requests USING btree (created_at DESC);


--
-- Name: idx_shop_quote_requests_package_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_shop_quote_requests_package_id ON public.shop_quote_requests USING btree (package_id);


--
-- Name: idx_shop_quote_requests_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_shop_quote_requests_status ON public.shop_quote_requests USING btree (status);


--
-- Name: idx_shop_quote_requests_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_shop_quote_requests_user_id ON public.shop_quote_requests USING btree (user_id);


--
-- Name: idx_signup_attempts_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_signup_attempts_created ON public.signup_attempts USING btree (created_at);


--
-- Name: idx_signup_attempts_device; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_signup_attempts_device ON public.signup_attempts USING btree (device_fingerprint);


--
-- Name: idx_signup_attempts_email; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_signup_attempts_email ON public.signup_attempts USING btree (email);


--
-- Name: idx_signup_attempts_ip; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_signup_attempts_ip ON public.signup_attempts USING btree (ip_address);


--
-- Name: idx_subscriptions_plan; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_plan ON public.subscriptions USING btree (plan);


--
-- Name: idx_subscriptions_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_status ON public.subscriptions USING btree (status);


--
-- Name: idx_subscriptions_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_user_id ON public.subscriptions USING btree (user_id);


--
-- Name: idx_support_conversations_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_support_conversations_status ON public.support_conversations USING btree (status);


--
-- Name: idx_support_conversations_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_support_conversations_user_id ON public.support_conversations USING btree (user_id);


--
-- Name: idx_support_messages_conversation_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_support_messages_conversation_id ON public.support_messages USING btree (conversation_id);


--
-- Name: idx_support_messages_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_support_messages_created_at ON public.support_messages USING btree (created_at);


--
-- Name: idx_support_tickets_priority; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_support_tickets_priority ON public.support_tickets USING btree (priority);


--
-- Name: idx_support_tickets_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_support_tickets_status ON public.support_tickets USING btree (status);


--
-- Name: idx_support_tickets_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_support_tickets_user_id ON public.support_tickets USING btree (user_id);


--
-- Name: idx_suspicious_accounts_email; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_suspicious_accounts_email ON public.suspicious_accounts USING btree (email);


--
-- Name: idx_suspicious_accounts_reviewed; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_suspicious_accounts_reviewed ON public.suspicious_accounts USING btree (reviewed);


--
-- Name: idx_track_driver; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_track_driver ON public.gps_tracking_sessions USING btree (driver_id);


--
-- Name: idx_track_mission; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_track_mission ON public.gps_tracking_sessions USING btree (mission_id);


--
-- Name: idx_tracking_history_mission; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tracking_history_mission ON public.mission_tracking_history USING btree (mission_id);


--
-- Name: idx_tracking_history_mission_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tracking_history_mission_time ON public.mission_tracking_history USING btree (mission_id, recorded_at DESC);


--
-- Name: idx_tracking_links_expiry; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tracking_links_expiry ON public.public_tracking_links USING btree (expires_at) WHERE (is_active = true);


--
-- Name: idx_tracking_links_mission; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tracking_links_mission ON public.public_tracking_links USING btree (mission_id);


--
-- Name: idx_tracking_links_token; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tracking_links_token ON public.public_tracking_links USING btree (token) WHERE (is_active = true);


--
-- Name: idx_tracking_live_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tracking_live_active ON public.mission_tracking_live USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_tracking_live_mission; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tracking_live_mission ON public.mission_tracking_live USING btree (mission_id, last_update DESC);


--
-- Name: idx_tracking_live_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_tracking_live_user ON public.mission_tracking_live USING btree (user_id);


--
-- Name: idx_unified_docs_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_unified_docs_created_at ON public.unified_scanned_documents USING btree (created_at DESC);


--
-- Name: idx_unified_docs_inspection_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_unified_docs_inspection_id ON public.unified_scanned_documents USING btree (inspection_id);


--
-- Name: idx_unified_docs_platform; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_unified_docs_platform ON public.unified_scanned_documents USING btree (platform);


--
-- Name: idx_unified_docs_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_unified_docs_type ON public.unified_scanned_documents USING btree (document_type);


--
-- Name: idx_unified_docs_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_unified_docs_user_id ON public.unified_scanned_documents USING btree (user_id);


--
-- Name: idx_unique_active_assignment; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX idx_unique_active_assignment ON public.mission_assignments USING btree (mission_id, contact_id) WHERE (status <> 'cancelled'::text);


--
-- Name: idx_user_consents_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_consents_user_id ON public.user_consents USING btree (user_id);


--
-- Name: idx_user_devices_last_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_devices_last_active ON public.user_devices USING btree (last_active DESC);


--
-- Name: idx_user_devices_player; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_devices_player ON public.user_devices USING btree (player_id);


--
-- Name: idx_user_devices_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_devices_user ON public.user_devices USING btree (user_id);


--
-- Name: idx_user_push_tokens_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_push_tokens_active ON public.user_push_tokens USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_user_push_tokens_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_push_tokens_user_id ON public.user_push_tokens USING btree (user_id);


--
-- Name: idx_vehicle_inspections_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_vehicle_inspections_created_at ON public.vehicle_inspections USING btree (created_at DESC);


--
-- Name: idx_vehicle_inspections_fuel_level_percentage; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_vehicle_inspections_fuel_level_percentage ON public.vehicle_inspections USING btree (fuel_level_percentage);


--
-- Name: idx_vehicle_inspections_inspector_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_vehicle_inspections_inspector_id ON public.vehicle_inspections USING btree (inspector_id);


--
-- Name: idx_vehicle_inspections_mileage_km; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_vehicle_inspections_mileage_km ON public.vehicle_inspections USING btree (mileage_km);


--
-- Name: idx_vehicle_inspections_mission_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_vehicle_inspections_mission_id ON public.vehicle_inspections USING btree (mission_id);


--
-- Name: idx_vehicle_inspections_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_vehicle_inspections_status ON public.vehicle_inspections USING btree (status);


--
-- Name: ix_realtime_subscription_entity; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE INDEX ix_realtime_subscription_entity ON realtime.subscription USING btree (entity);


--
-- Name: messages_inserted_at_topic_index; Type: INDEX; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE INDEX messages_inserted_at_topic_index ON ONLY realtime.messages USING btree (inserted_at DESC, topic) WHERE ((extension = 'broadcast'::text) AND (private IS TRUE));


--
-- Name: messages_2026_02_15_inserted_at_topic_idx; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE INDEX messages_2026_02_15_inserted_at_topic_idx ON realtime.messages_2026_02_15 USING btree (inserted_at DESC, topic) WHERE ((extension = 'broadcast'::text) AND (private IS TRUE));


--
-- Name: messages_2026_02_16_inserted_at_topic_idx; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE INDEX messages_2026_02_16_inserted_at_topic_idx ON realtime.messages_2026_02_16 USING btree (inserted_at DESC, topic) WHERE ((extension = 'broadcast'::text) AND (private IS TRUE));


--
-- Name: messages_2026_02_17_inserted_at_topic_idx; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE INDEX messages_2026_02_17_inserted_at_topic_idx ON realtime.messages_2026_02_17 USING btree (inserted_at DESC, topic) WHERE ((extension = 'broadcast'::text) AND (private IS TRUE));


--
-- Name: messages_2026_02_18_inserted_at_topic_idx; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE INDEX messages_2026_02_18_inserted_at_topic_idx ON realtime.messages_2026_02_18 USING btree (inserted_at DESC, topic) WHERE ((extension = 'broadcast'::text) AND (private IS TRUE));


--
-- Name: messages_2026_02_19_inserted_at_topic_idx; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE INDEX messages_2026_02_19_inserted_at_topic_idx ON realtime.messages_2026_02_19 USING btree (inserted_at DESC, topic) WHERE ((extension = 'broadcast'::text) AND (private IS TRUE));


--
-- Name: messages_2026_02_20_inserted_at_topic_idx; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE INDEX messages_2026_02_20_inserted_at_topic_idx ON realtime.messages_2026_02_20 USING btree (inserted_at DESC, topic) WHERE ((extension = 'broadcast'::text) AND (private IS TRUE));


--
-- Name: messages_2026_02_21_inserted_at_topic_idx; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE INDEX messages_2026_02_21_inserted_at_topic_idx ON realtime.messages_2026_02_21 USING btree (inserted_at DESC, topic) WHERE ((extension = 'broadcast'::text) AND (private IS TRUE));


--
-- Name: subscription_subscription_id_entity_filters_action_filter_key; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE UNIQUE INDEX subscription_subscription_id_entity_filters_action_filter_key ON realtime.subscription USING btree (subscription_id, entity, filters, action_filter);


--
-- Name: bname; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX bname ON storage.buckets USING btree (name);


--
-- Name: bucketid_objname; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX bucketid_objname ON storage.objects USING btree (bucket_id, name);


--
-- Name: buckets_analytics_unique_name_idx; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX buckets_analytics_unique_name_idx ON storage.buckets_analytics USING btree (name) WHERE (deleted_at IS NULL);


--
-- Name: idx_multipart_uploads_list; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_multipart_uploads_list ON storage.s3_multipart_uploads USING btree (bucket_id, key, created_at);


--
-- Name: idx_objects_bucket_id_name; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_objects_bucket_id_name ON storage.objects USING btree (bucket_id, name COLLATE "C");


--
-- Name: idx_objects_bucket_id_name_lower; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_objects_bucket_id_name_lower ON storage.objects USING btree (bucket_id, lower(name) COLLATE "C");


--
-- Name: name_prefix_search; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX name_prefix_search ON storage.objects USING btree (name text_pattern_ops);


--
-- Name: vector_indexes_name_bucket_id_idx; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX vector_indexes_name_bucket_id_idx ON storage.vector_indexes USING btree (name, bucket_id);


--
-- Name: messages_2026_02_15_inserted_at_topic_idx; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_inserted_at_topic_index ATTACH PARTITION realtime.messages_2026_02_15_inserted_at_topic_idx;


--
-- Name: messages_2026_02_15_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2026_02_15_pkey;


--
-- Name: messages_2026_02_16_inserted_at_topic_idx; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_inserted_at_topic_index ATTACH PARTITION realtime.messages_2026_02_16_inserted_at_topic_idx;


--
-- Name: messages_2026_02_16_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2026_02_16_pkey;


--
-- Name: messages_2026_02_17_inserted_at_topic_idx; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_inserted_at_topic_index ATTACH PARTITION realtime.messages_2026_02_17_inserted_at_topic_idx;


--
-- Name: messages_2026_02_17_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2026_02_17_pkey;


--
-- Name: messages_2026_02_18_inserted_at_topic_idx; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_inserted_at_topic_index ATTACH PARTITION realtime.messages_2026_02_18_inserted_at_topic_idx;


--
-- Name: messages_2026_02_18_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2026_02_18_pkey;


--
-- Name: messages_2026_02_19_inserted_at_topic_idx; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_inserted_at_topic_index ATTACH PARTITION realtime.messages_2026_02_19_inserted_at_topic_idx;


--
-- Name: messages_2026_02_19_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2026_02_19_pkey;


--
-- Name: messages_2026_02_20_inserted_at_topic_idx; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_inserted_at_topic_index ATTACH PARTITION realtime.messages_2026_02_20_inserted_at_topic_idx;


--
-- Name: messages_2026_02_20_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2026_02_20_pkey;


--
-- Name: messages_2026_02_21_inserted_at_topic_idx; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_inserted_at_topic_index ATTACH PARTITION realtime.messages_2026_02_21_inserted_at_topic_idx;


--
-- Name: messages_2026_02_21_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2026_02_21_pkey;


--
-- Name: users on_auth_user_created; Type: TRIGGER; Schema: auth; Owner: supabase_auth_admin
--

CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


--
-- Name: app_versions app_versions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER app_versions_updated_at BEFORE UPDATE ON public.app_versions FOR EACH ROW EXECUTE FUNCTION public.update_app_versions_updated_at();


--
-- Name: subscriptions assign_credits_on_subscription; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER assign_credits_on_subscription AFTER INSERT OR UPDATE OF plan, status ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION public.assign_credits_for_plan();


--
-- Name: profiles audit_admin_status_changes; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER audit_admin_status_changes AFTER UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.log_admin_status_change();


--
-- Name: invoices auto_calculate_vat_invoice; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER auto_calculate_vat_invoice BEFORE INSERT OR UPDATE OF subtotal, tax_rate, vat_liable, vat_regime ON public.invoices FOR EACH ROW EXECUTE FUNCTION public.calculate_vat();


--
-- Name: vehicle_inspections auto_generate_pdf_on_complete; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER auto_generate_pdf_on_complete AFTER INSERT OR UPDATE OF client_signature, driver_signature ON public.vehicle_inspections FOR EACH ROW WHEN (((new.client_signature IS NOT NULL) AND (new.driver_signature IS NOT NULL))) EXECUTE FUNCTION public.trigger_combined_pdf_generation();


--
-- Name: invoices auto_legal_mentions_invoice; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER auto_legal_mentions_invoice BEFORE INSERT OR UPDATE OF vat_regime, vat_liable ON public.invoices FOR EACH ROW EXECUTE FUNCTION public.auto_fill_legal_mentions();


--
-- Name: availability_calendar availability_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER availability_updated_at BEFORE UPDATE ON public.availability_calendar FOR EACH ROW EXECUTE FUNCTION public.update_availability_timestamp();


--
-- Name: carpooling_trips check_full_status; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER check_full_status AFTER UPDATE OF available_seats ON public.carpooling_trips FOR EACH ROW EXECUTE FUNCTION public.check_trip_full();


--
-- Name: inspection_photos inspection_photos_delete; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER inspection_photos_delete INSTEAD OF DELETE ON public.inspection_photos FOR EACH ROW EXECUTE FUNCTION public.inspection_photos_delete_trigger();


--
-- Name: inspection_photos inspection_photos_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER inspection_photos_insert INSTEAD OF INSERT ON public.inspection_photos FOR EACH ROW EXECUTE FUNCTION public.inspection_photos_insert_trigger();


--
-- Name: inspection_photos inspection_photos_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER inspection_photos_update INSTEAD OF UPDATE ON public.inspection_photos FOR EACH ROW EXECUTE FUNCTION public.inspection_photos_update_trigger();


--
-- Name: subscriptions on_subscription_expired; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER on_subscription_expired AFTER UPDATE ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION public.trigger_reset_credits_on_expiration();


--
-- Name: pricing_grids pricing_grids_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER pricing_grids_updated_at BEFORE UPDATE ON public.pricing_grids FOR EACH ROW EXECUTE FUNCTION public.update_pricing_grids_updated_at();


--
-- Name: profiles protect_is_admin_modification; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER protect_is_admin_modification BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.prevent_is_admin_self_modification();


--
-- Name: TRIGGER protect_is_admin_modification ON profiles; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TRIGGER protect_is_admin_modification ON public.profiles IS 'Trigger de s√©curit√©: Bloque toute tentative de modification non autoris√©e de la colonne is_admin';


--
-- Name: quotes quote_accepted_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER quote_accepted_at BEFORE UPDATE ON public.quotes FOR EACH ROW EXECUTE FUNCTION public.update_quote_accepted_at();


--
-- Name: quotes quote_calculate_distance; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER quote_calculate_distance BEFORE INSERT OR UPDATE OF items ON public.quotes FOR EACH ROW EXECUTE FUNCTION public.calculate_quote_total_distance();


--
-- Name: quotes quote_converted_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER quote_converted_at BEFORE UPDATE ON public.quotes FOR EACH ROW EXECUTE FUNCTION public.update_quote_converted_at();


--
-- Name: quotes quote_rejected_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER quote_rejected_at BEFORE UPDATE ON public.quotes FOR EACH ROW EXECUTE FUNCTION public.update_quote_rejected_at();


--
-- Name: quotes quote_sent_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER quote_sent_at BEFORE UPDATE ON public.quotes FOR EACH ROW EXECUTE FUNCTION public.update_quote_sent_at();


--
-- Name: quotes quotes_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER quotes_updated_at BEFORE UPDATE ON public.quotes FOR EACH ROW EXECUTE FUNCTION public.update_quotes_updated_at();


--
-- Name: invoices sync_client_data_invoice; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER sync_client_data_invoice BEFORE INSERT OR UPDATE OF client_id ON public.invoices FOR EACH ROW WHEN ((new.client_id IS NOT NULL)) EXECUTE FUNCTION public.sync_client_data_to_invoice();


--
-- Name: invoices sync_invoice_date_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER sync_invoice_date_trigger BEFORE INSERT OR UPDATE ON public.invoices FOR EACH ROW EXECUTE FUNCTION public.sync_invoice_date();


--
-- Name: profiles sync_profile_credits_to_user_credits; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER sync_profile_credits_to_user_credits AFTER UPDATE OF credits ON public.profiles FOR EACH ROW WHEN ((old.credits IS DISTINCT FROM new.credits)) EXECUTE FUNCTION public.sync_credits_bidirectional();


--
-- Name: user_credits sync_user_credits_to_profile; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER sync_user_credits_to_profile AFTER UPDATE OF balance ON public.user_credits FOR EACH ROW WHEN ((old.balance IS DISTINCT FROM new.balance)) EXECUTE FUNCTION public.sync_credits_bidirectional();


--
-- Name: gps_tracking_sessions trg_auto_report; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_auto_report AFTER UPDATE ON public.gps_tracking_sessions FOR EACH ROW EXECUTE FUNCTION public.auto_generate_report_on_session_end();


--
-- Name: missions trg_auto_ride_offer; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_auto_ride_offer AFTER UPDATE OF status ON public.missions FOR EACH ROW EXECUTE FUNCTION public.auto_create_ride_offer_from_mission();


--
-- Name: calendar_events trg_cal_evt_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_cal_evt_updated BEFORE UPDATE ON public.calendar_events FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: calendar_permissions trg_cal_perm_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_cal_perm_updated BEFORE UPDATE ON public.calendar_permissions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: convoy_plannings trg_compute_expires_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_compute_expires_at BEFORE INSERT OR UPDATE OF planning_date, end_time, flexibility_minutes ON public.convoy_plannings FOR EACH ROW EXECUTE FUNCTION public.compute_planning_expires_at();


--
-- Name: vehicle_inspections trg_insp_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_insp_updated BEFORE UPDATE ON public.vehicle_inspections FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: planning_matches trg_notify_match_change; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_notify_match_change AFTER INSERT OR UPDATE OF status ON public.planning_matches FOR EACH ROW EXECUTE FUNCTION public.notify_on_match_change();


--
-- Name: planning_messages trg_notify_new_message; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_notify_new_message AFTER INSERT ON public.planning_messages FOR EACH ROW EXECUTE FUNCTION public.notify_on_new_message();


--
-- Name: ride_matches trg_notify_ride_match; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_notify_ride_match AFTER INSERT OR UPDATE OF status ON public.ride_matches FOR EACH ROW EXECUTE FUNCTION public.notify_on_ride_match_change();


--
-- Name: ride_messages trg_notify_ride_message; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_notify_ride_message AFTER INSERT ON public.ride_messages FOR EACH ROW EXECUTE FUNCTION public.notify_on_ride_message();


--
-- Name: inspections trg_prevent_locked_changes; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_prevent_locked_changes BEFORE UPDATE ON public.inspections FOR EACH ROW EXECUTE FUNCTION public.prevent_locked_inspection_changes();


--
-- Name: ride_matches trg_ride_match_status; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_ride_match_status AFTER UPDATE OF status ON public.ride_matches FOR EACH ROW EXECUTE FUNCTION public.handle_ride_match_status_change();


--
-- Name: ride_offers trg_set_offer_expiry; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_set_offer_expiry BEFORE INSERT OR UPDATE OF departure_date ON public.ride_offers FOR EACH ROW EXECUTE FUNCTION public.set_ride_expiration();


--
-- Name: ride_requests trg_set_request_expiry; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_set_request_expiry BEFORE INSERT OR UPDATE OF needed_date ON public.ride_requests FOR EACH ROW EXECUTE FUNCTION public.set_ride_expiration();


--
-- Name: gps_tracking_sessions trg_track_updated; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_track_updated BEFORE UPDATE ON public.gps_tracking_sessions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: profiles trg_update_profile_completion; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_update_profile_completion BEFORE INSERT OR UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.trigger_update_profile_completion();


--
-- Name: missions trigger_auto_generate_share_code; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_auto_generate_share_code BEFORE INSERT ON public.missions FOR EACH ROW WHEN ((new.share_code IS NULL)) EXECUTE FUNCTION public.auto_generate_share_code();


--
-- Name: TRIGGER trigger_auto_generate_share_code ON missions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TRIGGER trigger_auto_generate_share_code ON public.missions IS 'G√©n√®re automatiquement un code de partage √† la cr√©ation d''une mission';


--
-- Name: carpooling_bookings trigger_notify_booking_status_changed; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_notify_booking_status_changed AFTER UPDATE ON public.carpooling_bookings FOR EACH ROW EXECUTE FUNCTION public.notify_booking_status_changed();


--
-- Name: missions trigger_notify_mission_status_changed; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_notify_mission_status_changed AFTER UPDATE ON public.missions FOR EACH ROW EXECUTE FUNCTION public.notify_mission_status_changed();


--
-- Name: carpooling_bookings trigger_notify_new_booking_request; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_notify_new_booking_request AFTER INSERT ON public.carpooling_bookings FOR EACH ROW EXECUTE FUNCTION public.notify_new_booking_request();


--
-- Name: carpooling_messages trigger_notify_new_message; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_notify_new_message AFTER INSERT ON public.carpooling_messages FOR EACH ROW EXECUTE FUNCTION public.notify_new_message();


--
-- Name: user_credits trigger_sync_profile_credits; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_sync_profile_credits AFTER INSERT OR UPDATE OF balance ON public.user_credits FOR EACH ROW EXECUTE FUNCTION public.sync_profile_credits_from_user_credits();


--
-- Name: attachments trigger_update_attachments_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_attachments_updated_at BEFORE UPDATE ON public.attachments FOR EACH ROW EXECUTE FUNCTION public.update_attachments_updated_at();


--
-- Name: support_messages trigger_update_conversation_last_message; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_conversation_last_message AFTER INSERT ON public.support_messages FOR EACH ROW EXECUTE FUNCTION public.update_conversation_last_message();


--
-- Name: inspection_damages trigger_update_inspection_damages_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_inspection_damages_updated_at BEFORE UPDATE ON public.inspection_damages FOR EACH ROW EXECUTE FUNCTION public.update_inspection_damages_updated_at();


--
-- Name: navigation_sessions trigger_update_navigation_sessions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_navigation_sessions_updated_at BEFORE UPDATE ON public.navigation_sessions FOR EACH ROW EXECUTE FUNCTION public.update_navigation_sessions_updated_at();


--
-- Name: public_inspection_reports trigger_update_public_reports_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_public_reports_updated_at BEFORE UPDATE ON public.public_inspection_reports FOR EACH ROW EXECUTE FUNCTION public.update_public_reports_updated_at();


--
-- Name: mission_tracking_live trigger_update_tracking_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_tracking_updated_at BEFORE UPDATE ON public.mission_tracking_live FOR EACH ROW EXECUTE FUNCTION public.update_tracking_updated_at();


--
-- Name: carpooling_messages trigger_update_trip_on_message; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_trip_on_message AFTER INSERT ON public.carpooling_messages FOR EACH ROW EXECUTE FUNCTION public.update_trip_on_message();


--
-- Name: unified_scanned_documents trigger_update_unified_docs_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_unified_docs_updated_at BEFORE UPDATE ON public.unified_scanned_documents FOR EACH ROW EXECUTE FUNCTION public.update_unified_docs_updated_at();


--
-- Name: user_devices trigger_update_user_devices_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_user_devices_updated_at BEFORE UPDATE ON public.user_devices FOR EACH ROW EXECUTE FUNCTION public.update_user_devices_updated_at();


--
-- Name: carpooling_bookings update_carpooling_bookings_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_carpooling_bookings_updated_at BEFORE UPDATE ON public.carpooling_bookings FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: carpooling_trips update_carpooling_trips_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_carpooling_trips_updated_at BEFORE UPDATE ON public.carpooling_trips FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: clients update_clients_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_clients_updated_at BEFORE UPDATE ON public.clients FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: contact_requests update_contact_requests_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_contact_requests_updated_at BEFORE UPDATE ON public.contact_requests FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: covoiturage_trips update_covoiturage_trips_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_covoiturage_trips_updated_at BEFORE UPDATE ON public.covoiturage_trips FOR EACH ROW EXECUTE FUNCTION public.update_covoiturage_updated_at();


--
-- Name: covoiturage_trips update_driver_stats_on_trip; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_driver_stats_on_trip AFTER INSERT ON public.covoiturage_trips FOR EACH ROW WHEN (((new.status)::text = 'published'::text)) EXECUTE FUNCTION public.update_driver_stats();


--
-- Name: inspection_documents update_inspection_documents_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_inspection_documents_updated_at BEFORE UPDATE ON public.inspection_documents FOR EACH ROW EXECUTE FUNCTION public.update_inspection_documents_updated_at();


--
-- Name: missions update_missions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_missions_updated_at BEFORE UPDATE ON public.missions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: profiles update_profiles_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: user_push_tokens update_push_tokens_updated_at_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_push_tokens_updated_at_trigger BEFORE UPDATE ON public.user_push_tokens FOR EACH ROW EXECUTE FUNCTION public.update_push_tokens_updated_at();


--
-- Name: carpooling_bookings update_seats_on_booking; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_seats_on_booking AFTER INSERT OR UPDATE ON public.carpooling_bookings FOR EACH ROW EXECUTE FUNCTION public.update_trip_available_seats();


--
-- Name: shop_quote_requests update_shop_quote_requests_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_shop_quote_requests_updated_at BEFORE UPDATE ON public.shop_quote_requests FOR EACH ROW EXECUTE FUNCTION public.update_shop_quote_requests_updated_at();


--
-- Name: subscriptions update_subscriptions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION public.update_subscription_updated_at();


--
-- Name: subscription tr_check_filters; Type: TRIGGER; Schema: realtime; Owner: supabase_admin
--

CREATE TRIGGER tr_check_filters BEFORE INSERT OR UPDATE ON realtime.subscription FOR EACH ROW EXECUTE FUNCTION realtime.subscription_check_filters();


--
-- Name: buckets enforce_bucket_name_length_trigger; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER enforce_bucket_name_length_trigger BEFORE INSERT OR UPDATE OF name ON storage.buckets FOR EACH ROW EXECUTE FUNCTION storage.enforce_bucket_name_length();


--
-- Name: buckets protect_buckets_delete; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER protect_buckets_delete BEFORE DELETE ON storage.buckets FOR EACH STATEMENT EXECUTE FUNCTION storage.protect_delete();


--
-- Name: objects protect_objects_delete; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER protect_objects_delete BEFORE DELETE ON storage.objects FOR EACH STATEMENT EXECUTE FUNCTION storage.protect_delete();


--
-- Name: objects update_objects_updated_at; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER update_objects_updated_at BEFORE UPDATE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column();


--
-- Name: identities identities_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: mfa_amr_claims mfa_amr_claims_session_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE;


--
-- Name: mfa_challenges mfa_challenges_auth_factor_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_auth_factor_id_fkey FOREIGN KEY (factor_id) REFERENCES auth.mfa_factors(id) ON DELETE CASCADE;


--
-- Name: mfa_factors mfa_factors_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: oauth_authorizations oauth_authorizations_client_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_client_id_fkey FOREIGN KEY (client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE;


--
-- Name: oauth_authorizations oauth_authorizations_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: oauth_consents oauth_consents_client_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_client_id_fkey FOREIGN KEY (client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE;


--
-- Name: oauth_consents oauth_consents_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: one_time_tokens one_time_tokens_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: refresh_tokens refresh_tokens_session_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE;


--
-- Name: saml_providers saml_providers_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: saml_relay_states saml_relay_states_flow_state_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_flow_state_id_fkey FOREIGN KEY (flow_state_id) REFERENCES auth.flow_state(id) ON DELETE CASCADE;


--
-- Name: saml_relay_states saml_relay_states_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: sessions sessions_oauth_client_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_oauth_client_id_fkey FOREIGN KEY (oauth_client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE;


--
-- Name: sessions sessions_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: sso_domains sso_domains_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_domains
    ADD CONSTRAINT sso_domains_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: account_creation_attempts account_creation_attempts_existing_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.account_creation_attempts
    ADD CONSTRAINT account_creation_attempts_existing_user_id_fkey FOREIGN KEY (existing_user_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: app_versions app_versions_uploaded_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.app_versions
    ADD CONSTRAINT app_versions_uploaded_by_fkey FOREIGN KEY (uploaded_by) REFERENCES auth.users(id);


--
-- Name: attachments attachments_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attachments
    ADD CONSTRAINT attachments_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: availability_calendar availability_calendar_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.availability_calendar
    ADD CONSTRAINT availability_calendar_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: calendar_events calendar_events_created_by_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.calendar_events
    ADD CONSTRAINT calendar_events_created_by_id_fkey FOREIGN KEY (created_by_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: calendar_events calendar_events_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.calendar_events
    ADD CONSTRAINT calendar_events_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE SET NULL;


--
-- Name: calendar_events calendar_events_owner_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.calendar_events
    ADD CONSTRAINT calendar_events_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: calendar_permissions calendar_permissions_owner_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.calendar_permissions
    ADD CONSTRAINT calendar_permissions_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: calendar_permissions calendar_permissions_shared_with_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.calendar_permissions
    ADD CONSTRAINT calendar_permissions_shared_with_id_fkey FOREIGN KEY (shared_with_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: carpooling_bookings carpooling_bookings_passenger_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carpooling_bookings
    ADD CONSTRAINT carpooling_bookings_passenger_id_fkey FOREIGN KEY (passenger_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: carpooling_bookings carpooling_bookings_trip_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carpooling_bookings
    ADD CONSTRAINT carpooling_bookings_trip_id_fkey FOREIGN KEY (trip_id) REFERENCES public.carpooling_trips(id) ON DELETE CASCADE;


--
-- Name: carpooling_messages carpooling_messages_receiver_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carpooling_messages
    ADD CONSTRAINT carpooling_messages_receiver_id_fkey FOREIGN KEY (receiver_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: carpooling_messages carpooling_messages_sender_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carpooling_messages
    ADD CONSTRAINT carpooling_messages_sender_id_fkey FOREIGN KEY (sender_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: carpooling_trips carpooling_trips_driver_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carpooling_trips
    ADD CONSTRAINT carpooling_trips_driver_id_fkey FOREIGN KEY (driver_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: clients clients_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.clients
    ADD CONSTRAINT clients_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: contact_requests contact_requests_requester_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contact_requests
    ADD CONSTRAINT contact_requests_requester_id_fkey FOREIGN KEY (requester_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: contacts contacts_invited_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contacts
    ADD CONSTRAINT contacts_invited_by_fkey FOREIGN KEY (invited_by) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: contacts contacts_invited_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contacts
    ADD CONSTRAINT contacts_invited_user_id_fkey FOREIGN KEY (invited_user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: contacts contacts_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contacts
    ADD CONSTRAINT contacts_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: convoy_plannings convoy_plannings_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.convoy_plannings
    ADD CONSTRAINT convoy_plannings_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: covoiturage_trips covoiturage_trips_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.covoiturage_trips
    ADD CONSTRAINT covoiturage_trips_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: credit_transactions credit_transactions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.credit_transactions
    ADD CONSTRAINT credit_transactions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: deletion_requests deletion_requests_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.deletion_requests
    ADD CONSTRAINT deletion_requests_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: documents documents_inspection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.documents
    ADD CONSTRAINT documents_inspection_id_fkey FOREIGN KEY (inspection_id) REFERENCES public.inspections(id) ON DELETE SET NULL;


--
-- Name: documents documents_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.documents
    ADD CONSTRAINT documents_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE SET NULL;


--
-- Name: documents documents_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.documents
    ADD CONSTRAINT documents_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: missions fk_missions_assigned_to_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.missions
    ADD CONSTRAINT fk_missions_assigned_to_user FOREIGN KEY (assigned_user_id) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: gps_location_points gps_location_points_session_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gps_location_points
    ADD CONSTRAINT gps_location_points_session_id_fkey FOREIGN KEY (session_id) REFERENCES public.gps_tracking_sessions(id) ON DELETE CASCADE;


--
-- Name: gps_tracking_sessions gps_tracking_sessions_arrival_inspection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gps_tracking_sessions
    ADD CONSTRAINT gps_tracking_sessions_arrival_inspection_id_fkey FOREIGN KEY (arrival_inspection_id) REFERENCES public.vehicle_inspections(id) ON DELETE SET NULL;


--
-- Name: gps_tracking_sessions gps_tracking_sessions_departure_inspection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gps_tracking_sessions
    ADD CONSTRAINT gps_tracking_sessions_departure_inspection_id_fkey FOREIGN KEY (departure_inspection_id) REFERENCES public.vehicle_inspections(id) ON DELETE SET NULL;


--
-- Name: gps_tracking_sessions gps_tracking_sessions_driver_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gps_tracking_sessions
    ADD CONSTRAINT gps_tracking_sessions_driver_id_fkey FOREIGN KEY (driver_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: gps_tracking_sessions gps_tracking_sessions_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gps_tracking_sessions
    ADD CONSTRAINT gps_tracking_sessions_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: inspection_damages inspection_damages_inspection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_damages
    ADD CONSTRAINT inspection_damages_inspection_id_fkey FOREIGN KEY (inspection_id) REFERENCES public.vehicle_inspections(id) ON DELETE CASCADE;


--
-- Name: inspection_documents inspection_documents_inspection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_documents
    ADD CONSTRAINT inspection_documents_inspection_id_fkey FOREIGN KEY (inspection_id) REFERENCES public.vehicle_inspections(id) ON DELETE CASCADE;


--
-- Name: inspection_expenses inspection_expenses_inspection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_expenses
    ADD CONSTRAINT inspection_expenses_inspection_id_fkey FOREIGN KEY (inspection_id) REFERENCES public.vehicle_inspections(id) ON DELETE CASCADE;


--
-- Name: inspection_pdfs inspection_pdfs_inspection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_pdfs
    ADD CONSTRAINT inspection_pdfs_inspection_id_fkey FOREIGN KEY (inspection_id) REFERENCES public.vehicle_inspections(id) ON DELETE CASCADE;


--
-- Name: inspection_pdfs inspection_pdfs_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_pdfs
    ADD CONSTRAINT inspection_pdfs_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id);


--
-- Name: inspection_photos_v2 inspection_photos_v2_inspection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_photos_v2
    ADD CONSTRAINT inspection_photos_v2_inspection_id_fkey FOREIGN KEY (inspection_id) REFERENCES public.vehicle_inspections(id) ON DELETE CASCADE;


--
-- Name: inspection_report_shares inspection_report_shares_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_report_shares
    ADD CONSTRAINT inspection_report_shares_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: inspection_report_shares inspection_report_shares_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspection_report_shares
    ADD CONSTRAINT inspection_report_shares_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: inspections inspections_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspections
    ADD CONSTRAINT inspections_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: inspections inspections_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.inspections
    ADD CONSTRAINT inspections_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: invoice_items invoice_items_invoice_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_items
    ADD CONSTRAINT invoice_items_invoice_id_fkey FOREIGN KEY (invoice_id) REFERENCES public.invoices(id) ON DELETE CASCADE;


--
-- Name: invoices invoices_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE SET NULL;


--
-- Name: invoices invoices_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE SET NULL;


--
-- Name: invoices invoices_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: mission_assignments mission_assignments_assigned_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_assignments
    ADD CONSTRAINT mission_assignments_assigned_by_fkey FOREIGN KEY (assigned_by) REFERENCES public.profiles(id);


--
-- Name: mission_assignments mission_assignments_contact_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_assignments
    ADD CONSTRAINT mission_assignments_contact_id_fkey FOREIGN KEY (contact_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: mission_assignments mission_assignments_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_assignments
    ADD CONSTRAINT mission_assignments_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: mission_assignments mission_assignments_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_assignments
    ADD CONSTRAINT mission_assignments_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: mission_locations mission_locations_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_locations
    ADD CONSTRAINT mission_locations_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: mission_revenue_logs mission_revenue_logs_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_revenue_logs
    ADD CONSTRAINT mission_revenue_logs_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: mission_revenue_logs mission_revenue_logs_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_revenue_logs
    ADD CONSTRAINT mission_revenue_logs_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: mission_tracking_history mission_tracking_history_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_tracking_history
    ADD CONSTRAINT mission_tracking_history_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: mission_tracking_history mission_tracking_history_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_tracking_history
    ADD CONSTRAINT mission_tracking_history_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id);


--
-- Name: mission_tracking_live mission_tracking_live_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_tracking_live
    ADD CONSTRAINT mission_tracking_live_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: mission_tracking_live mission_tracking_live_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mission_tracking_live
    ADD CONSTRAINT mission_tracking_live_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: missions missions_assigned_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.missions
    ADD CONSTRAINT missions_assigned_user_id_fkey FOREIGN KEY (assigned_user_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: missions missions_driver_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.missions
    ADD CONSTRAINT missions_driver_id_fkey FOREIGN KEY (driver_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: missions missions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.missions
    ADD CONSTRAINT missions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: navigation_sessions navigation_sessions_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.navigation_sessions
    ADD CONSTRAINT navigation_sessions_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: notifications notifications_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: planning_matches planning_matches_planning_a_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_matches
    ADD CONSTRAINT planning_matches_planning_a_id_fkey FOREIGN KEY (planning_a_id) REFERENCES public.convoy_plannings(id) ON DELETE CASCADE;


--
-- Name: planning_matches planning_matches_planning_b_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_matches
    ADD CONSTRAINT planning_matches_planning_b_id_fkey FOREIGN KEY (planning_b_id) REFERENCES public.convoy_plannings(id) ON DELETE CASCADE;


--
-- Name: planning_matches planning_matches_user_a_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_matches
    ADD CONSTRAINT planning_matches_user_a_id_fkey FOREIGN KEY (user_a_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: planning_matches planning_matches_user_b_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_matches
    ADD CONSTRAINT planning_matches_user_b_id_fkey FOREIGN KEY (user_b_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: planning_messages planning_messages_match_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_messages
    ADD CONSTRAINT planning_messages_match_id_fkey FOREIGN KEY (match_id) REFERENCES public.planning_matches(id) ON DELETE CASCADE;


--
-- Name: planning_messages planning_messages_sender_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_messages
    ADD CONSTRAINT planning_messages_sender_id_fkey FOREIGN KEY (sender_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: planning_notifications planning_notifications_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_notifications
    ADD CONSTRAINT planning_notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: planning_stats planning_stats_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_stats
    ADD CONSTRAINT planning_stats_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: planning_waypoints planning_waypoints_planning_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.planning_waypoints
    ADD CONSTRAINT planning_waypoints_planning_id_fkey FOREIGN KEY (planning_id) REFERENCES public.convoy_plannings(id) ON DELETE CASCADE;


--
-- Name: pricing_grids pricing_grids_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pricing_grids
    ADD CONSTRAINT pricing_grids_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE CASCADE;


--
-- Name: pricing_grids pricing_grids_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pricing_grids
    ADD CONSTRAINT pricing_grids_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: profiles profiles_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: public_inspection_reports public_inspection_reports_arrival_inspection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.public_inspection_reports
    ADD CONSTRAINT public_inspection_reports_arrival_inspection_id_fkey FOREIGN KEY (arrival_inspection_id) REFERENCES public.vehicle_inspections(id) ON DELETE SET NULL;


--
-- Name: public_inspection_reports public_inspection_reports_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.public_inspection_reports
    ADD CONSTRAINT public_inspection_reports_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: public_inspection_reports public_inspection_reports_departure_inspection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.public_inspection_reports
    ADD CONSTRAINT public_inspection_reports_departure_inspection_id_fkey FOREIGN KEY (departure_inspection_id) REFERENCES public.vehicle_inspections(id) ON DELETE SET NULL;


--
-- Name: public_inspection_reports public_inspection_reports_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.public_inspection_reports
    ADD CONSTRAINT public_inspection_reports_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: public_tracking_links public_tracking_links_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.public_tracking_links
    ADD CONSTRAINT public_tracking_links_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: push_tokens push_tokens_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.push_tokens
    ADD CONSTRAINT push_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: quotes quotes_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.quotes
    ADD CONSTRAINT quotes_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE CASCADE;


--
-- Name: quotes quotes_converted_invoice_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.quotes
    ADD CONSTRAINT quotes_converted_invoice_id_fkey FOREIGN KEY (converted_invoice_id) REFERENCES public.invoices(id) ON DELETE SET NULL;


--
-- Name: quotes quotes_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.quotes
    ADD CONSTRAINT quotes_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE SET NULL;


--
-- Name: quotes quotes_pricing_grid_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.quotes
    ADD CONSTRAINT quotes_pricing_grid_id_fkey FOREIGN KEY (pricing_grid_id) REFERENCES public.pricing_grids(id) ON DELETE SET NULL;


--
-- Name: quotes quotes_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.quotes
    ADD CONSTRAINT quotes_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: ride_matches ride_matches_driver_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_matches
    ADD CONSTRAINT ride_matches_driver_id_fkey FOREIGN KEY (driver_id) REFERENCES auth.users(id);


--
-- Name: ride_matches ride_matches_offer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_matches
    ADD CONSTRAINT ride_matches_offer_id_fkey FOREIGN KEY (offer_id) REFERENCES public.ride_offers(id) ON DELETE CASCADE;


--
-- Name: ride_matches ride_matches_passenger_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_matches
    ADD CONSTRAINT ride_matches_passenger_id_fkey FOREIGN KEY (passenger_id) REFERENCES auth.users(id);


--
-- Name: ride_matches ride_matches_request_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_matches
    ADD CONSTRAINT ride_matches_request_id_fkey FOREIGN KEY (request_id) REFERENCES public.ride_requests(id) ON DELETE CASCADE;


--
-- Name: ride_messages ride_messages_match_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_messages
    ADD CONSTRAINT ride_messages_match_id_fkey FOREIGN KEY (match_id) REFERENCES public.ride_matches(id) ON DELETE CASCADE;


--
-- Name: ride_messages ride_messages_sender_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_messages
    ADD CONSTRAINT ride_messages_sender_id_fkey FOREIGN KEY (sender_id) REFERENCES auth.users(id);


--
-- Name: ride_offers ride_offers_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_offers
    ADD CONSTRAINT ride_offers_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE SET NULL;


--
-- Name: ride_offers ride_offers_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_offers
    ADD CONSTRAINT ride_offers_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: ride_ratings ride_ratings_match_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_ratings
    ADD CONSTRAINT ride_ratings_match_id_fkey FOREIGN KEY (match_id) REFERENCES public.ride_matches(id) ON DELETE CASCADE;


--
-- Name: ride_ratings ride_ratings_rated_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_ratings
    ADD CONSTRAINT ride_ratings_rated_id_fkey FOREIGN KEY (rated_id) REFERENCES auth.users(id);


--
-- Name: ride_ratings ride_ratings_rater_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_ratings
    ADD CONSTRAINT ride_ratings_rater_id_fkey FOREIGN KEY (rater_id) REFERENCES auth.users(id);


--
-- Name: ride_requests ride_requests_completed_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_requests
    ADD CONSTRAINT ride_requests_completed_mission_id_fkey FOREIGN KEY (completed_mission_id) REFERENCES public.missions(id) ON DELETE SET NULL;


--
-- Name: ride_requests ride_requests_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ride_requests
    ADD CONSTRAINT ride_requests_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: shop_quote_requests shop_quote_requests_responded_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.shop_quote_requests
    ADD CONSTRAINT shop_quote_requests_responded_by_fkey FOREIGN KEY (responded_by) REFERENCES auth.users(id);


--
-- Name: shop_quote_requests shop_quote_requests_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.shop_quote_requests
    ADD CONSTRAINT shop_quote_requests_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: subscriptions subscriptions_assigned_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_assigned_by_fkey FOREIGN KEY (assigned_by) REFERENCES public.profiles(id);


--
-- Name: subscriptions subscriptions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: support_conversations support_conversations_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.support_conversations
    ADD CONSTRAINT support_conversations_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: support_messages support_messages_conversation_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.support_messages
    ADD CONSTRAINT support_messages_conversation_id_fkey FOREIGN KEY (conversation_id) REFERENCES public.support_conversations(id) ON DELETE CASCADE;


--
-- Name: support_messages support_messages_sender_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.support_messages
    ADD CONSTRAINT support_messages_sender_id_fkey FOREIGN KEY (sender_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: support_tickets support_tickets_assigned_to_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.support_tickets
    ADD CONSTRAINT support_tickets_assigned_to_fkey FOREIGN KEY (assigned_to) REFERENCES public.profiles(id);


--
-- Name: support_tickets support_tickets_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.support_tickets
    ADD CONSTRAINT support_tickets_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: suspicious_accounts suspicious_accounts_reviewed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.suspicious_accounts
    ADD CONSTRAINT suspicious_accounts_reviewed_by_fkey FOREIGN KEY (reviewed_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: transactions transactions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: unified_scanned_documents unified_scanned_documents_inspection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.unified_scanned_documents
    ADD CONSTRAINT unified_scanned_documents_inspection_id_fkey FOREIGN KEY (inspection_id) REFERENCES public.inspections(id) ON DELETE SET NULL;


--
-- Name: unified_scanned_documents unified_scanned_documents_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.unified_scanned_documents
    ADD CONSTRAINT unified_scanned_documents_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: user_consents user_consents_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_consents
    ADD CONSTRAINT user_consents_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: user_credits user_credits_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_credits
    ADD CONSTRAINT user_credits_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: user_devices user_devices_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_devices
    ADD CONSTRAINT user_devices_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: user_push_tokens user_push_tokens_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_push_tokens
    ADD CONSTRAINT user_push_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: vehicle_inspections vehicle_inspections_inspector_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vehicle_inspections
    ADD CONSTRAINT vehicle_inspections_inspector_id_fkey FOREIGN KEY (inspector_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: vehicle_inspections vehicle_inspections_mission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vehicle_inspections
    ADD CONSTRAINT vehicle_inspections_mission_id_fkey FOREIGN KEY (mission_id) REFERENCES public.missions(id) ON DELETE CASCADE;


--
-- Name: objects objects_bucketId_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.objects
    ADD CONSTRAINT "objects_bucketId_fkey" FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads s3_multipart_uploads_bucket_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_bucket_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_upload_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_upload_id_fkey FOREIGN KEY (upload_id) REFERENCES storage.s3_multipart_uploads(id) ON DELETE CASCADE;


--
-- Name: vector_indexes vector_indexes_bucket_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.vector_indexes
    ADD CONSTRAINT vector_indexes_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets_vectors(id);


--
-- Name: audit_log_entries; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.audit_log_entries ENABLE ROW LEVEL SECURITY;

--
-- Name: flow_state; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.flow_state ENABLE ROW LEVEL SECURITY;

--
-- Name: identities; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.identities ENABLE ROW LEVEL SECURITY;

--
-- Name: instances; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.instances ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_amr_claims; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_amr_claims ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_challenges; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_challenges ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_factors; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_factors ENABLE ROW LEVEL SECURITY;

--
-- Name: one_time_tokens; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.one_time_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: refresh_tokens; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.refresh_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: saml_providers; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.saml_providers ENABLE ROW LEVEL SECURITY;

--
-- Name: saml_relay_states; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.saml_relay_states ENABLE ROW LEVEL SECURITY;

--
-- Name: schema_migrations; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.schema_migrations ENABLE ROW LEVEL SECURITY;

--
-- Name: sessions; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sessions ENABLE ROW LEVEL SECURITY;

--
-- Name: sso_domains; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sso_domains ENABLE ROW LEVEL SECURITY;

--
-- Name: sso_providers; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sso_providers ENABLE ROW LEVEL SECURITY;

--
-- Name: users; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.users ENABLE ROW LEVEL SECURITY;

--
-- Name: subscriptions Admin full access to subscriptions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admin full access to subscriptions" ON public.subscriptions USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: subscriptions Admins can delete subscriptions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can delete subscriptions" ON public.subscriptions FOR DELETE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: subscriptions Admins can insert subscriptions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can insert subscriptions" ON public.subscriptions FOR INSERT TO authenticated WITH CHECK ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: app_versions Admins can manage versions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can manage versions" ON public.app_versions USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: support_messages Admins can send messages in all conversations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can send messages in all conversations" ON public.support_messages FOR INSERT TO authenticated WITH CHECK ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: support_conversations Admins can update all conversations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update all conversations" ON public.support_conversations FOR UPDATE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: shop_quote_requests Admins can update quote requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update quote requests" ON public.shop_quote_requests FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: subscriptions Admins can update subscriptions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update subscriptions" ON public.subscriptions FOR UPDATE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: support_conversations Admins can view all conversations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can view all conversations" ON public.support_conversations FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: user_devices Admins can view all devices; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can view all devices" ON public.user_devices FOR SELECT USING ((EXISTS ( SELECT 1
   FROM auth.users u
  WHERE ((u.id = auth.uid()) AND ((u.raw_user_meta_data ->> 'role'::text) = 'admin'::text)))));


--
-- Name: support_messages Admins can view all messages; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can view all messages" ON public.support_messages FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: shop_quote_requests Admins can view all quote requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can view all quote requests" ON public.shop_quote_requests FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: subscriptions Admins can view all subscriptions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can view all subscriptions" ON public.subscriptions FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: inspection_damages Admins have full access to damages; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins have full access to damages" ON public.inspection_damages USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: support_tickets Admins update tickets; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins update tickets" ON public.support_tickets FOR UPDATE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: support_tickets Admins view all tickets; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins view all tickets" ON public.support_tickets FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: signup_attempts Anyone can insert signup attempts; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Anyone can insert signup attempts" ON public.signup_attempts FOR INSERT TO authenticated, anon WITH CHECK (true);


--
-- Name: app_versions Anyone can read active versions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Anyone can read active versions" ON public.app_versions FOR SELECT USING ((is_active = true));


--
-- Name: ride_offers Anyone can view active offers; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Anyone can view active offers" ON public.ride_offers FOR SELECT USING (((status = ANY (ARRAY['active'::text, 'en_route'::text])) OR (auth.uid() = user_id)));


--
-- Name: ride_requests Anyone can view active requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Anyone can view active requests" ON public.ride_requests FOR SELECT USING (((status = 'active'::text) OR (auth.uid() = user_id)));


--
-- Name: shop_items Anyone can view active shop items; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Anyone can view active shop items" ON public.shop_items FOR SELECT TO authenticated USING ((is_active = true));


--
-- Name: public_tracking_links Anyone can view active tracking links; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Anyone can view active tracking links" ON public.public_tracking_links FOR SELECT USING (((is_active = true) AND (expires_at > now())));


--
-- Name: ride_ratings Anyone can view ratings; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Anyone can view ratings" ON public.ride_ratings FOR SELECT USING (true);


--
-- Name: public_inspection_reports Authenticated users can create public reports; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Authenticated users can create public reports" ON public.public_inspection_reports FOR INSERT WITH CHECK ((auth.role() = 'authenticated'::text));


--
-- Name: mission_assignments Contacts can view their assignments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Contacts can view their assignments" ON public.mission_assignments FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.contacts
  WHERE ((contacts.id = mission_assignments.contact_id) AND (contacts.user_id = auth.uid())))));


--
-- Name: carpooling_trips Cr√©er un trajet; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Cr√©er un trajet" ON public.carpooling_trips FOR INSERT TO authenticated WITH CHECK ((driver_id = auth.uid()));


--
-- Name: carpooling_bookings Drivers can update bookings for their trips; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Drivers can update bookings for their trips" ON public.carpooling_bookings FOR UPDATE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.carpooling_trips
  WHERE ((carpooling_trips.id = carpooling_bookings.trip_id) AND (carpooling_trips.driver_id = auth.uid()))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM public.carpooling_trips
  WHERE ((carpooling_trips.id = carpooling_bookings.trip_id) AND (carpooling_trips.driver_id = auth.uid())))));


--
-- Name: carpooling_bookings Drivers can view bookings for their trips; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Drivers can view bookings for their trips" ON public.carpooling_bookings FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.carpooling_trips
  WHERE ((carpooling_trips.id = carpooling_bookings.trip_id) AND (carpooling_trips.driver_id = auth.uid())))));


--
-- Name: inspection_expenses Expenses - DELETE own or assigned; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Expenses - DELETE own or assigned" ON public.inspection_expenses FOR DELETE TO authenticated USING ((EXISTS ( SELECT 1
   FROM (public.vehicle_inspections vi
     JOIN public.missions m ON ((m.id = vi.mission_id)))
  WHERE ((vi.id = inspection_expenses.inspection_id) AND ((m.user_id = auth.uid()) OR (m.assigned_user_id = auth.uid()))))));


--
-- Name: inspection_expenses Expenses - INSERT own or assigned; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Expenses - INSERT own or assigned" ON public.inspection_expenses FOR INSERT TO authenticated WITH CHECK ((EXISTS ( SELECT 1
   FROM (public.vehicle_inspections vi
     JOIN public.missions m ON ((m.id = vi.mission_id)))
  WHERE ((vi.id = inspection_expenses.inspection_id) AND ((m.user_id = auth.uid()) OR (m.assigned_user_id = auth.uid()))))));


--
-- Name: inspection_expenses Expenses - SELECT own or assigned; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Expenses - SELECT own or assigned" ON public.inspection_expenses FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM (public.vehicle_inspections vi
     JOIN public.missions m ON ((m.id = vi.mission_id)))
  WHERE ((vi.id = inspection_expenses.inspection_id) AND ((m.user_id = auth.uid()) OR (m.assigned_user_id = auth.uid()))))));


--
-- Name: inspection_expenses Expenses - UPDATE own or assigned; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Expenses - UPDATE own or assigned" ON public.inspection_expenses FOR UPDATE TO authenticated USING ((EXISTS ( SELECT 1
   FROM (public.vehicle_inspections vi
     JOIN public.missions m ON ((m.id = vi.mission_id)))
  WHERE ((vi.id = inspection_expenses.inspection_id) AND ((m.user_id = auth.uid()) OR (m.assigned_user_id = auth.uid()))))));


--
-- Name: covoiturage_trips Les conducteurs peuvent modifier leurs trajets; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Les conducteurs peuvent modifier leurs trajets" ON public.covoiturage_trips FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: covoiturage_trips Les conducteurs peuvent supprimer leurs trajets; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Les conducteurs peuvent supprimer leurs trajets" ON public.covoiturage_trips FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: covoiturage_trips Les utilisateurs peuvent cr√©er leurs trajets; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Les utilisateurs peuvent cr√©er leurs trajets" ON public.covoiturage_trips FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: planning_messages Match participants can send messages; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Match participants can send messages" ON public.planning_messages FOR INSERT WITH CHECK (((auth.uid() = sender_id) AND (EXISTS ( SELECT 1
   FROM public.planning_matches pm
  WHERE ((pm.id = planning_messages.match_id) AND (pm.status = 'accepted'::text) AND ((pm.user_a_id = auth.uid()) OR (pm.user_b_id = auth.uid())))))));


--
-- Name: ride_messages Match participants can send messages; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Match participants can send messages" ON public.ride_messages FOR INSERT WITH CHECK (((auth.uid() = sender_id) AND (EXISTS ( SELECT 1
   FROM public.ride_matches
  WHERE ((ride_matches.id = ride_messages.match_id) AND (ride_matches.status = 'accepted'::text) AND ((ride_matches.driver_id = auth.uid()) OR (ride_matches.passenger_id = auth.uid())))))));


--
-- Name: ride_matches Match participants can view; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Match participants can view" ON public.ride_matches FOR SELECT USING (((auth.uid() = driver_id) OR (auth.uid() = passenger_id)));


--
-- Name: planning_messages Match participants can view messages; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Match participants can view messages" ON public.planning_messages FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.planning_matches pm
  WHERE ((pm.id = planning_messages.match_id) AND ((pm.user_a_id = auth.uid()) OR (pm.user_b_id = auth.uid()))))));


--
-- Name: ride_messages Match participants can view messages; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Match participants can view messages" ON public.ride_messages FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.ride_matches
  WHERE ((ride_matches.id = ride_messages.match_id) AND ((ride_matches.driver_id = auth.uid()) OR (ride_matches.passenger_id = auth.uid()))))));


--
-- Name: public_tracking_links Mission owners can create tracking links; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Mission owners can create tracking links" ON public.public_tracking_links FOR INSERT WITH CHECK ((mission_id IN ( SELECT missions.id
   FROM public.missions
  WHERE (missions.user_id = auth.uid()))));


--
-- Name: public_tracking_links Mission owners can update tracking links; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Mission owners can update tracking links" ON public.public_tracking_links FOR UPDATE USING ((mission_id IN ( SELECT missions.id
   FROM public.missions
  WHERE (missions.user_id = auth.uid()))));


--
-- Name: carpooling_trips Modifier son trajet; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Modifier son trajet" ON public.carpooling_trips FOR UPDATE TO authenticated USING ((driver_id = auth.uid())) WITH CHECK ((driver_id = auth.uid()));


--
-- Name: suspicious_accounts Only admins can update suspicious accounts; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Only admins can update suspicious accounts" ON public.suspicious_accounts FOR UPDATE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: account_creation_attempts Only admins can view account attempts; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Only admins can view account attempts" ON public.account_creation_attempts FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: suspicious_accounts Only admins can view suspicious accounts; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Only admins can view suspicious accounts" ON public.suspicious_accounts FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true)))));


--
-- Name: carpooling_bookings Own bookings; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Own bookings" ON public.carpooling_bookings USING ((auth.uid() = passenger_id));


--
-- Name: user_credits Own credits; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Own credits" ON public.user_credits USING ((auth.uid() = user_id));


--
-- Name: ride_matches Participants can update matches; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Participants can update matches" ON public.ride_matches FOR UPDATE USING (((auth.uid() = driver_id) OR (auth.uid() = passenger_id)));


--
-- Name: carpooling_bookings Passengers can delete own bookings; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Passengers can delete own bookings" ON public.carpooling_bookings FOR DELETE TO authenticated USING ((passenger_id = auth.uid()));


--
-- Name: carpooling_bookings Passengers can update own bookings; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Passengers can update own bookings" ON public.carpooling_bookings FOR UPDATE TO authenticated USING ((passenger_id = auth.uid())) WITH CHECK ((passenger_id = auth.uid()));


--
-- Name: carpooling_bookings Passengers can view own bookings; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Passengers can view own bookings" ON public.carpooling_bookings FOR SELECT TO authenticated USING ((passenger_id = auth.uid()));


--
-- Name: public_inspection_reports Public reports readable by anyone; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Public reports readable by anyone" ON public.public_inspection_reports FOR SELECT USING (true);


--
-- Name: ride_ratings Raters can insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Raters can insert" ON public.ride_ratings FOR INSERT WITH CHECK ((auth.uid() = rater_id));


--
-- Name: planning_messages Recipients can mark messages read; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Recipients can mark messages read" ON public.planning_messages FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.planning_matches pm
  WHERE ((pm.id = planning_messages.match_id) AND ((pm.user_a_id = auth.uid()) OR (pm.user_b_id = auth.uid()))))));


--
-- Name: planning_messages Sender can update own messages; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Sender can update own messages" ON public.planning_messages FOR UPDATE USING ((auth.uid() = sender_id));


--
-- Name: ride_messages Sender can update own messages; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Sender can update own messages" ON public.ride_messages FOR UPDATE USING ((auth.uid() = sender_id));


--
-- Name: phone_verifications Service role full access on phone_verifications; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Service role full access on phone_verifications" ON public.phone_verifications USING (true) WITH CHECK (true);


--
-- Name: carpooling_trips Supprimer son trajet; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Supprimer son trajet" ON public.carpooling_trips FOR DELETE TO authenticated USING ((driver_id = auth.uid()));


--
-- Name: planning_matches System can insert matches; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "System can insert matches" ON public.planning_matches FOR INSERT WITH CHECK (((auth.uid() = user_a_id) OR (auth.uid() = user_b_id)));


--
-- Name: ride_matches System can insert matches; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "System can insert matches" ON public.ride_matches FOR INSERT WITH CHECK (((auth.uid() = driver_id) OR (auth.uid() = passenger_id)));


--
-- Name: planning_notifications System can insert notifications; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "System can insert notifications" ON public.planning_notifications FOR INSERT WITH CHECK (true);


--
-- Name: mission_revenue_logs System can manage revenue logs; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "System can manage revenue logs" ON public.mission_revenue_logs USING (true) WITH CHECK (true);


--
-- Name: covoiturage_trips Tout le monde peut voir les trajets publi√©s; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Tout le monde peut voir les trajets publi√©s" ON public.covoiturage_trips FOR SELECT USING ((((status)::text = 'published'::text) OR (user_id = auth.uid())));


--
-- Name: carpooling_trips Trajets publics lisibles; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Trajets publics lisibles" ON public.carpooling_trips FOR SELECT TO authenticated USING ((status = ANY (ARRAY['active'::text, 'full'::text])));


--
-- Name: mission_assignments Users and contacts can update assignments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users and contacts can update assignments" ON public.mission_assignments FOR UPDATE TO authenticated USING (((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.contacts
  WHERE ((contacts.id = mission_assignments.contact_id) AND (contacts.user_id = auth.uid())))))) WITH CHECK (((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.contacts
  WHERE ((contacts.id = mission_assignments.contact_id) AND (contacts.user_id = auth.uid()))))));


--
-- Name: mission_assignments Users and contacts can view assignments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users and contacts can view assignments" ON public.mission_assignments FOR SELECT TO authenticated USING (((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.contacts
  WHERE ((contacts.id = mission_assignments.contact_id) AND (contacts.user_id = auth.uid()))))));


--
-- Name: carpooling_bookings Users can create bookings; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create bookings" ON public.carpooling_bookings FOR INSERT TO authenticated WITH CHECK ((passenger_id = auth.uid()));


--
-- Name: contact_requests Users can create contact requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create contact requests" ON public.contact_requests FOR INSERT WITH CHECK ((auth.uid() = requester_id));


--
-- Name: inspections Users can create inspections for own missions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create inspections for own missions" ON public.inspections FOR INSERT TO authenticated WITH CHECK (((auth.uid() = user_id) AND (EXISTS ( SELECT 1
   FROM public.missions
  WHERE ((missions.id = inspections.mission_id) AND (missions.user_id = auth.uid()))))));


--
-- Name: navigation_sessions Users can create navigation sessions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create navigation sessions" ON public.navigation_sessions FOR INSERT WITH CHECK ((mission_id IN ( SELECT missions.id
   FROM public.missions
  WHERE ((missions.user_id = auth.uid()) OR (missions.driver_id = auth.uid())))));


--
-- Name: mission_assignments Users can create own assignments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own assignments" ON public.mission_assignments FOR INSERT TO authenticated WITH CHECK ((user_id = auth.uid()));


--
-- Name: clients Users can create own clients; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own clients" ON public.clients FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: support_conversations Users can create own conversations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own conversations" ON public.support_conversations FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: documents Users can create own documents; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own documents" ON public.documents FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: unified_scanned_documents Users can create own documents; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own documents" ON public.unified_scanned_documents FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: inspections Users can create own inspections; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own inspections" ON public.inspections FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: invoices Users can create own invoices; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own invoices" ON public.invoices FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: ride_offers Users can create own offers; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own offers" ON public.ride_offers FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: pricing_grids Users can create own pricing grids; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own pricing grids" ON public.pricing_grids FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: quotes Users can create own quotes; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own quotes" ON public.quotes FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: ride_requests Users can create own requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own requests" ON public.ride_requests FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: transactions Users can create own transactions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create own transactions" ON public.transactions FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: inspection_damages Users can delete damages for their inspections; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete damages for their inspections" ON public.inspection_damages FOR DELETE USING ((EXISTS ( SELECT 1
   FROM (public.vehicle_inspections vi
     JOIN public.missions m ON ((vi.mission_id = m.id)))
  WHERE ((vi.id = inspection_damages.inspection_id) AND ((m.user_id = auth.uid()) OR (m.assigned_user_id = auth.uid()))))));


--
-- Name: mission_assignments Users can delete own assignments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own assignments" ON public.mission_assignments FOR DELETE TO authenticated USING ((user_id = auth.uid()));


--
-- Name: clients Users can delete own clients; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own clients" ON public.clients FOR DELETE TO authenticated USING ((auth.uid() = user_id));


--
-- Name: contacts Users can delete own contacts; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own contacts" ON public.contacts FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: documents Users can delete own documents; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own documents" ON public.documents FOR DELETE TO authenticated USING ((auth.uid() = user_id));


--
-- Name: unified_scanned_documents Users can delete own documents; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own documents" ON public.unified_scanned_documents FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: quotes Users can delete own draft quotes; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own draft quotes" ON public.quotes FOR DELETE USING (((auth.uid() = user_id) AND ((status)::text = 'draft'::text)));


--
-- Name: inspections Users can delete own inspections; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own inspections" ON public.inspections FOR DELETE TO authenticated USING ((auth.uid() = user_id));


--
-- Name: ride_offers Users can delete own offers; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own offers" ON public.ride_offers FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: convoy_plannings Users can delete own plannings; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own plannings" ON public.convoy_plannings FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: pricing_grids Users can delete own pricing grids; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own pricing grids" ON public.pricing_grids FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: user_push_tokens Users can delete own push tokens; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own push tokens" ON public.user_push_tokens FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: ride_requests Users can delete own requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own requests" ON public.ride_requests FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: planning_waypoints Users can delete own waypoints; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete own waypoints" ON public.planning_waypoints FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.convoy_plannings
  WHERE ((convoy_plannings.id = planning_waypoints.planning_id) AND (convoy_plannings.user_id = auth.uid())))));


--
-- Name: navigation_sessions Users can delete their navigation sessions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete their navigation sessions" ON public.navigation_sessions FOR DELETE USING ((mission_id IN ( SELECT missions.id
   FROM public.missions
  WHERE ((missions.user_id = auth.uid()) OR (missions.driver_id = auth.uid())))));


--
-- Name: attachments Users can delete their own attachments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete their own attachments" ON public.attachments FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: public_inspection_reports Users can delete their own public reports; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete their own public reports" ON public.public_inspection_reports FOR DELETE USING ((auth.uid() = created_by));


--
-- Name: inspection_damages Users can insert damages for their inspections; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert damages for their inspections" ON public.inspection_damages FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM (public.vehicle_inspections vi
     JOIN public.missions m ON ((vi.mission_id = m.id)))
  WHERE ((vi.id = inspection_damages.inspection_id) AND ((m.user_id = auth.uid()) OR (m.assigned_user_id = auth.uid()))))));


--
-- Name: user_consents Users can insert own consents; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert own consents" ON public.user_consents FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: user_credits Users can insert own credits; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert own credits" ON public.user_credits FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: deletion_requests Users can insert own deletion requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert own deletion requests" ON public.deletion_requests FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: convoy_plannings Users can insert own plannings; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert own plannings" ON public.convoy_plannings FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: user_push_tokens Users can insert own push tokens; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert own push tokens" ON public.user_push_tokens FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: shop_quote_requests Users can insert own quote requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert own quote requests" ON public.shop_quote_requests FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: mission_tracking_live Users can insert own tracking; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert own tracking" ON public.mission_tracking_live FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: mission_tracking_history Users can insert own tracking history; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert own tracking history" ON public.mission_tracking_history FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: attachments Users can insert their own attachments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert their own attachments" ON public.attachments FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: user_devices Users can insert their own devices; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert their own devices" ON public.user_devices FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: availability_calendar Users can manage own availability; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can manage own availability" ON public.availability_calendar USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: contacts Users can manage own contacts; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can manage own contacts" ON public.contacts TO authenticated USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: invoice_items Users can manage own invoice items; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can manage own invoice items" ON public.invoice_items TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.invoices
  WHERE ((invoices.id = invoice_items.invoice_id) AND (invoices.user_id = auth.uid()))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM public.invoices
  WHERE ((invoices.id = invoice_items.invoice_id) AND (invoices.user_id = auth.uid())))));


--
-- Name: push_tokens Users can manage own push tokens; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can manage own push tokens" ON public.push_tokens USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: planning_waypoints Users can manage own waypoints; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can manage own waypoints" ON public.planning_waypoints FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.convoy_plannings
  WHERE ((convoy_plannings.id = planning_waypoints.planning_id) AND (convoy_plannings.user_id = auth.uid())))));


--
-- Name: carpooling_messages Users can mark messages as read; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can mark messages as read" ON public.carpooling_messages FOR UPDATE USING ((receiver_id = auth.uid())) WITH CHECK ((receiver_id = auth.uid()));


--
-- Name: profiles Users can search profiles by phone; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can search profiles by phone" ON public.profiles FOR SELECT TO authenticated USING (true);


--
-- Name: contacts Users can send contact invitations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can send contact invitations" ON public.contacts FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: carpooling_messages Users can send messages; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can send messages" ON public.carpooling_messages FOR INSERT WITH CHECK ((sender_id = auth.uid()));


--
-- Name: support_messages Users can send messages in own conversations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can send messages in own conversations" ON public.support_messages FOR INSERT TO authenticated WITH CHECK ((EXISTS ( SELECT 1
   FROM public.support_conversations
  WHERE ((support_conversations.id = support_messages.conversation_id) AND (support_conversations.user_id = auth.uid())))));


--
-- Name: inspection_damages Users can update damages for their inspections; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update damages for their inspections" ON public.inspection_damages FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM (public.vehicle_inspections vi
     JOIN public.missions m ON ((vi.mission_id = m.id)))
  WHERE ((vi.id = inspection_damages.inspection_id) AND ((m.user_id = auth.uid()) OR (m.assigned_user_id = auth.uid()))))));


--
-- Name: clients Users can update own clients; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own clients" ON public.clients FOR UPDATE TO authenticated USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: user_consents Users can update own consents; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own consents" ON public.user_consents FOR UPDATE TO authenticated USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: contacts Users can update own contacts or respond to invitations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own contacts or respond to invitations" ON public.contacts FOR UPDATE USING (((auth.uid() = user_id) OR ((auth.uid() = invited_user_id) AND (invitation_status = 'pending'::text))));


--
-- Name: user_credits Users can update own credits; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own credits" ON public.user_credits FOR UPDATE TO authenticated USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: unified_scanned_documents Users can update own documents; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own documents" ON public.unified_scanned_documents FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: inspections Users can update own inspections; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own inspections" ON public.inspections FOR UPDATE TO authenticated USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: invoices Users can update own invoices; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own invoices" ON public.invoices FOR UPDATE TO authenticated USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: planning_matches Users can update own matches; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own matches" ON public.planning_matches FOR UPDATE USING (((auth.uid() = user_a_id) OR (auth.uid() = user_b_id)));


--
-- Name: carpooling_messages Users can update own messages; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own messages" ON public.carpooling_messages FOR UPDATE TO authenticated USING ((receiver_id = auth.uid())) WITH CHECK ((receiver_id = auth.uid()));


--
-- Name: notifications Users can update own notifications; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own notifications" ON public.notifications FOR UPDATE TO authenticated USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: planning_notifications Users can update own notifications; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own notifications" ON public.planning_notifications FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: ride_offers Users can update own offers; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own offers" ON public.ride_offers FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: convoy_plannings Users can update own plannings; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own plannings" ON public.convoy_plannings FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: pricing_grids Users can update own pricing grids; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own pricing grids" ON public.pricing_grids FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: profiles Users can update own profile; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING ((auth.uid() = id));


--
-- Name: user_push_tokens Users can update own push tokens; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own push tokens" ON public.user_push_tokens FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: quotes Users can update own quotes; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own quotes" ON public.quotes FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: ride_requests Users can update own requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own requests" ON public.ride_requests FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: planning_stats Users can update own stats; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own stats" ON public.planning_stats FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: subscriptions Users can update own subscription; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own subscription" ON public.subscriptions FOR UPDATE USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: mission_tracking_live Users can update own tracking; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own tracking" ON public.mission_tracking_live FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: planning_waypoints Users can update own waypoints; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own waypoints" ON public.planning_waypoints FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.convoy_plannings
  WHERE ((convoy_plannings.id = planning_waypoints.planning_id) AND (convoy_plannings.user_id = auth.uid())))));


--
-- Name: contact_requests Users can update relevant contact requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update relevant contact requests" ON public.contact_requests FOR UPDATE USING (((auth.uid() = requester_id) OR (auth.uid() IN ( SELECT profiles.id
   FROM public.profiles
  WHERE (profiles.email = contact_requests.target_email)))));


--
-- Name: navigation_sessions Users can update their navigation sessions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their navigation sessions" ON public.navigation_sessions FOR UPDATE USING ((mission_id IN ( SELECT missions.id
   FROM public.missions
  WHERE ((missions.user_id = auth.uid()) OR (missions.driver_id = auth.uid())))));


--
-- Name: attachments Users can update their own attachments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their own attachments" ON public.attachments FOR UPDATE USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: user_devices Users can update their own devices; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their own devices" ON public.user_devices FOR UPDATE USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));


--
-- Name: public_inspection_reports Users can update their own public reports; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their own public reports" ON public.public_inspection_reports FOR UPDATE USING ((auth.uid() = created_by));


--
-- Name: planning_stats Users can upsert own stats; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can upsert own stats" ON public.planning_stats FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: availability_calendar Users can view contacts availability; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view contacts availability" ON public.availability_calendar FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.contacts
  WHERE ((contacts.user_id = auth.uid()) AND (contacts.invited_user_id = availability_calendar.user_id) AND (contacts.invitation_status = 'accepted'::text) AND (contacts.has_calendar_access = true)))));


--
-- Name: inspection_damages Users can view damages for their inspections; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view damages for their inspections" ON public.inspection_damages FOR SELECT USING ((EXISTS ( SELECT 1
   FROM (public.vehicle_inspections vi
     JOIN public.missions m ON ((vi.mission_id = m.id)))
  WHERE ((vi.id = inspection_damages.inspection_id) AND ((m.user_id = auth.uid()) OR (m.assigned_user_id = auth.uid()))))));


--
-- Name: mission_tracking_history Users can view history of their missions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view history of their missions" ON public.mission_tracking_history FOR SELECT USING ((mission_id IN ( SELECT missions.id
   FROM public.missions
  WHERE ((missions.user_id = auth.uid()) OR (missions.assigned_user_id = auth.uid())))));


--
-- Name: inspections Users can view inspections for own missions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view inspections for own missions" ON public.inspections FOR SELECT TO authenticated USING (((auth.uid() = user_id) OR (EXISTS ( SELECT 1
   FROM public.missions
  WHERE ((missions.id = inspections.mission_id) AND (missions.user_id = auth.uid()))))));


--
-- Name: support_messages Users can view messages in own conversations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view messages in own conversations" ON public.support_messages FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.support_conversations
  WHERE ((support_conversations.id = support_messages.conversation_id) AND (support_conversations.user_id = auth.uid())))));


--
-- Name: carpooling_messages Users can view messages they sent or received; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view messages they sent or received" ON public.carpooling_messages FOR SELECT TO authenticated USING (((sender_id = auth.uid()) OR (receiver_id = auth.uid())));


--
-- Name: profiles Users can view other profiles for covoiturage; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view other profiles for covoiturage" ON public.profiles FOR SELECT TO authenticated USING (true);


--
-- Name: availability_calendar Users can view own availability; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own availability" ON public.availability_calendar FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: clients Users can view own clients; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own clients" ON public.clients FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: user_consents Users can view own consents; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own consents" ON public.user_consents FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: contact_requests Users can view own contact requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own contact requests" ON public.contact_requests FOR SELECT USING (((auth.uid() = requester_id) OR (auth.uid() IN ( SELECT profiles.id
   FROM public.profiles
  WHERE (profiles.email = contact_requests.target_email)))));


--
-- Name: contacts Users can view own contacts and received invitations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own contacts and received invitations" ON public.contacts FOR SELECT USING (((auth.uid() = user_id) OR (auth.uid() = invited_user_id)));


--
-- Name: support_conversations Users can view own conversations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own conversations" ON public.support_conversations FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: user_credits Users can view own credits; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own credits" ON public.user_credits FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: deletion_requests Users can view own deletion requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own deletion requests" ON public.deletion_requests FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: documents Users can view own documents; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own documents" ON public.documents FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: unified_scanned_documents Users can view own documents; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own documents" ON public.unified_scanned_documents FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: inspections Users can view own inspections; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own inspections" ON public.inspections FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: invoice_items Users can view own invoice items; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own invoice items" ON public.invoice_items FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.invoices
  WHERE ((invoices.id = invoice_items.invoice_id) AND (invoices.user_id = auth.uid())))));


--
-- Name: invoices Users can view own invoices; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own invoices" ON public.invoices FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: planning_matches Users can view own matches; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own matches" ON public.planning_matches FOR SELECT USING (((auth.uid() = user_a_id) OR (auth.uid() = user_b_id)));


--
-- Name: notifications Users can view own notifications; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own notifications" ON public.notifications FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: planning_notifications Users can view own notifications; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own notifications" ON public.planning_notifications FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: pricing_grids Users can view own pricing grids; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own pricing grids" ON public.pricing_grids FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: profiles Users can view own profile; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own profile" ON public.profiles FOR SELECT USING ((auth.uid() = id));


--
-- Name: user_push_tokens Users can view own push tokens; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own push tokens" ON public.user_push_tokens FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: shop_quote_requests Users can view own quote requests; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own quote requests" ON public.shop_quote_requests FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: quotes Users can view own quotes; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own quotes" ON public.quotes FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: mission_revenue_logs Users can view own revenue logs; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own revenue logs" ON public.mission_revenue_logs FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: planning_stats Users can view own stats; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own stats" ON public.planning_stats FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: subscriptions Users can view own subscription; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own subscription" ON public.subscriptions FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: transactions Users can view own transactions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view own transactions" ON public.transactions FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: convoy_plannings Users can view published plannings; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view published plannings" ON public.convoy_plannings FOR SELECT USING (((status = 'published'::text) OR (auth.uid() = user_id)));


--
-- Name: carpooling_messages Users can view their messages; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their messages" ON public.carpooling_messages FOR SELECT USING (((sender_id = auth.uid()) OR (receiver_id = auth.uid())));


--
-- Name: navigation_sessions Users can view their navigation sessions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their navigation sessions" ON public.navigation_sessions FOR SELECT USING ((mission_id IN ( SELECT missions.id
   FROM public.missions
  WHERE ((missions.user_id = auth.uid()) OR (missions.driver_id = auth.uid())))));


--
-- Name: attachments Users can view their own attachments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own attachments" ON public.attachments FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: user_devices Users can view their own devices; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own devices" ON public.user_devices FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: mission_tracking_live Users can view tracking of their missions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view tracking of their missions" ON public.mission_tracking_live FOR SELECT USING ((mission_id IN ( SELECT missions.id
   FROM public.missions
  WHERE ((missions.user_id = auth.uid()) OR (missions.assigned_user_id = auth.uid())))));


--
-- Name: planning_waypoints Users can view waypoints of visible plannings; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view waypoints of visible plannings" ON public.planning_waypoints FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.convoy_plannings
  WHERE ((convoy_plannings.id = planning_waypoints.planning_id) AND ((convoy_plannings.status = 'published'::text) OR (convoy_plannings.user_id = auth.uid()))))));


--
-- Name: support_tickets Users create own tickets; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users create own tickets" ON public.support_tickets FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: planning_notifications Users see own notifications; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users see own notifications" ON public.planning_notifications USING ((user_id = auth.uid()));


--
-- Name: support_tickets Users view own tickets; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users view own tickets" ON public.support_tickets FOR SELECT TO authenticated USING ((auth.uid() = user_id));


--
-- Name: app_versions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.app_versions ENABLE ROW LEVEL SECURITY;

--
-- Name: calendar_events cal_evt_owner_all; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY cal_evt_owner_all ON public.calendar_events TO authenticated USING ((auth.uid() = owner_id)) WITH CHECK ((auth.uid() = owner_id));


--
-- Name: calendar_events cal_evt_shared_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY cal_evt_shared_delete ON public.calendar_events FOR DELETE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.calendar_permissions
  WHERE ((calendar_permissions.owner_id = calendar_events.owner_id) AND (calendar_permissions.shared_with_id = auth.uid()) AND (calendar_permissions.is_active = true) AND (calendar_permissions.permission_level = 'full'::text)))));


--
-- Name: calendar_events cal_evt_shared_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY cal_evt_shared_insert ON public.calendar_events FOR INSERT TO authenticated WITH CHECK ((EXISTS ( SELECT 1
   FROM public.calendar_permissions
  WHERE ((calendar_permissions.owner_id = calendar_events.owner_id) AND (calendar_permissions.shared_with_id = auth.uid()) AND (calendar_permissions.is_active = true) AND (calendar_permissions.permission_level = ANY (ARRAY['edit'::text, 'full'::text]))))));


--
-- Name: calendar_events cal_evt_shared_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY cal_evt_shared_update ON public.calendar_events FOR UPDATE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.calendar_permissions
  WHERE ((calendar_permissions.owner_id = calendar_events.owner_id) AND (calendar_permissions.shared_with_id = auth.uid()) AND (calendar_permissions.is_active = true) AND (calendar_permissions.permission_level = ANY (ARRAY['edit'::text, 'full'::text]))))));


--
-- Name: calendar_events cal_evt_shared_view; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY cal_evt_shared_view ON public.calendar_events FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.calendar_permissions
  WHERE ((calendar_permissions.owner_id = calendar_events.owner_id) AND (calendar_permissions.shared_with_id = auth.uid()) AND (calendar_permissions.is_active = true)))));


--
-- Name: calendar_permissions cal_perm_owner_all; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY cal_perm_owner_all ON public.calendar_permissions TO authenticated USING ((auth.uid() = owner_id)) WITH CHECK ((auth.uid() = owner_id));


--
-- Name: calendar_permissions cal_perm_shared_view; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY cal_perm_shared_view ON public.calendar_permissions FOR SELECT TO authenticated USING ((auth.uid() = shared_with_id));


--
-- Name: carpooling_bookings; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.carpooling_bookings ENABLE ROW LEVEL SECURITY;

--
-- Name: clients clients_create; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY clients_create ON public.clients FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: clients clients_modify; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY clients_modify ON public.clients FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: clients clients_remove; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY clients_remove ON public.clients FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: clients clients_view; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY clients_view ON public.clients FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: contacts contacts_create; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY contacts_create ON public.contacts FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: contacts contacts_modify; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY contacts_modify ON public.contacts FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: contacts contacts_remove; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY contacts_remove ON public.contacts FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: contacts contacts_view; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY contacts_view ON public.contacts FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: convoy_plannings; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.convoy_plannings ENABLE ROW LEVEL SECURITY;

--
-- Name: mission_assignments create_assignments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY create_assignments ON public.mission_assignments FOR INSERT WITH CHECK ((auth.uid() = assigned_by));


--
-- Name: credit_transactions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.credit_transactions ENABLE ROW LEVEL SECURITY;

--
-- Name: user_credits credits_create; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY credits_create ON public.user_credits FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: user_credits credits_modify; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY credits_modify ON public.user_credits FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: user_credits credits_view; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY credits_view ON public.user_credits FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: credit_transactions ct_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY ct_insert ON public.credit_transactions FOR INSERT TO authenticated WITH CHECK ((user_id = auth.uid()));


--
-- Name: credit_transactions ct_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY ct_select ON public.credit_transactions FOR SELECT TO authenticated USING ((user_id = auth.uid()));


--
-- Name: inspection_documents id_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY id_delete ON public.inspection_documents FOR DELETE TO authenticated USING (true);


--
-- Name: inspection_documents id_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY id_insert ON public.inspection_documents FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: inspection_documents id_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY id_select ON public.inspection_documents FOR SELECT TO authenticated USING (true);


--
-- Name: inspection_documents id_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY id_update ON public.inspection_documents FOR UPDATE TO authenticated USING (true);


--
-- Name: mission_locations insert_mission_locations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY insert_mission_locations ON public.mission_locations FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.missions m
  WHERE ((m.id = mission_locations.mission_id) AND ((m.user_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.mission_assignments ma
          WHERE ((ma.mission_id = m.id) AND (ma.user_id = auth.uid())))))))));


--
-- Name: inspection_damages; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.inspection_damages ENABLE ROW LEVEL SECURITY;

--
-- Name: inspection_documents; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.inspection_documents ENABLE ROW LEVEL SECURITY;

--
-- Name: inspection_expenses; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.inspection_expenses ENABLE ROW LEVEL SECURITY;

--
-- Name: inspection_photos_v2; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.inspection_photos_v2 ENABLE ROW LEVEL SECURITY;

--
-- Name: inspection_report_shares; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.inspection_report_shares ENABLE ROW LEVEL SECURITY;

--
-- Name: invoices invoices_create; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY invoices_create ON public.invoices FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: invoices invoices_modify; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY invoices_modify ON public.invoices FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: invoices invoices_remove; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY invoices_remove ON public.invoices FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: invoices invoices_view; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY invoices_view ON public.invoices FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: inspection_photos_v2 ipv2_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY ipv2_insert ON public.inspection_photos_v2 FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: inspection_photos_v2 ipv2_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY ipv2_select ON public.inspection_photos_v2 FOR SELECT TO authenticated USING (true);


--
-- Name: inspection_report_shares irs_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY irs_insert ON public.inspection_report_shares FOR INSERT TO authenticated WITH CHECK ((user_id = auth.uid()));


--
-- Name: inspection_report_shares irs_public_read; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY irs_public_read ON public.inspection_report_shares FOR SELECT TO anon USING ((is_active = true));


--
-- Name: inspection_report_shares irs_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY irs_select ON public.inspection_report_shares FOR SELECT TO authenticated USING ((user_id = auth.uid()));


--
-- Name: inspection_report_shares irs_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY irs_update ON public.inspection_report_shares FOR UPDATE TO authenticated USING ((user_id = auth.uid())) WITH CHECK ((user_id = auth.uid()));


--
-- Name: gps_location_points loc_insert_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY loc_insert_policy ON public.gps_location_points FOR INSERT TO authenticated WITH CHECK ((EXISTS ( SELECT 1
   FROM public.gps_tracking_sessions ts
  WHERE ((ts.id = gps_location_points.session_id) AND (ts.driver_id = auth.uid())))));


--
-- Name: gps_location_points loc_view_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY loc_view_policy ON public.gps_location_points FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM (public.gps_tracking_sessions ts
     JOIN public.missions m ON ((m.id = ts.mission_id)))
  WHERE ((ts.id = gps_location_points.session_id) AND ((ts.driver_id = auth.uid()) OR (m.user_id = auth.uid()))))));


--
-- Name: mission_tracking_history; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.mission_tracking_history ENABLE ROW LEVEL SECURITY;

--
-- Name: mission_tracking_live; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.mission_tracking_live ENABLE ROW LEVEL SECURITY;

--
-- Name: missions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.missions ENABLE ROW LEVEL SECURITY;

--
-- Name: missions missions_anon_public_tracking; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY missions_anon_public_tracking ON public.missions FOR SELECT TO anon USING ((EXISTS ( SELECT 1
   FROM public.public_tracking_links ptl
  WHERE ((ptl.mission_id = missions.id) AND (ptl.is_active = true) AND (ptl.expires_at > now())))));


--
-- Name: missions missions_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY missions_delete ON public.missions FOR DELETE TO authenticated USING ((auth.uid() = user_id));


--
-- Name: missions missions_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY missions_insert ON public.missions FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));


--
-- Name: missions missions_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY missions_select ON public.missions FOR SELECT TO authenticated USING (((auth.uid() = user_id) OR (auth.uid() = assigned_user_id)));


--
-- Name: missions missions_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY missions_update ON public.missions FOR UPDATE TO authenticated USING (((auth.uid() = user_id) OR (auth.uid() = assigned_user_id))) WITH CHECK (((auth.uid() = user_id) OR (auth.uid() = assigned_user_id)));


--
-- Name: mission_assignments modify_assignments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY modify_assignments ON public.mission_assignments FOR UPDATE USING (((auth.uid() = assigned_by) OR (auth.uid() = user_id)));


--
-- Name: phone_verifications; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.phone_verifications ENABLE ROW LEVEL SECURITY;

--
-- Name: planning_matches; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.planning_matches ENABLE ROW LEVEL SECURITY;

--
-- Name: planning_messages; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.planning_messages ENABLE ROW LEVEL SECURITY;

--
-- Name: planning_notifications; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.planning_notifications ENABLE ROW LEVEL SECURITY;

--
-- Name: planning_stats; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.planning_stats ENABLE ROW LEVEL SECURITY;

--
-- Name: planning_waypoints; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.planning_waypoints ENABLE ROW LEVEL SECURITY;

--
-- Name: profiles; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

--
-- Name: profiles profiles_anon_driver_name; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY profiles_anon_driver_name ON public.profiles FOR SELECT TO anon USING ((EXISTS ( SELECT 1
   FROM (public.missions m
     JOIN public.public_tracking_links ptl ON ((ptl.mission_id = m.id)))
  WHERE ((m.assigned_user_id = profiles.id) AND (ptl.is_active = true) AND (ptl.expires_at > now())))));


--
-- Name: profiles profiles_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY profiles_insert ON public.profiles FOR INSERT TO authenticated WITH CHECK ((id = auth.uid()));


--
-- Name: profiles profiles_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY profiles_select ON public.profiles FOR SELECT TO authenticated USING (true);


--
-- Name: profiles profiles_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY profiles_update ON public.profiles FOR UPDATE TO authenticated USING ((id = auth.uid())) WITH CHECK ((id = auth.uid()));


--
-- Name: public_inspection_reports; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.public_inspection_reports ENABLE ROW LEVEL SECURITY;

--
-- Name: public_tracking_links; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.public_tracking_links ENABLE ROW LEVEL SECURITY;

--
-- Name: public_tracking_links public_tracking_links_anon_read; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY public_tracking_links_anon_read ON public.public_tracking_links FOR SELECT TO anon USING (((is_active = true) AND (expires_at > now())));


--
-- Name: public_tracking_links public_tracking_links_auth_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY public_tracking_links_auth_insert ON public.public_tracking_links FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: public_tracking_links public_tracking_links_auth_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY public_tracking_links_auth_select ON public.public_tracking_links FOR SELECT TO authenticated USING (true);


--
-- Name: public_tracking_links public_tracking_links_auth_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY public_tracking_links_auth_update ON public.public_tracking_links FOR UPDATE TO authenticated USING (true);


--
-- Name: push_tokens; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.push_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: quotes quotes_create; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY quotes_create ON public.quotes FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: quotes quotes_modify; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY quotes_modify ON public.quotes FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: quotes quotes_remove; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY quotes_remove ON public.quotes FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: quotes quotes_view; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY quotes_view ON public.quotes FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: mission_assignments remove_assignments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY remove_assignments ON public.mission_assignments FOR DELETE USING ((auth.uid() = assigned_by));


--
-- Name: ride_matches; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.ride_matches ENABLE ROW LEVEL SECURITY;

--
-- Name: ride_messages; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.ride_messages ENABLE ROW LEVEL SECURITY;

--
-- Name: ride_offers; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.ride_offers ENABLE ROW LEVEL SECURITY;

--
-- Name: ride_ratings; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.ride_ratings ENABLE ROW LEVEL SECURITY;

--
-- Name: ride_requests; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.ride_requests ENABLE ROW LEVEL SECURITY;

--
-- Name: signup_attempts; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.signup_attempts ENABLE ROW LEVEL SECURITY;

--
-- Name: subscriptions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;

--
-- Name: gps_tracking_sessions track_client_view; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY track_client_view ON public.gps_tracking_sessions FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.missions m
  WHERE ((m.id = gps_tracking_sessions.mission_id) AND (m.user_id = auth.uid())))));


--
-- Name: gps_tracking_sessions track_driver_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY track_driver_policy ON public.gps_tracking_sessions TO authenticated USING ((driver_id = auth.uid())) WITH CHECK ((driver_id = auth.uid()));


--
-- Name: mission_tracking_history tracking_history_anon_read; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY tracking_history_anon_read ON public.mission_tracking_history FOR SELECT TO anon USING ((EXISTS ( SELECT 1
   FROM public.public_tracking_links ptl
  WHERE ((ptl.mission_id = mission_tracking_history.mission_id) AND (ptl.is_active = true) AND (ptl.expires_at > now())))));


--
-- Name: mission_tracking_history tracking_history_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY tracking_history_insert ON public.mission_tracking_history FOR INSERT TO authenticated WITH CHECK ((user_id = auth.uid()));


--
-- Name: mission_tracking_history tracking_history_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY tracking_history_select ON public.mission_tracking_history FOR SELECT TO authenticated USING (((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.missions m
  WHERE ((m.id = mission_tracking_history.mission_id) AND ((m.user_id = auth.uid()) OR (m.assigned_user_id = auth.uid())))))));


--
-- Name: mission_tracking_live tracking_live_anon_read; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY tracking_live_anon_read ON public.mission_tracking_live FOR SELECT TO anon USING ((EXISTS ( SELECT 1
   FROM public.public_tracking_links ptl
  WHERE ((ptl.mission_id = mission_tracking_live.mission_id) AND (ptl.is_active = true) AND (ptl.expires_at > now())))));


--
-- Name: mission_tracking_live tracking_live_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY tracking_live_insert ON public.mission_tracking_live FOR INSERT TO authenticated WITH CHECK ((user_id = auth.uid()));


--
-- Name: mission_tracking_live tracking_live_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY tracking_live_select ON public.mission_tracking_live FOR SELECT TO authenticated USING (((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.missions m
  WHERE ((m.id = mission_tracking_live.mission_id) AND ((m.user_id = auth.uid()) OR (m.assigned_user_id = auth.uid())))))));


--
-- Name: mission_tracking_live tracking_live_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY tracking_live_update ON public.mission_tracking_live FOR UPDATE TO authenticated USING ((user_id = auth.uid()));


--
-- Name: unified_scanned_documents; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.unified_scanned_documents ENABLE ROW LEVEL SECURITY;

--
-- Name: user_credits; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.user_credits ENABLE ROW LEVEL SECURITY;

--
-- Name: vehicle_inspections; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.vehicle_inspections ENABLE ROW LEVEL SECURITY;

--
-- Name: vehicle_inspections vi_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY vi_insert ON public.vehicle_inspections FOR INSERT TO authenticated WITH CHECK ((inspector_id = auth.uid()));


--
-- Name: vehicle_inspections vi_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY vi_select ON public.vehicle_inspections FOR SELECT TO authenticated USING ((inspector_id = auth.uid()));


--
-- Name: vehicle_inspections vi_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY vi_update ON public.vehicle_inspections FOR UPDATE TO authenticated USING ((inspector_id = auth.uid())) WITH CHECK ((inspector_id = auth.uid()));


--
-- Name: mission_assignments view_assignments; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY view_assignments ON public.mission_assignments FOR SELECT USING (((auth.uid() = user_id) OR (auth.uid() = assigned_by)));


--
-- Name: mission_locations view_mission_locations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY view_mission_locations ON public.mission_locations FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.missions m
  WHERE ((m.id = mission_locations.mission_id) AND ((m.user_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.mission_assignments ma
          WHERE ((ma.mission_id = m.id) AND (ma.user_id = auth.uid())))))))));


--
-- Name: messages; Type: ROW SECURITY; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER TABLE realtime.messages ENABLE ROW LEVEL SECURITY;

--
-- Name: objects Admins can delete APK; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Admins can delete APK" ON storage.objects FOR DELETE USING (((bucket_id = 'apk-files'::text) AND (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true))))));


--
-- Name: objects Admins can upload APK; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Admins can upload APK" ON storage.objects FOR INSERT WITH CHECK (((bucket_id = 'apk-files'::text) AND (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.is_admin = true))))));


--
-- Name: objects Allow authenticated users to upload mobile apps; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow authenticated users to upload mobile apps" ON storage.objects FOR INSERT TO authenticated WITH CHECK ((bucket_id = 'mobile-apps'::text));


--
-- Name: objects Allow authenticated users to upload their files; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow authenticated users to upload their files" ON storage.objects FOR INSERT TO authenticated WITH CHECK (((bucket_id = 'scanned-documents'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));


--
-- Name: objects Allow authenticated users to upload webp photos; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow authenticated users to upload webp photos" ON storage.objects FOR INSERT TO authenticated WITH CHECK ((bucket_id = 'inspection-photos-webp'::text));


--
-- Name: objects Allow public read access; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow public read access" ON storage.objects FOR SELECT USING ((bucket_id = 'scanned-documents'::text));


--
-- Name: objects Allow public to download PDFs; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow public to download PDFs" ON storage.objects FOR SELECT USING ((bucket_id = 'inspection-pdfs'::text));


--
-- Name: objects Allow public to download mobile apps; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow public to download mobile apps" ON storage.objects FOR SELECT USING ((bucket_id = 'mobile-apps'::text));


--
-- Name: objects Allow public to view webp photos; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow public to view webp photos" ON storage.objects FOR SELECT USING ((bucket_id = 'inspection-photos-webp'::text));


--
-- Name: objects Allow service to update PDFs; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow service to update PDFs" ON storage.objects FOR UPDATE TO service_role USING ((bucket_id = 'inspection-pdfs'::text));


--
-- Name: objects Allow service to upload PDFs; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow service to upload PDFs" ON storage.objects FOR INSERT TO authenticated, service_role WITH CHECK ((bucket_id = 'inspection-pdfs'::text));


--
-- Name: objects Allow users to delete their own files; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow users to delete their own files" ON storage.objects FOR DELETE TO authenticated USING (((bucket_id = 'scanned-documents'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));


--
-- Name: objects Allow users to delete their webp photos; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow users to delete their webp photos" ON storage.objects FOR DELETE TO authenticated USING (((bucket_id = 'inspection-photos-webp'::text) AND (auth.uid() = owner)));


--
-- Name: objects Allow users to read their own files; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow users to read their own files" ON storage.objects FOR SELECT TO authenticated USING (((bucket_id = 'scanned-documents'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));


--
-- Name: objects Allow users to update their own files; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow users to update their own files" ON storage.objects FOR UPDATE TO authenticated USING (((bucket_id = 'scanned-documents'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));


--
-- Name: objects Allow users to update their webp photos; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow users to update their webp photos" ON storage.objects FOR UPDATE TO authenticated USING (((bucket_id = 'inspection-photos-webp'::text) AND (auth.uid() = owner)));


--
-- Name: objects Anyone can download APK; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Anyone can download APK" ON storage.objects FOR SELECT USING ((bucket_id = 'apk-files'::text));


--
-- Name: objects Anyone can read avatars; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Anyone can read avatars" ON storage.objects FOR SELECT USING ((bucket_id = 'avatars'::text));


--
-- Name: objects Anyone can upload avatars; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Anyone can upload avatars" ON storage.objects FOR INSERT WITH CHECK ((bucket_id = 'avatars'::text));


--
-- Name: objects Auth users upload avatars; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Auth users upload avatars" ON storage.objects FOR INSERT WITH CHECK (((bucket_id = 'avatars'::text) AND (auth.role() = 'authenticated'::text)));


--
-- Name: objects Authenticated users can delete; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Authenticated users can delete" ON storage.objects FOR DELETE TO authenticated USING ((bucket_id = 'inspection-photos'::text));


--
-- Name: objects Authenticated users can update; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Authenticated users can update" ON storage.objects FOR UPDATE TO authenticated USING ((bucket_id = 'inspection-photos'::text));


--
-- Name: objects Authenticated users can upload; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Authenticated users can upload" ON storage.objects FOR INSERT TO authenticated WITH CHECK ((bucket_id = 'vehicle-images'::text));


--
-- Name: objects Documents delete; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Documents delete" ON storage.objects FOR DELETE TO authenticated USING (((bucket_id = 'inspection-documents'::text) AND (auth.role() = 'authenticated'::text)));


--
-- Name: objects Documents read; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Documents read" ON storage.objects FOR SELECT TO authenticated USING ((bucket_id = 'inspection-documents'::text));


--
-- Name: objects Documents upload; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Documents upload" ON storage.objects FOR INSERT TO authenticated WITH CHECK (((bucket_id = 'inspection-documents'::text) AND (auth.role() = 'authenticated'::text)));


--
-- Name: objects Public Access; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Public Access" ON storage.objects FOR SELECT USING ((bucket_id = 'vehicle-images'::text));


--
-- Name: objects Public read; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Public read" ON storage.objects FOR SELECT USING ((bucket_id = 'inspection-photos'::text));


--
-- Name: objects Public read avatars; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Public read avatars" ON storage.objects FOR SELECT USING ((bucket_id = 'avatars'::text));


--
-- Name: objects Users can delete own avatars; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can delete own avatars" ON storage.objects FOR DELETE TO authenticated USING (((bucket_id = 'avatars'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: objects Users can delete own images; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can delete own images" ON storage.objects FOR DELETE TO authenticated USING (((bucket_id = 'vehicle-images'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));


--
-- Name: objects Users can update own avatars; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can update own avatars" ON storage.objects FOR UPDATE TO authenticated USING (((bucket_id = 'avatars'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: objects Users can update own images; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can update own images" ON storage.objects FOR UPDATE TO authenticated USING (((bucket_id = 'vehicle-images'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));


--
-- Name: objects Users update own avatars; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users update own avatars" ON storage.objects FOR UPDATE USING (((bucket_id = 'avatars'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: buckets; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.buckets ENABLE ROW LEVEL SECURITY;

--
-- Name: buckets_analytics; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.buckets_analytics ENABLE ROW LEVEL SECURITY;

--
-- Name: buckets_vectors; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.buckets_vectors ENABLE ROW LEVEL SECURITY;

--
-- Name: objects insp_photos_delete; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY insp_photos_delete ON storage.objects FOR DELETE TO authenticated USING ((bucket_id = 'inspection-photos'::text));


--
-- Name: objects insp_photos_insert; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY insp_photos_insert ON storage.objects FOR INSERT TO authenticated WITH CHECK ((bucket_id = 'inspection-photos'::text));


--
-- Name: objects insp_photos_public_read; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY insp_photos_public_read ON storage.objects FOR SELECT USING ((bucket_id = 'inspection-photos'::text));


--
-- Name: objects insp_photos_update; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY insp_photos_update ON storage.objects FOR UPDATE TO authenticated USING ((bucket_id = 'inspection-photos'::text));


--
-- Name: migrations; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.migrations ENABLE ROW LEVEL SECURITY;

--
-- Name: objects; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;

--
-- Name: s3_multipart_uploads; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.s3_multipart_uploads ENABLE ROW LEVEL SECURITY;

--
-- Name: s3_multipart_uploads_parts; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.s3_multipart_uploads_parts ENABLE ROW LEVEL SECURITY;

--
-- Name: vector_indexes; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.vector_indexes ENABLE ROW LEVEL SECURITY;

--
-- Name: supabase_realtime; Type: PUBLICATION; Schema: -; Owner: postgres
--

CREATE PUBLICATION supabase_realtime WITH (publish = 'insert, update, delete, truncate');


ALTER PUBLICATION supabase_realtime OWNER TO postgres;

--
-- Name: supabase_realtime_messages_publication; Type: PUBLICATION; Schema: -; Owner: supabase_admin
--

CREATE PUBLICATION supabase_realtime_messages_publication WITH (publish = 'insert, update, delete, truncate');


ALTER PUBLICATION supabase_realtime_messages_publication OWNER TO supabase_admin;

--
-- Name: supabase_realtime contacts; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.contacts;


--
-- Name: supabase_realtime convoy_plannings; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.convoy_plannings;


--
-- Name: supabase_realtime invoices; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.invoices;


--
-- Name: supabase_realtime mission_assignments; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.mission_assignments;


--
-- Name: supabase_realtime mission_tracking_live; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.mission_tracking_live;


--
-- Name: supabase_realtime missions; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.missions;


--
-- Name: supabase_realtime phone_verifications; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.phone_verifications;


--
-- Name: supabase_realtime planning_matches; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.planning_matches;


--
-- Name: supabase_realtime planning_messages; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.planning_messages;


--
-- Name: supabase_realtime planning_notifications; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.planning_notifications;


--
-- Name: supabase_realtime profiles; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.profiles;


--
-- Name: supabase_realtime ride_matches; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.ride_matches;


--
-- Name: supabase_realtime ride_messages; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.ride_messages;


--
-- Name: supabase_realtime ride_offers; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.ride_offers;


--
-- Name: supabase_realtime ride_requests; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.ride_requests;


--
-- Name: supabase_realtime support_conversations; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.support_conversations;


--
-- Name: supabase_realtime support_messages; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.support_messages;


--
-- Name: supabase_realtime user_credits; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.user_credits;


--
-- Name: supabase_realtime_messages_publication messages; Type: PUBLICATION TABLE; Schema: realtime; Owner: supabase_admin
--

ALTER PUBLICATION supabase_realtime_messages_publication ADD TABLE ONLY realtime.messages;


--
-- Name: SCHEMA auth; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA auth TO anon;
GRANT USAGE ON SCHEMA auth TO authenticated;
GRANT USAGE ON SCHEMA auth TO service_role;
GRANT ALL ON SCHEMA auth TO supabase_auth_admin;
GRANT ALL ON SCHEMA auth TO dashboard_user;
GRANT USAGE ON SCHEMA auth TO postgres;


--
-- Name: SCHEMA extensions; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA extensions TO anon;
GRANT USAGE ON SCHEMA extensions TO authenticated;
GRANT USAGE ON SCHEMA extensions TO service_role;
GRANT ALL ON SCHEMA extensions TO dashboard_user;


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: pg_database_owner
--

GRANT USAGE ON SCHEMA public TO postgres;
GRANT USAGE ON SCHEMA public TO anon;
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT USAGE ON SCHEMA public TO service_role;


--
-- Name: SCHEMA net; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA net TO supabase_functions_admin;
GRANT USAGE ON SCHEMA net TO postgres;
GRANT USAGE ON SCHEMA net TO anon;
GRANT USAGE ON SCHEMA net TO authenticated;
GRANT USAGE ON SCHEMA net TO service_role;


--
-- Name: SCHEMA realtime; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA realtime TO postgres;
GRANT USAGE ON SCHEMA realtime TO anon;
GRANT USAGE ON SCHEMA realtime TO authenticated;
GRANT USAGE ON SCHEMA realtime TO service_role;
GRANT ALL ON SCHEMA realtime TO supabase_realtime_admin;


--
-- Name: SCHEMA storage; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA storage TO postgres WITH GRANT OPTION;
GRANT USAGE ON SCHEMA storage TO anon;
GRANT USAGE ON SCHEMA storage TO authenticated;
GRANT USAGE ON SCHEMA storage TO service_role;
GRANT ALL ON SCHEMA storage TO supabase_storage_admin;
GRANT ALL ON SCHEMA storage TO dashboard_user;


--
-- Name: SCHEMA vault; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA vault TO postgres WITH GRANT OPTION;
GRANT USAGE ON SCHEMA vault TO service_role;


--
-- Name: FUNCTION box2d_in(cstring); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box2d_in(cstring) TO postgres;
GRANT ALL ON FUNCTION public.box2d_in(cstring) TO anon;
GRANT ALL ON FUNCTION public.box2d_in(cstring) TO authenticated;
GRANT ALL ON FUNCTION public.box2d_in(cstring) TO service_role;


--
-- Name: FUNCTION box2d_out(public.box2d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box2d_out(public.box2d) TO postgres;
GRANT ALL ON FUNCTION public.box2d_out(public.box2d) TO anon;
GRANT ALL ON FUNCTION public.box2d_out(public.box2d) TO authenticated;
GRANT ALL ON FUNCTION public.box2d_out(public.box2d) TO service_role;


--
-- Name: FUNCTION box2df_in(cstring); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box2df_in(cstring) TO postgres;
GRANT ALL ON FUNCTION public.box2df_in(cstring) TO anon;
GRANT ALL ON FUNCTION public.box2df_in(cstring) TO authenticated;
GRANT ALL ON FUNCTION public.box2df_in(cstring) TO service_role;


--
-- Name: FUNCTION box2df_out(public.box2df); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box2df_out(public.box2df) TO postgres;
GRANT ALL ON FUNCTION public.box2df_out(public.box2df) TO anon;
GRANT ALL ON FUNCTION public.box2df_out(public.box2df) TO authenticated;
GRANT ALL ON FUNCTION public.box2df_out(public.box2df) TO service_role;


--
-- Name: FUNCTION box3d_in(cstring); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box3d_in(cstring) TO postgres;
GRANT ALL ON FUNCTION public.box3d_in(cstring) TO anon;
GRANT ALL ON FUNCTION public.box3d_in(cstring) TO authenticated;
GRANT ALL ON FUNCTION public.box3d_in(cstring) TO service_role;


--
-- Name: FUNCTION box3d_out(public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box3d_out(public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.box3d_out(public.box3d) TO anon;
GRANT ALL ON FUNCTION public.box3d_out(public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.box3d_out(public.box3d) TO service_role;


--
-- Name: FUNCTION geography_analyze(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_analyze(internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_analyze(internal) TO anon;
GRANT ALL ON FUNCTION public.geography_analyze(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_analyze(internal) TO service_role;


--
-- Name: FUNCTION geography_in(cstring, oid, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_in(cstring, oid, integer) TO postgres;
GRANT ALL ON FUNCTION public.geography_in(cstring, oid, integer) TO anon;
GRANT ALL ON FUNCTION public.geography_in(cstring, oid, integer) TO authenticated;
GRANT ALL ON FUNCTION public.geography_in(cstring, oid, integer) TO service_role;


--
-- Name: FUNCTION geography_out(public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_out(public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geography_out(public.geography) TO anon;
GRANT ALL ON FUNCTION public.geography_out(public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geography_out(public.geography) TO service_role;


--
-- Name: FUNCTION geography_recv(internal, oid, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_recv(internal, oid, integer) TO postgres;
GRANT ALL ON FUNCTION public.geography_recv(internal, oid, integer) TO anon;
GRANT ALL ON FUNCTION public.geography_recv(internal, oid, integer) TO authenticated;
GRANT ALL ON FUNCTION public.geography_recv(internal, oid, integer) TO service_role;


--
-- Name: FUNCTION geography_send(public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_send(public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geography_send(public.geography) TO anon;
GRANT ALL ON FUNCTION public.geography_send(public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geography_send(public.geography) TO service_role;


--
-- Name: FUNCTION geography_typmod_in(cstring[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_typmod_in(cstring[]) TO postgres;
GRANT ALL ON FUNCTION public.geography_typmod_in(cstring[]) TO anon;
GRANT ALL ON FUNCTION public.geography_typmod_in(cstring[]) TO authenticated;
GRANT ALL ON FUNCTION public.geography_typmod_in(cstring[]) TO service_role;


--
-- Name: FUNCTION geography_typmod_out(integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_typmod_out(integer) TO postgres;
GRANT ALL ON FUNCTION public.geography_typmod_out(integer) TO anon;
GRANT ALL ON FUNCTION public.geography_typmod_out(integer) TO authenticated;
GRANT ALL ON FUNCTION public.geography_typmod_out(integer) TO service_role;


--
-- Name: FUNCTION geometry_analyze(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_analyze(internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_analyze(internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_analyze(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_analyze(internal) TO service_role;


--
-- Name: FUNCTION geometry_in(cstring); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_in(cstring) TO postgres;
GRANT ALL ON FUNCTION public.geometry_in(cstring) TO anon;
GRANT ALL ON FUNCTION public.geometry_in(cstring) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_in(cstring) TO service_role;


--
-- Name: FUNCTION geometry_out(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_out(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_out(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_out(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_out(public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_recv(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_recv(internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_recv(internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_recv(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_recv(internal) TO service_role;


--
-- Name: FUNCTION geometry_send(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_send(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_send(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_send(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_send(public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_typmod_in(cstring[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_typmod_in(cstring[]) TO postgres;
GRANT ALL ON FUNCTION public.geometry_typmod_in(cstring[]) TO anon;
GRANT ALL ON FUNCTION public.geometry_typmod_in(cstring[]) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_typmod_in(cstring[]) TO service_role;


--
-- Name: FUNCTION geometry_typmod_out(integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_typmod_out(integer) TO postgres;
GRANT ALL ON FUNCTION public.geometry_typmod_out(integer) TO anon;
GRANT ALL ON FUNCTION public.geometry_typmod_out(integer) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_typmod_out(integer) TO service_role;


--
-- Name: FUNCTION gidx_in(cstring); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.gidx_in(cstring) TO postgres;
GRANT ALL ON FUNCTION public.gidx_in(cstring) TO anon;
GRANT ALL ON FUNCTION public.gidx_in(cstring) TO authenticated;
GRANT ALL ON FUNCTION public.gidx_in(cstring) TO service_role;


--
-- Name: FUNCTION gidx_out(public.gidx); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.gidx_out(public.gidx) TO postgres;
GRANT ALL ON FUNCTION public.gidx_out(public.gidx) TO anon;
GRANT ALL ON FUNCTION public.gidx_out(public.gidx) TO authenticated;
GRANT ALL ON FUNCTION public.gidx_out(public.gidx) TO service_role;


--
-- Name: FUNCTION spheroid_in(cstring); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.spheroid_in(cstring) TO postgres;
GRANT ALL ON FUNCTION public.spheroid_in(cstring) TO anon;
GRANT ALL ON FUNCTION public.spheroid_in(cstring) TO authenticated;
GRANT ALL ON FUNCTION public.spheroid_in(cstring) TO service_role;


--
-- Name: FUNCTION spheroid_out(public.spheroid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.spheroid_out(public.spheroid) TO postgres;
GRANT ALL ON FUNCTION public.spheroid_out(public.spheroid) TO anon;
GRANT ALL ON FUNCTION public.spheroid_out(public.spheroid) TO authenticated;
GRANT ALL ON FUNCTION public.spheroid_out(public.spheroid) TO service_role;


--
-- Name: FUNCTION box3d(public.box2d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box3d(public.box2d) TO postgres;
GRANT ALL ON FUNCTION public.box3d(public.box2d) TO anon;
GRANT ALL ON FUNCTION public.box3d(public.box2d) TO authenticated;
GRANT ALL ON FUNCTION public.box3d(public.box2d) TO service_role;


--
-- Name: FUNCTION geometry(public.box2d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry(public.box2d) TO postgres;
GRANT ALL ON FUNCTION public.geometry(public.box2d) TO anon;
GRANT ALL ON FUNCTION public.geometry(public.box2d) TO authenticated;
GRANT ALL ON FUNCTION public.geometry(public.box2d) TO service_role;


--
-- Name: FUNCTION box(public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box(public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.box(public.box3d) TO anon;
GRANT ALL ON FUNCTION public.box(public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.box(public.box3d) TO service_role;


--
-- Name: FUNCTION box2d(public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box2d(public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.box2d(public.box3d) TO anon;
GRANT ALL ON FUNCTION public.box2d(public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.box2d(public.box3d) TO service_role;


--
-- Name: FUNCTION geometry(public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry(public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.geometry(public.box3d) TO anon;
GRANT ALL ON FUNCTION public.geometry(public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.geometry(public.box3d) TO service_role;


--
-- Name: FUNCTION geography(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography(bytea) TO postgres;
GRANT ALL ON FUNCTION public.geography(bytea) TO anon;
GRANT ALL ON FUNCTION public.geography(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.geography(bytea) TO service_role;


--
-- Name: FUNCTION geometry(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry(bytea) TO postgres;
GRANT ALL ON FUNCTION public.geometry(bytea) TO anon;
GRANT ALL ON FUNCTION public.geometry(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.geometry(bytea) TO service_role;


--
-- Name: FUNCTION bytea(public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bytea(public.geography) TO postgres;
GRANT ALL ON FUNCTION public.bytea(public.geography) TO anon;
GRANT ALL ON FUNCTION public.bytea(public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.bytea(public.geography) TO service_role;


--
-- Name: FUNCTION geography(public.geography, integer, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography(public.geography, integer, boolean) TO postgres;
GRANT ALL ON FUNCTION public.geography(public.geography, integer, boolean) TO anon;
GRANT ALL ON FUNCTION public.geography(public.geography, integer, boolean) TO authenticated;
GRANT ALL ON FUNCTION public.geography(public.geography, integer, boolean) TO service_role;


--
-- Name: FUNCTION geometry(public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry(public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geometry(public.geography) TO anon;
GRANT ALL ON FUNCTION public.geometry(public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geometry(public.geography) TO service_role;


--
-- Name: FUNCTION box(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.box(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.box(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.box(public.geometry) TO service_role;


--
-- Name: FUNCTION box2d(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box2d(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.box2d(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.box2d(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.box2d(public.geometry) TO service_role;


--
-- Name: FUNCTION box3d(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box3d(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.box3d(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.box3d(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.box3d(public.geometry) TO service_role;


--
-- Name: FUNCTION bytea(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bytea(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.bytea(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.bytea(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.bytea(public.geometry) TO service_role;


--
-- Name: FUNCTION geography(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geography(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geography(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geography(public.geometry) TO service_role;


--
-- Name: FUNCTION geometry(public.geometry, integer, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry(public.geometry, integer, boolean) TO postgres;
GRANT ALL ON FUNCTION public.geometry(public.geometry, integer, boolean) TO anon;
GRANT ALL ON FUNCTION public.geometry(public.geometry, integer, boolean) TO authenticated;
GRANT ALL ON FUNCTION public.geometry(public.geometry, integer, boolean) TO service_role;


--
-- Name: FUNCTION "json"(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public."json"(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public."json"(public.geometry) TO anon;
GRANT ALL ON FUNCTION public."json"(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public."json"(public.geometry) TO service_role;


--
-- Name: FUNCTION jsonb(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.jsonb(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.jsonb(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.jsonb(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.jsonb(public.geometry) TO service_role;


--
-- Name: FUNCTION path(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.path(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.path(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.path(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.path(public.geometry) TO service_role;


--
-- Name: FUNCTION point(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.point(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.point(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.point(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.point(public.geometry) TO service_role;


--
-- Name: FUNCTION polygon(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.polygon(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.polygon(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.polygon(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.polygon(public.geometry) TO service_role;


--
-- Name: FUNCTION text(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.text(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.text(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.text(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.text(public.geometry) TO service_role;


--
-- Name: FUNCTION geometry(path); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry(path) TO postgres;
GRANT ALL ON FUNCTION public.geometry(path) TO anon;
GRANT ALL ON FUNCTION public.geometry(path) TO authenticated;
GRANT ALL ON FUNCTION public.geometry(path) TO service_role;


--
-- Name: FUNCTION geometry(point); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry(point) TO postgres;
GRANT ALL ON FUNCTION public.geometry(point) TO anon;
GRANT ALL ON FUNCTION public.geometry(point) TO authenticated;
GRANT ALL ON FUNCTION public.geometry(point) TO service_role;


--
-- Name: FUNCTION geometry(polygon); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry(polygon) TO postgres;
GRANT ALL ON FUNCTION public.geometry(polygon) TO anon;
GRANT ALL ON FUNCTION public.geometry(polygon) TO authenticated;
GRANT ALL ON FUNCTION public.geometry(polygon) TO service_role;


--
-- Name: FUNCTION geometry(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry(text) TO postgres;
GRANT ALL ON FUNCTION public.geometry(text) TO anon;
GRANT ALL ON FUNCTION public.geometry(text) TO authenticated;
GRANT ALL ON FUNCTION public.geometry(text) TO service_role;


--
-- Name: FUNCTION email(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.email() TO dashboard_user;


--
-- Name: FUNCTION jwt(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.jwt() TO postgres;
GRANT ALL ON FUNCTION auth.jwt() TO dashboard_user;


--
-- Name: FUNCTION role(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.role() TO dashboard_user;


--
-- Name: FUNCTION uid(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.uid() TO dashboard_user;


--
-- Name: FUNCTION armor(bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.armor(bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.armor(bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.armor(bytea) TO dashboard_user;


--
-- Name: FUNCTION armor(bytea, text[], text[]); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.armor(bytea, text[], text[]) FROM postgres;
GRANT ALL ON FUNCTION extensions.armor(bytea, text[], text[]) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.armor(bytea, text[], text[]) TO dashboard_user;


--
-- Name: FUNCTION crypt(text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.crypt(text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.crypt(text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.crypt(text, text) TO dashboard_user;


--
-- Name: FUNCTION dearmor(text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.dearmor(text) FROM postgres;
GRANT ALL ON FUNCTION extensions.dearmor(text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.dearmor(text) TO dashboard_user;


--
-- Name: FUNCTION decrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.decrypt(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.decrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.decrypt(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION decrypt_iv(bytea, bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION digest(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.digest(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.digest(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.digest(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION digest(text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.digest(text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.digest(text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.digest(text, text) TO dashboard_user;


--
-- Name: FUNCTION encrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.encrypt(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.encrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.encrypt(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION encrypt_iv(bytea, bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION gen_random_bytes(integer); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_random_bytes(integer) FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_random_bytes(integer) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_random_bytes(integer) TO dashboard_user;


--
-- Name: FUNCTION gen_random_uuid(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_random_uuid() FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_random_uuid() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_random_uuid() TO dashboard_user;


--
-- Name: FUNCTION gen_salt(text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_salt(text) FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_salt(text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_salt(text) TO dashboard_user;


--
-- Name: FUNCTION gen_salt(text, integer); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_salt(text, integer) FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_salt(text, integer) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_salt(text, integer) TO dashboard_user;


--
-- Name: FUNCTION grant_pg_cron_access(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

REVOKE ALL ON FUNCTION extensions.grant_pg_cron_access() FROM supabase_admin;
GRANT ALL ON FUNCTION extensions.grant_pg_cron_access() TO supabase_admin WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.grant_pg_cron_access() TO dashboard_user;


--
-- Name: FUNCTION grant_pg_graphql_access(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.grant_pg_graphql_access() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION grant_pg_net_access(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

REVOKE ALL ON FUNCTION extensions.grant_pg_net_access() FROM supabase_admin;
GRANT ALL ON FUNCTION extensions.grant_pg_net_access() TO supabase_admin WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.grant_pg_net_access() TO dashboard_user;


--
-- Name: FUNCTION hmac(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.hmac(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.hmac(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.hmac(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION hmac(text, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.hmac(text, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.hmac(text, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.hmac(text, text, text) TO dashboard_user;


--
-- Name: FUNCTION pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone) FROM postgres;
GRANT ALL ON FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone) TO dashboard_user;


--
-- Name: FUNCTION pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone) FROM postgres;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone) TO dashboard_user;


--
-- Name: FUNCTION pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean) FROM postgres;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean) TO dashboard_user;


--
-- Name: FUNCTION pgp_armor_headers(text, OUT key text, OUT value text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text) TO dashboard_user;


--
-- Name: FUNCTION pgp_key_id(bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_key_id(bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_key_id(bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_key_id(bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt(text, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt(text, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt_bytea(bytea, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt_bytea(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt(bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt_bytea(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt_bytea(bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt(text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt(text, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt_bytea(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt_bytea(bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgrst_ddl_watch(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgrst_ddl_watch() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgrst_drop_watch(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgrst_drop_watch() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION set_graphql_placeholder(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.set_graphql_placeholder() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_generate_v1(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v1() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1() TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v1mc(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v1mc() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1mc() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1mc() TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v3(namespace uuid, name text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v3(namespace uuid, name text) FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v3(namespace uuid, name text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v3(namespace uuid, name text) TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v4(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v4() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v4() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v4() TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v5(namespace uuid, name text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v5(namespace uuid, name text) FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v5(namespace uuid, name text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v5(namespace uuid, name text) TO dashboard_user;


--
-- Name: FUNCTION uuid_nil(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_nil() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_nil() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_nil() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_dns(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_dns() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_dns() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_dns() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_oid(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_oid() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_oid() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_oid() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_url(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_url() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_url() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_url() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_x500(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_x500() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_x500() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_x500() TO dashboard_user;


--
-- Name: FUNCTION graphql("operationName" text, query text, variables jsonb, extensions jsonb); Type: ACL; Schema: graphql_public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO postgres;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO anon;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO authenticated;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO service_role;


--
-- Name: FUNCTION get_auth(p_usename text); Type: ACL; Schema: pgbouncer; Owner: supabase_admin
--

REVOKE ALL ON FUNCTION pgbouncer.get_auth(p_usename text) FROM PUBLIC;
GRANT ALL ON FUNCTION pgbouncer.get_auth(p_usename text) TO pgbouncer;


--
-- Name: FUNCTION _postgis_deprecate(oldname text, newname text, version text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._postgis_deprecate(oldname text, newname text, version text) TO postgres;
GRANT ALL ON FUNCTION public._postgis_deprecate(oldname text, newname text, version text) TO anon;
GRANT ALL ON FUNCTION public._postgis_deprecate(oldname text, newname text, version text) TO authenticated;
GRANT ALL ON FUNCTION public._postgis_deprecate(oldname text, newname text, version text) TO service_role;


--
-- Name: FUNCTION _postgis_index_extent(tbl regclass, col text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._postgis_index_extent(tbl regclass, col text) TO postgres;
GRANT ALL ON FUNCTION public._postgis_index_extent(tbl regclass, col text) TO anon;
GRANT ALL ON FUNCTION public._postgis_index_extent(tbl regclass, col text) TO authenticated;
GRANT ALL ON FUNCTION public._postgis_index_extent(tbl regclass, col text) TO service_role;


--
-- Name: FUNCTION _postgis_join_selectivity(regclass, text, regclass, text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._postgis_join_selectivity(regclass, text, regclass, text, text) TO postgres;
GRANT ALL ON FUNCTION public._postgis_join_selectivity(regclass, text, regclass, text, text) TO anon;
GRANT ALL ON FUNCTION public._postgis_join_selectivity(regclass, text, regclass, text, text) TO authenticated;
GRANT ALL ON FUNCTION public._postgis_join_selectivity(regclass, text, regclass, text, text) TO service_role;


--
-- Name: FUNCTION _postgis_pgsql_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._postgis_pgsql_version() TO postgres;
GRANT ALL ON FUNCTION public._postgis_pgsql_version() TO anon;
GRANT ALL ON FUNCTION public._postgis_pgsql_version() TO authenticated;
GRANT ALL ON FUNCTION public._postgis_pgsql_version() TO service_role;


--
-- Name: FUNCTION _postgis_scripts_pgsql_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._postgis_scripts_pgsql_version() TO postgres;
GRANT ALL ON FUNCTION public._postgis_scripts_pgsql_version() TO anon;
GRANT ALL ON FUNCTION public._postgis_scripts_pgsql_version() TO authenticated;
GRANT ALL ON FUNCTION public._postgis_scripts_pgsql_version() TO service_role;


--
-- Name: FUNCTION _postgis_selectivity(tbl regclass, att_name text, geom public.geometry, mode text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._postgis_selectivity(tbl regclass, att_name text, geom public.geometry, mode text) TO postgres;
GRANT ALL ON FUNCTION public._postgis_selectivity(tbl regclass, att_name text, geom public.geometry, mode text) TO anon;
GRANT ALL ON FUNCTION public._postgis_selectivity(tbl regclass, att_name text, geom public.geometry, mode text) TO authenticated;
GRANT ALL ON FUNCTION public._postgis_selectivity(tbl regclass, att_name text, geom public.geometry, mode text) TO service_role;


--
-- Name: FUNCTION _postgis_stats(tbl regclass, att_name text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._postgis_stats(tbl regclass, att_name text, text) TO postgres;
GRANT ALL ON FUNCTION public._postgis_stats(tbl regclass, att_name text, text) TO anon;
GRANT ALL ON FUNCTION public._postgis_stats(tbl regclass, att_name text, text) TO authenticated;
GRANT ALL ON FUNCTION public._postgis_stats(tbl regclass, att_name text, text) TO service_role;


--
-- Name: FUNCTION _st_3ddfullywithin(geom1 public.geometry, geom2 public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_3ddfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public._st_3ddfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public._st_3ddfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public._st_3ddfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION _st_3ddwithin(geom1 public.geometry, geom2 public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_3ddwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public._st_3ddwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public._st_3ddwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public._st_3ddwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION _st_3dintersects(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_3dintersects(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_3dintersects(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_3dintersects(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_3dintersects(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_asgml(integer, public.geometry, integer, integer, text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_asgml(integer, public.geometry, integer, integer, text, text) TO postgres;
GRANT ALL ON FUNCTION public._st_asgml(integer, public.geometry, integer, integer, text, text) TO anon;
GRANT ALL ON FUNCTION public._st_asgml(integer, public.geometry, integer, integer, text, text) TO authenticated;
GRANT ALL ON FUNCTION public._st_asgml(integer, public.geometry, integer, integer, text, text) TO service_role;


--
-- Name: FUNCTION _st_asx3d(integer, public.geometry, integer, integer, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_asx3d(integer, public.geometry, integer, integer, text) TO postgres;
GRANT ALL ON FUNCTION public._st_asx3d(integer, public.geometry, integer, integer, text) TO anon;
GRANT ALL ON FUNCTION public._st_asx3d(integer, public.geometry, integer, integer, text) TO authenticated;
GRANT ALL ON FUNCTION public._st_asx3d(integer, public.geometry, integer, integer, text) TO service_role;


--
-- Name: FUNCTION _st_bestsrid(public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_bestsrid(public.geography) TO postgres;
GRANT ALL ON FUNCTION public._st_bestsrid(public.geography) TO anon;
GRANT ALL ON FUNCTION public._st_bestsrid(public.geography) TO authenticated;
GRANT ALL ON FUNCTION public._st_bestsrid(public.geography) TO service_role;


--
-- Name: FUNCTION _st_bestsrid(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_bestsrid(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public._st_bestsrid(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public._st_bestsrid(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public._st_bestsrid(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION _st_contains(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_contains(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_contains(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_contains(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_contains(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_containsproperly(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_containsproperly(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_containsproperly(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_containsproperly(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_containsproperly(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_coveredby(geog1 public.geography, geog2 public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_coveredby(geog1 public.geography, geog2 public.geography) TO postgres;
GRANT ALL ON FUNCTION public._st_coveredby(geog1 public.geography, geog2 public.geography) TO anon;
GRANT ALL ON FUNCTION public._st_coveredby(geog1 public.geography, geog2 public.geography) TO authenticated;
GRANT ALL ON FUNCTION public._st_coveredby(geog1 public.geography, geog2 public.geography) TO service_role;


--
-- Name: FUNCTION _st_coveredby(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_coveredby(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_coveredby(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_coveredby(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_coveredby(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_covers(geog1 public.geography, geog2 public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_covers(geog1 public.geography, geog2 public.geography) TO postgres;
GRANT ALL ON FUNCTION public._st_covers(geog1 public.geography, geog2 public.geography) TO anon;
GRANT ALL ON FUNCTION public._st_covers(geog1 public.geography, geog2 public.geography) TO authenticated;
GRANT ALL ON FUNCTION public._st_covers(geog1 public.geography, geog2 public.geography) TO service_role;


--
-- Name: FUNCTION _st_covers(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_covers(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_covers(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_covers(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_covers(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_crosses(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_crosses(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_crosses(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_crosses(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_crosses(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_dfullywithin(geom1 public.geometry, geom2 public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_dfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public._st_dfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public._st_dfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public._st_dfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION _st_distancetree(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_distancetree(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public._st_distancetree(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public._st_distancetree(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public._st_distancetree(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION _st_distancetree(public.geography, public.geography, double precision, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_distancetree(public.geography, public.geography, double precision, boolean) TO postgres;
GRANT ALL ON FUNCTION public._st_distancetree(public.geography, public.geography, double precision, boolean) TO anon;
GRANT ALL ON FUNCTION public._st_distancetree(public.geography, public.geography, double precision, boolean) TO authenticated;
GRANT ALL ON FUNCTION public._st_distancetree(public.geography, public.geography, double precision, boolean) TO service_role;


--
-- Name: FUNCTION _st_distanceuncached(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION _st_distanceuncached(public.geography, public.geography, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography, boolean) TO postgres;
GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography, boolean) TO anon;
GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography, boolean) TO authenticated;
GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography, boolean) TO service_role;


--
-- Name: FUNCTION _st_distanceuncached(public.geography, public.geography, double precision, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography, double precision, boolean) TO postgres;
GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography, double precision, boolean) TO anon;
GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography, double precision, boolean) TO authenticated;
GRANT ALL ON FUNCTION public._st_distanceuncached(public.geography, public.geography, double precision, boolean) TO service_role;


--
-- Name: FUNCTION _st_dwithin(geom1 public.geometry, geom2 public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_dwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public._st_dwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public._st_dwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public._st_dwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION _st_dwithin(geog1 public.geography, geog2 public.geography, tolerance double precision, use_spheroid boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_dwithin(geog1 public.geography, geog2 public.geography, tolerance double precision, use_spheroid boolean) TO postgres;
GRANT ALL ON FUNCTION public._st_dwithin(geog1 public.geography, geog2 public.geography, tolerance double precision, use_spheroid boolean) TO anon;
GRANT ALL ON FUNCTION public._st_dwithin(geog1 public.geography, geog2 public.geography, tolerance double precision, use_spheroid boolean) TO authenticated;
GRANT ALL ON FUNCTION public._st_dwithin(geog1 public.geography, geog2 public.geography, tolerance double precision, use_spheroid boolean) TO service_role;


--
-- Name: FUNCTION _st_dwithinuncached(public.geography, public.geography, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_dwithinuncached(public.geography, public.geography, double precision) TO postgres;
GRANT ALL ON FUNCTION public._st_dwithinuncached(public.geography, public.geography, double precision) TO anon;
GRANT ALL ON FUNCTION public._st_dwithinuncached(public.geography, public.geography, double precision) TO authenticated;
GRANT ALL ON FUNCTION public._st_dwithinuncached(public.geography, public.geography, double precision) TO service_role;


--
-- Name: FUNCTION _st_dwithinuncached(public.geography, public.geography, double precision, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_dwithinuncached(public.geography, public.geography, double precision, boolean) TO postgres;
GRANT ALL ON FUNCTION public._st_dwithinuncached(public.geography, public.geography, double precision, boolean) TO anon;
GRANT ALL ON FUNCTION public._st_dwithinuncached(public.geography, public.geography, double precision, boolean) TO authenticated;
GRANT ALL ON FUNCTION public._st_dwithinuncached(public.geography, public.geography, double precision, boolean) TO service_role;


--
-- Name: FUNCTION _st_equals(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_equals(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_equals(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_equals(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_equals(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_expand(public.geography, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_expand(public.geography, double precision) TO postgres;
GRANT ALL ON FUNCTION public._st_expand(public.geography, double precision) TO anon;
GRANT ALL ON FUNCTION public._st_expand(public.geography, double precision) TO authenticated;
GRANT ALL ON FUNCTION public._st_expand(public.geography, double precision) TO service_role;


--
-- Name: FUNCTION _st_geomfromgml(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_geomfromgml(text, integer) TO postgres;
GRANT ALL ON FUNCTION public._st_geomfromgml(text, integer) TO anon;
GRANT ALL ON FUNCTION public._st_geomfromgml(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public._st_geomfromgml(text, integer) TO service_role;


--
-- Name: FUNCTION _st_intersects(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_intersects(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_intersects(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_intersects(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_intersects(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_linecrossingdirection(line1 public.geometry, line2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_linecrossingdirection(line1 public.geometry, line2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_linecrossingdirection(line1 public.geometry, line2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_linecrossingdirection(line1 public.geometry, line2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_linecrossingdirection(line1 public.geometry, line2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_longestline(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_longestline(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_longestline(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_longestline(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_longestline(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_maxdistance(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_maxdistance(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_maxdistance(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_maxdistance(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_maxdistance(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_orderingequals(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_orderingequals(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_orderingequals(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_orderingequals(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_orderingequals(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_overlaps(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_overlaps(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_overlaps(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_overlaps(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_overlaps(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_pointoutside(public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_pointoutside(public.geography) TO postgres;
GRANT ALL ON FUNCTION public._st_pointoutside(public.geography) TO anon;
GRANT ALL ON FUNCTION public._st_pointoutside(public.geography) TO authenticated;
GRANT ALL ON FUNCTION public._st_pointoutside(public.geography) TO service_role;


--
-- Name: FUNCTION _st_sortablehash(geom public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_sortablehash(geom public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_sortablehash(geom public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_sortablehash(geom public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_sortablehash(geom public.geometry) TO service_role;


--
-- Name: FUNCTION _st_touches(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_touches(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_touches(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_touches(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_touches(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION _st_voronoi(g1 public.geometry, clip public.geometry, tolerance double precision, return_polygons boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_voronoi(g1 public.geometry, clip public.geometry, tolerance double precision, return_polygons boolean) TO postgres;
GRANT ALL ON FUNCTION public._st_voronoi(g1 public.geometry, clip public.geometry, tolerance double precision, return_polygons boolean) TO anon;
GRANT ALL ON FUNCTION public._st_voronoi(g1 public.geometry, clip public.geometry, tolerance double precision, return_polygons boolean) TO authenticated;
GRANT ALL ON FUNCTION public._st_voronoi(g1 public.geometry, clip public.geometry, tolerance double precision, return_polygons boolean) TO service_role;


--
-- Name: FUNCTION _st_within(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public._st_within(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public._st_within(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public._st_within(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public._st_within(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION accept_contact_invitation(p_contact_id uuid, p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.accept_contact_invitation(p_contact_id uuid, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.accept_contact_invitation(p_contact_id uuid, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.accept_contact_invitation(p_contact_id uuid, p_user_id uuid) TO service_role;


--
-- Name: FUNCTION accept_contact_request(p_request_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.accept_contact_request(p_request_id uuid) TO anon;
GRANT ALL ON FUNCTION public.accept_contact_request(p_request_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.accept_contact_request(p_request_id uuid) TO service_role;


--
-- Name: FUNCTION add_credits(p_user_id uuid, p_amount integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.add_credits(p_user_id uuid, p_amount integer) TO anon;
GRANT ALL ON FUNCTION public.add_credits(p_user_id uuid, p_amount integer) TO authenticated;
GRANT ALL ON FUNCTION public.add_credits(p_user_id uuid, p_amount integer) TO service_role;


--
-- Name: FUNCTION add_credits(p_user_id uuid, p_amount integer, p_description text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.add_credits(p_user_id uuid, p_amount integer, p_description text) TO anon;
GRANT ALL ON FUNCTION public.add_credits(p_user_id uuid, p_amount integer, p_description text) TO authenticated;
GRANT ALL ON FUNCTION public.add_credits(p_user_id uuid, p_amount integer, p_description text) TO service_role;


--
-- Name: FUNCTION add_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_transaction_type text, p_reference_type text, p_reference_id text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.add_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_transaction_type text, p_reference_type text, p_reference_id text) TO anon;
GRANT ALL ON FUNCTION public.add_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_transaction_type text, p_reference_type text, p_reference_id text) TO authenticated;
GRANT ALL ON FUNCTION public.add_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_transaction_type text, p_reference_type text, p_reference_id text) TO service_role;


--
-- Name: FUNCTION add_credits_with_expiration(p_user_id uuid, p_credits integer, p_package_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.add_credits_with_expiration(p_user_id uuid, p_credits integer, p_package_id uuid) TO anon;
GRANT ALL ON FUNCTION public.add_credits_with_expiration(p_user_id uuid, p_credits integer, p_package_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.add_credits_with_expiration(p_user_id uuid, p_credits integer, p_package_id uuid) TO service_role;


--
-- Name: FUNCTION addauth(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.addauth(text) TO postgres;
GRANT ALL ON FUNCTION public.addauth(text) TO anon;
GRANT ALL ON FUNCTION public.addauth(text) TO authenticated;
GRANT ALL ON FUNCTION public.addauth(text) TO service_role;


--
-- Name: FUNCTION addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean) TO postgres;
GRANT ALL ON FUNCTION public.addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean) TO anon;
GRANT ALL ON FUNCTION public.addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean) TO authenticated;
GRANT ALL ON FUNCTION public.addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean) TO service_role;


--
-- Name: FUNCTION addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean) TO postgres;
GRANT ALL ON FUNCTION public.addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean) TO anon;
GRANT ALL ON FUNCTION public.addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean) TO authenticated;
GRANT ALL ON FUNCTION public.addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean) TO service_role;


--
-- Name: FUNCTION addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean) TO postgres;
GRANT ALL ON FUNCTION public.addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean) TO anon;
GRANT ALL ON FUNCTION public.addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean) TO authenticated;
GRANT ALL ON FUNCTION public.addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean) TO service_role;


--
-- Name: FUNCTION admin_adjust_credits(p_email text, p_delta integer, p_description text, p_reference_id uuid, p_reference_type text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.admin_adjust_credits(p_email text, p_delta integer, p_description text, p_reference_id uuid, p_reference_type text) TO anon;
GRANT ALL ON FUNCTION public.admin_adjust_credits(p_email text, p_delta integer, p_description text, p_reference_id uuid, p_reference_type text) TO authenticated;
GRANT ALL ON FUNCTION public.admin_adjust_credits(p_email text, p_delta integer, p_description text, p_reference_id uuid, p_reference_type text) TO service_role;


--
-- Name: FUNCTION admin_adjust_credits_by_user_id(p_user_id uuid, p_delta integer, p_description text, p_reference_id uuid, p_reference_type text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.admin_adjust_credits_by_user_id(p_user_id uuid, p_delta integer, p_description text, p_reference_id uuid, p_reference_type text) TO anon;
GRANT ALL ON FUNCTION public.admin_adjust_credits_by_user_id(p_user_id uuid, p_delta integer, p_description text, p_reference_id uuid, p_reference_type text) TO authenticated;
GRANT ALL ON FUNCTION public.admin_adjust_credits_by_user_id(p_user_id uuid, p_delta integer, p_description text, p_reference_id uuid, p_reference_type text) TO service_role;


--
-- Name: FUNCTION assign_credits_for_plan(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.assign_credits_for_plan() TO anon;
GRANT ALL ON FUNCTION public.assign_credits_for_plan() TO authenticated;
GRANT ALL ON FUNCTION public.assign_credits_for_plan() TO service_role;


--
-- Name: FUNCTION auto_create_ride_offer_from_mission(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.auto_create_ride_offer_from_mission() TO anon;
GRANT ALL ON FUNCTION public.auto_create_ride_offer_from_mission() TO authenticated;
GRANT ALL ON FUNCTION public.auto_create_ride_offer_from_mission() TO service_role;


--
-- Name: FUNCTION auto_fill_legal_mentions(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.auto_fill_legal_mentions() TO anon;
GRANT ALL ON FUNCTION public.auto_fill_legal_mentions() TO authenticated;
GRANT ALL ON FUNCTION public.auto_fill_legal_mentions() TO service_role;


--
-- Name: FUNCTION auto_generate_report_on_session_end(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.auto_generate_report_on_session_end() TO anon;
GRANT ALL ON FUNCTION public.auto_generate_report_on_session_end() TO authenticated;
GRANT ALL ON FUNCTION public.auto_generate_report_on_session_end() TO service_role;


--
-- Name: FUNCTION auto_generate_share_code(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.auto_generate_share_code() TO anon;
GRANT ALL ON FUNCTION public.auto_generate_share_code() TO authenticated;
GRANT ALL ON FUNCTION public.auto_generate_share_code() TO service_role;


--
-- Name: FUNCTION box3dtobox(public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.box3dtobox(public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.box3dtobox(public.box3d) TO anon;
GRANT ALL ON FUNCTION public.box3dtobox(public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.box3dtobox(public.box3d) TO service_role;


--
-- Name: FUNCTION bytea_to_text(data bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bytea_to_text(data bytea) TO postgres;
GRANT ALL ON FUNCTION public.bytea_to_text(data bytea) TO anon;
GRANT ALL ON FUNCTION public.bytea_to_text(data bytea) TO authenticated;
GRANT ALL ON FUNCTION public.bytea_to_text(data bytea) TO service_role;


--
-- Name: FUNCTION calculate_distance_km(lat1 numeric, lon1 numeric, lat2 numeric, lon2 numeric); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_distance_km(lat1 numeric, lon1 numeric, lat2 numeric, lon2 numeric) TO anon;
GRANT ALL ON FUNCTION public.calculate_distance_km(lat1 numeric, lon1 numeric, lat2 numeric, lon2 numeric) TO authenticated;
GRANT ALL ON FUNCTION public.calculate_distance_km(lat1 numeric, lon1 numeric, lat2 numeric, lon2 numeric) TO service_role;


--
-- Name: FUNCTION calculate_driver_rating(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_driver_rating(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.calculate_driver_rating(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.calculate_driver_rating(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION calculate_planning_eta(p_planning_id uuid, p_user_lat double precision, p_user_lng double precision); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_planning_eta(p_planning_id uuid, p_user_lat double precision, p_user_lng double precision) TO anon;
GRANT ALL ON FUNCTION public.calculate_planning_eta(p_planning_id uuid, p_user_lat double precision, p_user_lng double precision) TO authenticated;
GRANT ALL ON FUNCTION public.calculate_planning_eta(p_planning_id uuid, p_user_lat double precision, p_user_lng double precision) TO service_role;


--
-- Name: FUNCTION calculate_profile_completion(profile_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_profile_completion(profile_id uuid) TO anon;
GRANT ALL ON FUNCTION public.calculate_profile_completion(profile_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.calculate_profile_completion(profile_id uuid) TO service_role;


--
-- Name: FUNCTION calculate_quote_total_distance(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_quote_total_distance() TO anon;
GRANT ALL ON FUNCTION public.calculate_quote_total_distance() TO authenticated;
GRANT ALL ON FUNCTION public.calculate_quote_total_distance() TO service_role;


--
-- Name: FUNCTION calculate_vat(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_vat() TO anon;
GRANT ALL ON FUNCTION public.calculate_vat() TO authenticated;
GRANT ALL ON FUNCTION public.calculate_vat() TO service_role;


--
-- Name: FUNCTION check_assignment_rules(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_assignment_rules() TO anon;
GRANT ALL ON FUNCTION public.check_assignment_rules() TO authenticated;
GRANT ALL ON FUNCTION public.check_assignment_rules() TO service_role;


--
-- Name: FUNCTION check_email_available(p_email text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_email_available(p_email text) TO anon;
GRANT ALL ON FUNCTION public.check_email_available(p_email text) TO authenticated;
GRANT ALL ON FUNCTION public.check_email_available(p_email text) TO service_role;


--
-- Name: FUNCTION check_existing_user(p_email text, p_phone text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_existing_user(p_email text, p_phone text) TO anon;
GRANT ALL ON FUNCTION public.check_existing_user(p_email text, p_phone text) TO authenticated;
GRANT ALL ON FUNCTION public.check_existing_user(p_email text, p_phone text) TO service_role;


--
-- Name: FUNCTION check_phone_usage_count(p_phone text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_phone_usage_count(p_phone text) TO anon;
GRANT ALL ON FUNCTION public.check_phone_usage_count(p_phone text) TO authenticated;
GRANT ALL ON FUNCTION public.check_phone_usage_count(p_phone text) TO service_role;


--
-- Name: FUNCTION check_signup_fraud(p_email text, p_phone text, p_siret text, p_device_fingerprint text, p_ip_address text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_signup_fraud(p_email text, p_phone text, p_siret text, p_device_fingerprint text, p_ip_address text) TO anon;
GRANT ALL ON FUNCTION public.check_signup_fraud(p_email text, p_phone text, p_siret text, p_device_fingerprint text, p_ip_address text) TO authenticated;
GRANT ALL ON FUNCTION public.check_signup_fraud(p_email text, p_phone text, p_siret text, p_device_fingerprint text, p_ip_address text) TO service_role;


--
-- Name: FUNCTION check_signup_system_health(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_signup_system_health() TO anon;
GRANT ALL ON FUNCTION public.check_signup_system_health() TO authenticated;
GRANT ALL ON FUNCTION public.check_signup_system_health() TO service_role;


--
-- Name: FUNCTION check_siret_available(p_siret text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_siret_available(p_siret text) TO anon;
GRANT ALL ON FUNCTION public.check_siret_available(p_siret text) TO authenticated;
GRANT ALL ON FUNCTION public.check_siret_available(p_siret text) TO service_role;


--
-- Name: FUNCTION check_trip_full(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_trip_full() TO anon;
GRANT ALL ON FUNCTION public.check_trip_full() TO authenticated;
GRANT ALL ON FUNCTION public.check_trip_full() TO service_role;


--
-- Name: FUNCTION checkauth(text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.checkauth(text, text) TO postgres;
GRANT ALL ON FUNCTION public.checkauth(text, text) TO anon;
GRANT ALL ON FUNCTION public.checkauth(text, text) TO authenticated;
GRANT ALL ON FUNCTION public.checkauth(text, text) TO service_role;


--
-- Name: FUNCTION checkauth(text, text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.checkauth(text, text, text) TO postgres;
GRANT ALL ON FUNCTION public.checkauth(text, text, text) TO anon;
GRANT ALL ON FUNCTION public.checkauth(text, text, text) TO authenticated;
GRANT ALL ON FUNCTION public.checkauth(text, text, text) TO service_role;


--
-- Name: FUNCTION checkauthtrigger(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.checkauthtrigger() TO postgres;
GRANT ALL ON FUNCTION public.checkauthtrigger() TO anon;
GRANT ALL ON FUNCTION public.checkauthtrigger() TO authenticated;
GRANT ALL ON FUNCTION public.checkauthtrigger() TO service_role;


--
-- Name: FUNCTION claim_mission(p_code text, p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.claim_mission(p_code text, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.claim_mission(p_code text, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.claim_mission(p_code text, p_user_id uuid) TO service_role;


--
-- Name: FUNCTION cleanup_expired_alerts(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_expired_alerts() TO anon;
GRANT ALL ON FUNCTION public.cleanup_expired_alerts() TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_expired_alerts() TO service_role;


--
-- Name: FUNCTION cleanup_expired_phone_verifications(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_expired_phone_verifications() TO anon;
GRANT ALL ON FUNCTION public.cleanup_expired_phone_verifications() TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_expired_phone_verifications() TO service_role;


--
-- Name: FUNCTION cleanup_expired_tracking_links(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_expired_tracking_links() TO anon;
GRANT ALL ON FUNCTION public.cleanup_expired_tracking_links() TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_expired_tracking_links() TO service_role;


--
-- Name: FUNCTION cleanup_inactive_tracking(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_inactive_tracking() TO anon;
GRANT ALL ON FUNCTION public.cleanup_inactive_tracking() TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_inactive_tracking() TO service_role;


--
-- Name: FUNCTION cleanup_old_ai_requests(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_old_ai_requests() TO anon;
GRANT ALL ON FUNCTION public.cleanup_old_ai_requests() TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_old_ai_requests() TO service_role;


--
-- Name: FUNCTION cleanup_old_documents(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_old_documents() TO anon;
GRANT ALL ON FUNCTION public.cleanup_old_documents() TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_old_documents() TO service_role;


--
-- Name: FUNCTION cleanup_old_gps_data(p_retention_days integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_old_gps_data(p_retention_days integer) TO anon;
GRANT ALL ON FUNCTION public.cleanup_old_gps_data(p_retention_days integer) TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_old_gps_data(p_retention_days integer) TO service_role;


--
-- Name: FUNCTION cleanup_old_pdfs(days_old integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_old_pdfs(days_old integer) TO anon;
GRANT ALL ON FUNCTION public.cleanup_old_pdfs(days_old integer) TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_old_pdfs(days_old integer) TO service_role;


--
-- Name: FUNCTION cleanup_old_tracking_history(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_old_tracking_history() TO anon;
GRANT ALL ON FUNCTION public.cleanup_old_tracking_history() TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_old_tracking_history() TO service_role;


--
-- Name: FUNCTION close_mission_after_arrival(p_mission_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.close_mission_after_arrival(p_mission_id uuid) TO anon;
GRANT ALL ON FUNCTION public.close_mission_after_arrival(p_mission_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.close_mission_after_arrival(p_mission_id uuid) TO service_role;


--
-- Name: FUNCTION complete_mission(p_mission_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.complete_mission(p_mission_id uuid) TO anon;
GRANT ALL ON FUNCTION public.complete_mission(p_mission_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.complete_mission(p_mission_id uuid) TO service_role;


--
-- Name: FUNCTION compute_planning_expires_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.compute_planning_expires_at() TO anon;
GRANT ALL ON FUNCTION public.compute_planning_expires_at() TO authenticated;
GRANT ALL ON FUNCTION public.compute_planning_expires_at() TO service_role;


--
-- Name: FUNCTION contains_2d(public.box2df, public.box2df); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.contains_2d(public.box2df, public.box2df) TO postgres;
GRANT ALL ON FUNCTION public.contains_2d(public.box2df, public.box2df) TO anon;
GRANT ALL ON FUNCTION public.contains_2d(public.box2df, public.box2df) TO authenticated;
GRANT ALL ON FUNCTION public.contains_2d(public.box2df, public.box2df) TO service_role;


--
-- Name: FUNCTION contains_2d(public.box2df, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.contains_2d(public.box2df, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.contains_2d(public.box2df, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.contains_2d(public.box2df, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.contains_2d(public.box2df, public.geometry) TO service_role;


--
-- Name: FUNCTION contains_2d(public.geometry, public.box2df); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.contains_2d(public.geometry, public.box2df) TO postgres;
GRANT ALL ON FUNCTION public.contains_2d(public.geometry, public.box2df) TO anon;
GRANT ALL ON FUNCTION public.contains_2d(public.geometry, public.box2df) TO authenticated;
GRANT ALL ON FUNCTION public.contains_2d(public.geometry, public.box2df) TO service_role;


--
-- Name: FUNCTION convert_quote_to_mission(quote_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.convert_quote_to_mission(quote_id uuid) TO anon;
GRANT ALL ON FUNCTION public.convert_quote_to_mission(quote_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.convert_quote_to_mission(quote_id uuid) TO service_role;


--
-- Name: FUNCTION create_calendar_event_on_assignment(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_calendar_event_on_assignment() TO anon;
GRANT ALL ON FUNCTION public.create_calendar_event_on_assignment() TO authenticated;
GRANT ALL ON FUNCTION public.create_calendar_event_on_assignment() TO service_role;


--
-- Name: FUNCTION create_contact_invitation(p_inviter_id uuid, p_invited_user_id uuid, p_contact_type text, p_name text, p_email text, p_phone text, p_company text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_contact_invitation(p_inviter_id uuid, p_invited_user_id uuid, p_contact_type text, p_name text, p_email text, p_phone text, p_company text) TO anon;
GRANT ALL ON FUNCTION public.create_contact_invitation(p_inviter_id uuid, p_invited_user_id uuid, p_contact_type text, p_name text, p_email text, p_phone text, p_company text) TO authenticated;
GRANT ALL ON FUNCTION public.create_contact_invitation(p_inviter_id uuid, p_invited_user_id uuid, p_contact_type text, p_name text, p_email text, p_phone text, p_company text) TO service_role;


--
-- Name: FUNCTION create_contact_request(p_requester_id uuid, p_target_email text, p_target_name text, p_message text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_contact_request(p_requester_id uuid, p_target_email text, p_target_name text, p_message text) TO anon;
GRANT ALL ON FUNCTION public.create_contact_request(p_requester_id uuid, p_target_email text, p_target_name text, p_message text) TO authenticated;
GRANT ALL ON FUNCTION public.create_contact_request(p_requester_id uuid, p_target_email text, p_target_name text, p_message text) TO service_role;


--
-- Name: FUNCTION create_or_get_inspection_share(p_mission_id uuid, p_user_id uuid, p_report_type text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_or_get_inspection_share(p_mission_id uuid, p_user_id uuid, p_report_type text) TO anon;
GRANT ALL ON FUNCTION public.create_or_get_inspection_share(p_mission_id uuid, p_user_id uuid, p_report_type text) TO authenticated;
GRANT ALL ON FUNCTION public.create_or_get_inspection_share(p_mission_id uuid, p_user_id uuid, p_report_type text) TO service_role;


--
-- Name: FUNCTION create_or_update_public_report(p_mission_id uuid, p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_or_update_public_report(p_mission_id uuid, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.create_or_update_public_report(p_mission_id uuid, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.create_or_update_public_report(p_mission_id uuid, p_user_id uuid) TO service_role;


--
-- Name: FUNCTION create_profile_for_existing_user(user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_profile_for_existing_user(user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.create_profile_for_existing_user(user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.create_profile_for_existing_user(user_id uuid) TO service_role;


--
-- Name: FUNCTION daily_tracking_cleanup(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.daily_tracking_cleanup() TO anon;
GRANT ALL ON FUNCTION public.daily_tracking_cleanup() TO authenticated;
GRANT ALL ON FUNCTION public.daily_tracking_cleanup() TO service_role;


--
-- Name: FUNCTION deactivate_unpopular_alerts(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.deactivate_unpopular_alerts() TO anon;
GRANT ALL ON FUNCTION public.deactivate_unpopular_alerts() TO authenticated;
GRANT ALL ON FUNCTION public.deactivate_unpopular_alerts() TO service_role;


--
-- Name: FUNCTION deduct_credits(p_user_id uuid, p_amount integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.deduct_credits(p_user_id uuid, p_amount integer) TO anon;
GRANT ALL ON FUNCTION public.deduct_credits(p_user_id uuid, p_amount integer) TO authenticated;
GRANT ALL ON FUNCTION public.deduct_credits(p_user_id uuid, p_amount integer) TO service_role;


--
-- Name: FUNCTION deduct_credits(p_user_id uuid, p_amount integer, p_description text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.deduct_credits(p_user_id uuid, p_amount integer, p_description text) TO anon;
GRANT ALL ON FUNCTION public.deduct_credits(p_user_id uuid, p_amount integer, p_description text) TO authenticated;
GRANT ALL ON FUNCTION public.deduct_credits(p_user_id uuid, p_amount integer, p_description text) TO service_role;


--
-- Name: FUNCTION deduct_credits(p_user_id uuid, p_feature_key text, p_reference_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.deduct_credits(p_user_id uuid, p_feature_key text, p_reference_id uuid) TO anon;
GRANT ALL ON FUNCTION public.deduct_credits(p_user_id uuid, p_feature_key text, p_reference_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.deduct_credits(p_user_id uuid, p_feature_key text, p_reference_id uuid) TO service_role;


--
-- Name: FUNCTION delete_availability(p_user_id uuid, p_date date); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.delete_availability(p_user_id uuid, p_date date) TO anon;
GRANT ALL ON FUNCTION public.delete_availability(p_user_id uuid, p_date date) TO authenticated;
GRANT ALL ON FUNCTION public.delete_availability(p_user_id uuid, p_date date) TO service_role;


--
-- Name: FUNCTION detect_stop_zones(p_session_id uuid, p_min_duration_minutes integer, p_max_speed_kmh double precision); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.detect_stop_zones(p_session_id uuid, p_min_duration_minutes integer, p_max_speed_kmh double precision) TO anon;
GRANT ALL ON FUNCTION public.detect_stop_zones(p_session_id uuid, p_min_duration_minutes integer, p_max_speed_kmh double precision) TO authenticated;
GRANT ALL ON FUNCTION public.detect_stop_zones(p_session_id uuid, p_min_duration_minutes integer, p_max_speed_kmh double precision) TO service_role;


--
-- Name: FUNCTION detect_suspicious_behavior(p_email text, p_phone text, p_ip_address text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.detect_suspicious_behavior(p_email text, p_phone text, p_ip_address text) TO anon;
GRANT ALL ON FUNCTION public.detect_suspicious_behavior(p_email text, p_phone text, p_ip_address text) TO authenticated;
GRANT ALL ON FUNCTION public.detect_suspicious_behavior(p_email text, p_phone text, p_ip_address text) TO service_role;


--
-- Name: FUNCTION disablelongtransactions(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.disablelongtransactions() TO postgres;
GRANT ALL ON FUNCTION public.disablelongtransactions() TO anon;
GRANT ALL ON FUNCTION public.disablelongtransactions() TO authenticated;
GRANT ALL ON FUNCTION public.disablelongtransactions() TO service_role;


--
-- Name: FUNCTION distribute_subscription_credits(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.distribute_subscription_credits() TO anon;
GRANT ALL ON FUNCTION public.distribute_subscription_credits() TO authenticated;
GRANT ALL ON FUNCTION public.distribute_subscription_credits() TO service_role;


--
-- Name: FUNCTION dropgeometrycolumn(table_name character varying, column_name character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.dropgeometrycolumn(table_name character varying, column_name character varying) TO postgres;
GRANT ALL ON FUNCTION public.dropgeometrycolumn(table_name character varying, column_name character varying) TO anon;
GRANT ALL ON FUNCTION public.dropgeometrycolumn(table_name character varying, column_name character varying) TO authenticated;
GRANT ALL ON FUNCTION public.dropgeometrycolumn(table_name character varying, column_name character varying) TO service_role;


--
-- Name: FUNCTION dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying) TO postgres;
GRANT ALL ON FUNCTION public.dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying) TO anon;
GRANT ALL ON FUNCTION public.dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying) TO authenticated;
GRANT ALL ON FUNCTION public.dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying) TO service_role;


--
-- Name: FUNCTION dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying) TO postgres;
GRANT ALL ON FUNCTION public.dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying) TO anon;
GRANT ALL ON FUNCTION public.dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying) TO authenticated;
GRANT ALL ON FUNCTION public.dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying) TO service_role;


--
-- Name: FUNCTION dropgeometrytable(table_name character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.dropgeometrytable(table_name character varying) TO postgres;
GRANT ALL ON FUNCTION public.dropgeometrytable(table_name character varying) TO anon;
GRANT ALL ON FUNCTION public.dropgeometrytable(table_name character varying) TO authenticated;
GRANT ALL ON FUNCTION public.dropgeometrytable(table_name character varying) TO service_role;


--
-- Name: FUNCTION dropgeometrytable(schema_name character varying, table_name character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.dropgeometrytable(schema_name character varying, table_name character varying) TO postgres;
GRANT ALL ON FUNCTION public.dropgeometrytable(schema_name character varying, table_name character varying) TO anon;
GRANT ALL ON FUNCTION public.dropgeometrytable(schema_name character varying, table_name character varying) TO authenticated;
GRANT ALL ON FUNCTION public.dropgeometrytable(schema_name character varying, table_name character varying) TO service_role;


--
-- Name: FUNCTION dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying) TO postgres;
GRANT ALL ON FUNCTION public.dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying) TO anon;
GRANT ALL ON FUNCTION public.dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying) TO authenticated;
GRANT ALL ON FUNCTION public.dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying) TO service_role;


--
-- Name: FUNCTION enablelongtransactions(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.enablelongtransactions() TO postgres;
GRANT ALL ON FUNCTION public.enablelongtransactions() TO anon;
GRANT ALL ON FUNCTION public.enablelongtransactions() TO authenticated;
GRANT ALL ON FUNCTION public.enablelongtransactions() TO service_role;


--
-- Name: FUNCTION equals(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.equals(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.equals(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.equals(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.equals(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION expire_old_quotes(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.expire_old_quotes() TO anon;
GRANT ALL ON FUNCTION public.expire_old_quotes() TO authenticated;
GRANT ALL ON FUNCTION public.expire_old_quotes() TO service_role;


--
-- Name: FUNCTION expire_old_ride_entries(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.expire_old_ride_entries() TO anon;
GRANT ALL ON FUNCTION public.expire_old_ride_entries() TO authenticated;
GRANT ALL ON FUNCTION public.expire_old_ride_entries() TO service_role;


--
-- Name: FUNCTION find_planning_matches(p_planning_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.find_planning_matches(p_planning_id uuid) TO anon;
GRANT ALL ON FUNCTION public.find_planning_matches(p_planning_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.find_planning_matches(p_planning_id uuid) TO service_role;


--
-- Name: FUNCTION find_ride_matches_for_request(p_request_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.find_ride_matches_for_request(p_request_id uuid) TO anon;
GRANT ALL ON FUNCTION public.find_ride_matches_for_request(p_request_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.find_ride_matches_for_request(p_request_id uuid) TO service_role;


--
-- Name: FUNCTION find_similar_rides(p_ride_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.find_similar_rides(p_ride_id uuid) TO anon;
GRANT ALL ON FUNCTION public.find_similar_rides(p_ride_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.find_similar_rides(p_ride_id uuid) TO service_role;


--
-- Name: FUNCTION find_srid(character varying, character varying, character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.find_srid(character varying, character varying, character varying) TO postgres;
GRANT ALL ON FUNCTION public.find_srid(character varying, character varying, character varying) TO anon;
GRANT ALL ON FUNCTION public.find_srid(character varying, character varying, character varying) TO authenticated;
GRANT ALL ON FUNCTION public.find_srid(character varying, character varying, character varying) TO service_role;


--
-- Name: FUNCTION generate_driving_report(p_session_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.generate_driving_report(p_session_id uuid) TO anon;
GRANT ALL ON FUNCTION public.generate_driving_report(p_session_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.generate_driving_report(p_session_id uuid) TO service_role;


--
-- Name: FUNCTION generate_public_tracking_link(p_mission_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.generate_public_tracking_link(p_mission_id uuid) TO anon;
GRANT ALL ON FUNCTION public.generate_public_tracking_link(p_mission_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.generate_public_tracking_link(p_mission_id uuid) TO service_role;


--
-- Name: FUNCTION generate_share_code(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.generate_share_code() TO anon;
GRANT ALL ON FUNCTION public.generate_share_code() TO authenticated;
GRANT ALL ON FUNCTION public.generate_share_code() TO service_role;


--
-- Name: FUNCTION geog_brin_inclusion_add_value(internal, internal, internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geog_brin_inclusion_add_value(internal, internal, internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geog_brin_inclusion_add_value(internal, internal, internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geog_brin_inclusion_add_value(internal, internal, internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geog_brin_inclusion_add_value(internal, internal, internal, internal) TO service_role;


--
-- Name: FUNCTION geography_cmp(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_cmp(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geography_cmp(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public.geography_cmp(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geography_cmp(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION geography_distance_knn(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_distance_knn(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geography_distance_knn(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public.geography_distance_knn(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geography_distance_knn(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION geography_eq(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_eq(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geography_eq(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public.geography_eq(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geography_eq(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION geography_ge(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_ge(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geography_ge(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public.geography_ge(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geography_ge(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION geography_gist_compress(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_gist_compress(internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_gist_compress(internal) TO anon;
GRANT ALL ON FUNCTION public.geography_gist_compress(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_gist_compress(internal) TO service_role;


--
-- Name: FUNCTION geography_gist_consistent(internal, public.geography, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_gist_consistent(internal, public.geography, integer) TO postgres;
GRANT ALL ON FUNCTION public.geography_gist_consistent(internal, public.geography, integer) TO anon;
GRANT ALL ON FUNCTION public.geography_gist_consistent(internal, public.geography, integer) TO authenticated;
GRANT ALL ON FUNCTION public.geography_gist_consistent(internal, public.geography, integer) TO service_role;


--
-- Name: FUNCTION geography_gist_decompress(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_gist_decompress(internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_gist_decompress(internal) TO anon;
GRANT ALL ON FUNCTION public.geography_gist_decompress(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_gist_decompress(internal) TO service_role;


--
-- Name: FUNCTION geography_gist_distance(internal, public.geography, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_gist_distance(internal, public.geography, integer) TO postgres;
GRANT ALL ON FUNCTION public.geography_gist_distance(internal, public.geography, integer) TO anon;
GRANT ALL ON FUNCTION public.geography_gist_distance(internal, public.geography, integer) TO authenticated;
GRANT ALL ON FUNCTION public.geography_gist_distance(internal, public.geography, integer) TO service_role;


--
-- Name: FUNCTION geography_gist_penalty(internal, internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_gist_penalty(internal, internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_gist_penalty(internal, internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geography_gist_penalty(internal, internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_gist_penalty(internal, internal, internal) TO service_role;


--
-- Name: FUNCTION geography_gist_picksplit(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_gist_picksplit(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_gist_picksplit(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geography_gist_picksplit(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_gist_picksplit(internal, internal) TO service_role;


--
-- Name: FUNCTION geography_gist_same(public.box2d, public.box2d, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_gist_same(public.box2d, public.box2d, internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_gist_same(public.box2d, public.box2d, internal) TO anon;
GRANT ALL ON FUNCTION public.geography_gist_same(public.box2d, public.box2d, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_gist_same(public.box2d, public.box2d, internal) TO service_role;


--
-- Name: FUNCTION geography_gist_union(bytea, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_gist_union(bytea, internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_gist_union(bytea, internal) TO anon;
GRANT ALL ON FUNCTION public.geography_gist_union(bytea, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_gist_union(bytea, internal) TO service_role;


--
-- Name: FUNCTION geography_gt(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_gt(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geography_gt(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public.geography_gt(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geography_gt(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION geography_le(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_le(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geography_le(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public.geography_le(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geography_le(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION geography_lt(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_lt(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geography_lt(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public.geography_lt(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geography_lt(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION geography_overlaps(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_overlaps(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geography_overlaps(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public.geography_overlaps(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geography_overlaps(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION geography_spgist_choose_nd(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_spgist_choose_nd(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_spgist_choose_nd(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geography_spgist_choose_nd(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_spgist_choose_nd(internal, internal) TO service_role;


--
-- Name: FUNCTION geography_spgist_compress_nd(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_spgist_compress_nd(internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_spgist_compress_nd(internal) TO anon;
GRANT ALL ON FUNCTION public.geography_spgist_compress_nd(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_spgist_compress_nd(internal) TO service_role;


--
-- Name: FUNCTION geography_spgist_config_nd(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_spgist_config_nd(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_spgist_config_nd(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geography_spgist_config_nd(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_spgist_config_nd(internal, internal) TO service_role;


--
-- Name: FUNCTION geography_spgist_inner_consistent_nd(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_spgist_inner_consistent_nd(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_spgist_inner_consistent_nd(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geography_spgist_inner_consistent_nd(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_spgist_inner_consistent_nd(internal, internal) TO service_role;


--
-- Name: FUNCTION geography_spgist_leaf_consistent_nd(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_spgist_leaf_consistent_nd(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_spgist_leaf_consistent_nd(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geography_spgist_leaf_consistent_nd(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_spgist_leaf_consistent_nd(internal, internal) TO service_role;


--
-- Name: FUNCTION geography_spgist_picksplit_nd(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geography_spgist_picksplit_nd(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geography_spgist_picksplit_nd(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geography_spgist_picksplit_nd(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geography_spgist_picksplit_nd(internal, internal) TO service_role;


--
-- Name: FUNCTION geom2d_brin_inclusion_add_value(internal, internal, internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geom2d_brin_inclusion_add_value(internal, internal, internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geom2d_brin_inclusion_add_value(internal, internal, internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geom2d_brin_inclusion_add_value(internal, internal, internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geom2d_brin_inclusion_add_value(internal, internal, internal, internal) TO service_role;


--
-- Name: FUNCTION geom3d_brin_inclusion_add_value(internal, internal, internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geom3d_brin_inclusion_add_value(internal, internal, internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geom3d_brin_inclusion_add_value(internal, internal, internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geom3d_brin_inclusion_add_value(internal, internal, internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geom3d_brin_inclusion_add_value(internal, internal, internal, internal) TO service_role;


--
-- Name: FUNCTION geom4d_brin_inclusion_add_value(internal, internal, internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geom4d_brin_inclusion_add_value(internal, internal, internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geom4d_brin_inclusion_add_value(internal, internal, internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geom4d_brin_inclusion_add_value(internal, internal, internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geom4d_brin_inclusion_add_value(internal, internal, internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_above(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_above(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_above(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_above(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_above(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_below(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_below(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_below(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_below(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_below(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_cmp(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_cmp(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_cmp(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_cmp(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_cmp(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_contained_3d(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_contained_3d(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_contained_3d(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_contained_3d(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_contained_3d(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_contains(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_contains(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_contains(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_contains(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_contains(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_contains_3d(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_contains_3d(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_contains_3d(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_contains_3d(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_contains_3d(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_contains_nd(public.geometry, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_contains_nd(public.geometry, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_contains_nd(public.geometry, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_contains_nd(public.geometry, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_contains_nd(public.geometry, public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_distance_box(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_distance_box(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_distance_box(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_distance_box(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_distance_box(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_distance_centroid(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_distance_centroid(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_distance_centroid(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_distance_centroid(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_distance_centroid(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_distance_centroid_nd(public.geometry, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_distance_centroid_nd(public.geometry, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_distance_centroid_nd(public.geometry, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_distance_centroid_nd(public.geometry, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_distance_centroid_nd(public.geometry, public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_distance_cpa(public.geometry, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_distance_cpa(public.geometry, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_distance_cpa(public.geometry, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_distance_cpa(public.geometry, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_distance_cpa(public.geometry, public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_eq(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_eq(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_eq(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_eq(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_eq(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_ge(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_ge(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_ge(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_ge(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_ge(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_gist_compress_2d(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_compress_2d(internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_compress_2d(internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_compress_2d(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_compress_2d(internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_compress_nd(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_compress_nd(internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_compress_nd(internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_compress_nd(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_compress_nd(internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_consistent_2d(internal, public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_consistent_2d(internal, public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_consistent_2d(internal, public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_consistent_2d(internal, public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_consistent_2d(internal, public.geometry, integer) TO service_role;


--
-- Name: FUNCTION geometry_gist_consistent_nd(internal, public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_consistent_nd(internal, public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_consistent_nd(internal, public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_consistent_nd(internal, public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_consistent_nd(internal, public.geometry, integer) TO service_role;


--
-- Name: FUNCTION geometry_gist_decompress_2d(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_decompress_2d(internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_decompress_2d(internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_decompress_2d(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_decompress_2d(internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_decompress_nd(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_decompress_nd(internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_decompress_nd(internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_decompress_nd(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_decompress_nd(internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_distance_2d(internal, public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_distance_2d(internal, public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_distance_2d(internal, public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_distance_2d(internal, public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_distance_2d(internal, public.geometry, integer) TO service_role;


--
-- Name: FUNCTION geometry_gist_distance_nd(internal, public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_distance_nd(internal, public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_distance_nd(internal, public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_distance_nd(internal, public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_distance_nd(internal, public.geometry, integer) TO service_role;


--
-- Name: FUNCTION geometry_gist_penalty_2d(internal, internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_penalty_2d(internal, internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_penalty_2d(internal, internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_penalty_2d(internal, internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_penalty_2d(internal, internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_penalty_nd(internal, internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_penalty_nd(internal, internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_penalty_nd(internal, internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_penalty_nd(internal, internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_penalty_nd(internal, internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_picksplit_2d(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_picksplit_2d(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_picksplit_2d(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_picksplit_2d(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_picksplit_2d(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_picksplit_nd(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_picksplit_nd(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_picksplit_nd(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_picksplit_nd(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_picksplit_nd(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_same_2d(geom1 public.geometry, geom2 public.geometry, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_same_2d(geom1 public.geometry, geom2 public.geometry, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_same_2d(geom1 public.geometry, geom2 public.geometry, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_same_2d(geom1 public.geometry, geom2 public.geometry, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_same_2d(geom1 public.geometry, geom2 public.geometry, internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_same_nd(public.geometry, public.geometry, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_same_nd(public.geometry, public.geometry, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_same_nd(public.geometry, public.geometry, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_same_nd(public.geometry, public.geometry, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_same_nd(public.geometry, public.geometry, internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_sortsupport_2d(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_sortsupport_2d(internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_sortsupport_2d(internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_sortsupport_2d(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_sortsupport_2d(internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_union_2d(bytea, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_union_2d(bytea, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_union_2d(bytea, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_union_2d(bytea, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_union_2d(bytea, internal) TO service_role;


--
-- Name: FUNCTION geometry_gist_union_nd(bytea, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gist_union_nd(bytea, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gist_union_nd(bytea, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_gist_union_nd(bytea, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gist_union_nd(bytea, internal) TO service_role;


--
-- Name: FUNCTION geometry_gt(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_gt(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_gt(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_gt(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_gt(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_hash(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_hash(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_hash(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_hash(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_hash(public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_le(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_le(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_le(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_le(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_le(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_left(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_left(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_left(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_left(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_left(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_lt(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_lt(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_lt(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_lt(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_lt(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_overabove(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_overabove(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_overabove(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_overabove(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_overabove(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_overbelow(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_overbelow(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_overbelow(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_overbelow(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_overbelow(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_overlaps(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_overlaps(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_overlaps(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_overlaps(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_overlaps(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_overlaps_3d(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_overlaps_3d(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_overlaps_3d(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_overlaps_3d(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_overlaps_3d(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_overlaps_nd(public.geometry, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_overlaps_nd(public.geometry, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_overlaps_nd(public.geometry, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_overlaps_nd(public.geometry, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_overlaps_nd(public.geometry, public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_overleft(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_overleft(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_overleft(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_overleft(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_overleft(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_overright(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_overright(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_overright(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_overright(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_overright(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_right(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_right(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_right(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_right(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_right(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_same(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_same(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_same(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_same(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_same(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_same_3d(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_same_3d(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_same_3d(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_same_3d(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_same_3d(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_same_nd(public.geometry, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_same_nd(public.geometry, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_same_nd(public.geometry, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_same_nd(public.geometry, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_same_nd(public.geometry, public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_sortsupport(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_sortsupport(internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_sortsupport(internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_sortsupport(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_sortsupport(internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_choose_2d(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_choose_2d(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_choose_2d(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_choose_2d(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_choose_2d(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_choose_3d(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_choose_3d(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_choose_3d(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_choose_3d(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_choose_3d(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_choose_nd(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_choose_nd(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_choose_nd(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_choose_nd(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_choose_nd(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_compress_2d(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_compress_2d(internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_compress_2d(internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_compress_2d(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_compress_2d(internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_compress_3d(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_compress_3d(internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_compress_3d(internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_compress_3d(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_compress_3d(internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_compress_nd(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_compress_nd(internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_compress_nd(internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_compress_nd(internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_compress_nd(internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_config_2d(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_config_2d(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_config_2d(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_config_2d(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_config_2d(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_config_3d(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_config_3d(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_config_3d(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_config_3d(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_config_3d(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_config_nd(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_config_nd(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_config_nd(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_config_nd(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_config_nd(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_inner_consistent_2d(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_2d(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_2d(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_2d(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_2d(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_inner_consistent_3d(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_3d(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_3d(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_3d(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_3d(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_inner_consistent_nd(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_nd(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_nd(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_nd(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_inner_consistent_nd(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_leaf_consistent_2d(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_2d(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_2d(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_2d(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_2d(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_leaf_consistent_3d(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_3d(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_3d(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_3d(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_3d(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_leaf_consistent_nd(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_nd(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_nd(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_nd(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_leaf_consistent_nd(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_picksplit_2d(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_2d(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_2d(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_2d(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_2d(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_picksplit_3d(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_3d(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_3d(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_3d(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_3d(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_spgist_picksplit_nd(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_nd(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_nd(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_nd(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_spgist_picksplit_nd(internal, internal) TO service_role;


--
-- Name: FUNCTION geometry_within(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_within(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_within(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_within(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_within(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION geometry_within_nd(public.geometry, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometry_within_nd(public.geometry, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometry_within_nd(public.geometry, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometry_within_nd(public.geometry, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometry_within_nd(public.geometry, public.geometry) TO service_role;


--
-- Name: FUNCTION geometrytype(public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometrytype(public.geography) TO postgres;
GRANT ALL ON FUNCTION public.geometrytype(public.geography) TO anon;
GRANT ALL ON FUNCTION public.geometrytype(public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.geometrytype(public.geography) TO service_role;


--
-- Name: FUNCTION geometrytype(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geometrytype(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.geometrytype(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.geometrytype(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.geometrytype(public.geometry) TO service_role;


--
-- Name: FUNCTION geomfromewkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geomfromewkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.geomfromewkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.geomfromewkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.geomfromewkb(bytea) TO service_role;


--
-- Name: FUNCTION geomfromewkt(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.geomfromewkt(text) TO postgres;
GRANT ALL ON FUNCTION public.geomfromewkt(text) TO anon;
GRANT ALL ON FUNCTION public.geomfromewkt(text) TO authenticated;
GRANT ALL ON FUNCTION public.geomfromewkt(text) TO service_role;


--
-- Name: FUNCTION get_ai_requests_count(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_ai_requests_count(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_ai_requests_count(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_ai_requests_count(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION get_all_users(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_all_users() TO anon;
GRANT ALL ON FUNCTION public.get_all_users() TO authenticated;
GRANT ALL ON FUNCTION public.get_all_users() TO service_role;


--
-- Name: FUNCTION get_client_stats_by_siret(p_siret text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_client_stats_by_siret(p_siret text) TO anon;
GRANT ALL ON FUNCTION public.get_client_stats_by_siret(p_siret text) TO authenticated;
GRANT ALL ON FUNCTION public.get_client_stats_by_siret(p_siret text) TO service_role;


--
-- Name: FUNCTION get_current_month_key(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_current_month_key() TO anon;
GRANT ALL ON FUNCTION public.get_current_month_key() TO authenticated;
GRANT ALL ON FUNCTION public.get_current_month_key() TO service_role;


--
-- Name: FUNCTION get_current_month_navigation_stats(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_current_month_navigation_stats() TO anon;
GRANT ALL ON FUNCTION public.get_current_month_navigation_stats() TO authenticated;
GRANT ALL ON FUNCTION public.get_current_month_navigation_stats() TO service_role;


--
-- Name: FUNCTION get_dashboard_stats(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_dashboard_stats(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_dashboard_stats(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_dashboard_stats(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION get_documents_by_siret(p_siret text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_documents_by_siret(p_siret text) TO anon;
GRANT ALL ON FUNCTION public.get_documents_by_siret(p_siret text) TO authenticated;
GRANT ALL ON FUNCTION public.get_documents_by_siret(p_siret text) TO service_role;


--
-- Name: FUNCTION get_driver_trips_count(user_uuid uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_driver_trips_count(user_uuid uuid) TO anon;
GRANT ALL ON FUNCTION public.get_driver_trips_count(user_uuid uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_driver_trips_count(user_uuid uuid) TO service_role;


--
-- Name: FUNCTION get_expiring_quotes(days_before integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_expiring_quotes(days_before integer) TO anon;
GRANT ALL ON FUNCTION public.get_expiring_quotes(days_before integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_expiring_quotes(days_before integer) TO service_role;


--
-- Name: FUNCTION get_full_inspection_report(p_token text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_full_inspection_report(p_token text) TO anon;
GRANT ALL ON FUNCTION public.get_full_inspection_report(p_token text) TO authenticated;
GRANT ALL ON FUNCTION public.get_full_inspection_report(p_token text) TO service_role;


--
-- Name: FUNCTION get_inspection_email_history(p_inspection_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_inspection_email_history(p_inspection_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_inspection_email_history(p_inspection_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_inspection_email_history(p_inspection_id uuid) TO service_role;


--
-- Name: FUNCTION get_inspection_report_by_token(p_token text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_inspection_report_by_token(p_token text) TO anon;
GRANT ALL ON FUNCTION public.get_inspection_report_by_token(p_token text) TO authenticated;
GRANT ALL ON FUNCTION public.get_inspection_report_by_token(p_token text) TO service_role;


--
-- Name: FUNCTION get_latest_position(p_mission_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_latest_position(p_mission_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_latest_position(p_mission_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_latest_position(p_mission_id uuid) TO service_role;


--
-- Name: FUNCTION get_legal_mentions(p_vat_regime text, p_vat_liable boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_legal_mentions(p_vat_regime text, p_vat_liable boolean) TO anon;
GRANT ALL ON FUNCTION public.get_legal_mentions(p_vat_regime text, p_vat_liable boolean) TO authenticated;
GRANT ALL ON FUNCTION public.get_legal_mentions(p_vat_regime text, p_vat_liable boolean) TO service_role;


--
-- Name: FUNCTION get_mission_inspection_ids(p_mission_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_mission_inspection_ids(p_mission_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_mission_inspection_ids(p_mission_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_mission_inspection_ids(p_mission_id uuid) TO service_role;


--
-- Name: FUNCTION get_mission_last_position(p_mission_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_mission_last_position(p_mission_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_mission_last_position(p_mission_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_mission_last_position(p_mission_id uuid) TO service_role;


--
-- Name: FUNCTION get_mission_positions(p_mission_id uuid, p_limit integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_mission_positions(p_mission_id uuid, p_limit integer) TO anon;
GRANT ALL ON FUNCTION public.get_mission_positions(p_mission_id uuid, p_limit integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_mission_positions(p_mission_id uuid, p_limit integer) TO service_role;


--
-- Name: FUNCTION get_monthly_revenue(p_user_id uuid, p_month_key text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_monthly_revenue(p_user_id uuid, p_month_key text) TO anon;
GRANT ALL ON FUNCTION public.get_monthly_revenue(p_user_id uuid, p_month_key text) TO authenticated;
GRANT ALL ON FUNCTION public.get_monthly_revenue(p_user_id uuid, p_month_key text) TO service_role;


--
-- Name: FUNCTION get_navigation_quota_projection(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_navigation_quota_projection() TO anon;
GRANT ALL ON FUNCTION public.get_navigation_quota_projection() TO authenticated;
GRANT ALL ON FUNCTION public.get_navigation_quota_projection() TO service_role;


--
-- Name: FUNCTION get_notification_summary(days_back integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_notification_summary(days_back integer) TO anon;
GRANT ALL ON FUNCTION public.get_notification_summary(days_back integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_notification_summary(days_back integer) TO service_role;


--
-- Name: FUNCTION get_optimized_tracking_positions(p_session_id uuid, p_limit integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_optimized_tracking_positions(p_session_id uuid, p_limit integer) TO anon;
GRANT ALL ON FUNCTION public.get_optimized_tracking_positions(p_session_id uuid, p_limit integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_optimized_tracking_positions(p_session_id uuid, p_limit integer) TO service_role;


--
-- Name: FUNCTION get_planning_visibility(p_planning_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_planning_visibility(p_planning_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_planning_visibility(p_planning_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_planning_visibility(p_planning_id uuid) TO service_role;


--
-- Name: FUNCTION get_proj4_from_srid(integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_proj4_from_srid(integer) TO postgres;
GRANT ALL ON FUNCTION public.get_proj4_from_srid(integer) TO anon;
GRANT ALL ON FUNCTION public.get_proj4_from_srid(integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_proj4_from_srid(integer) TO service_role;


--
-- Name: FUNCTION get_public_report_data(p_share_token text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_public_report_data(p_share_token text) TO anon;
GRANT ALL ON FUNCTION public.get_public_report_data(p_share_token text) TO authenticated;
GRANT ALL ON FUNCTION public.get_public_report_data(p_share_token text) TO service_role;


--
-- Name: FUNCTION get_revenue_breakdown(p_user_id uuid, p_month_key text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_revenue_breakdown(p_user_id uuid, p_month_key text) TO anon;
GRANT ALL ON FUNCTION public.get_revenue_breakdown(p_user_id uuid, p_month_key text) TO authenticated;
GRANT ALL ON FUNCTION public.get_revenue_breakdown(p_user_id uuid, p_month_key text) TO service_role;


--
-- Name: FUNCTION get_unread_messages_count(user_uuid uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_unread_messages_count(user_uuid uuid) TO anon;
GRANT ALL ON FUNCTION public.get_unread_messages_count(user_uuid uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_unread_messages_count(user_uuid uuid) TO service_role;


--
-- Name: FUNCTION get_user_average_rating(user_uuid uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_average_rating(user_uuid uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_average_rating(user_uuid uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_average_rating(user_uuid uuid) TO service_role;


--
-- Name: FUNCTION get_user_credits(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_credits(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_credits(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_credits(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION get_user_ride_rating(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_ride_rating(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_ride_rating(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_ride_rating(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION get_user_storage_usage(user_uuid uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_storage_usage(user_uuid uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_storage_usage(user_uuid uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_storage_usage(user_uuid uuid) TO service_role;


--
-- Name: FUNCTION get_wallet_balance(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_wallet_balance(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_wallet_balance(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_wallet_balance(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION gettransactionid(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.gettransactionid() TO postgres;
GRANT ALL ON FUNCTION public.gettransactionid() TO anon;
GRANT ALL ON FUNCTION public.gettransactionid() TO authenticated;
GRANT ALL ON FUNCTION public.gettransactionid() TO service_role;


--
-- Name: FUNCTION gserialized_gist_joinsel_2d(internal, oid, internal, smallint); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.gserialized_gist_joinsel_2d(internal, oid, internal, smallint) TO postgres;
GRANT ALL ON FUNCTION public.gserialized_gist_joinsel_2d(internal, oid, internal, smallint) TO anon;
GRANT ALL ON FUNCTION public.gserialized_gist_joinsel_2d(internal, oid, internal, smallint) TO authenticated;
GRANT ALL ON FUNCTION public.gserialized_gist_joinsel_2d(internal, oid, internal, smallint) TO service_role;


--
-- Name: FUNCTION gserialized_gist_joinsel_nd(internal, oid, internal, smallint); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.gserialized_gist_joinsel_nd(internal, oid, internal, smallint) TO postgres;
GRANT ALL ON FUNCTION public.gserialized_gist_joinsel_nd(internal, oid, internal, smallint) TO anon;
GRANT ALL ON FUNCTION public.gserialized_gist_joinsel_nd(internal, oid, internal, smallint) TO authenticated;
GRANT ALL ON FUNCTION public.gserialized_gist_joinsel_nd(internal, oid, internal, smallint) TO service_role;


--
-- Name: FUNCTION gserialized_gist_sel_2d(internal, oid, internal, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.gserialized_gist_sel_2d(internal, oid, internal, integer) TO postgres;
GRANT ALL ON FUNCTION public.gserialized_gist_sel_2d(internal, oid, internal, integer) TO anon;
GRANT ALL ON FUNCTION public.gserialized_gist_sel_2d(internal, oid, internal, integer) TO authenticated;
GRANT ALL ON FUNCTION public.gserialized_gist_sel_2d(internal, oid, internal, integer) TO service_role;


--
-- Name: FUNCTION gserialized_gist_sel_nd(internal, oid, internal, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.gserialized_gist_sel_nd(internal, oid, internal, integer) TO postgres;
GRANT ALL ON FUNCTION public.gserialized_gist_sel_nd(internal, oid, internal, integer) TO anon;
GRANT ALL ON FUNCTION public.gserialized_gist_sel_nd(internal, oid, internal, integer) TO authenticated;
GRANT ALL ON FUNCTION public.gserialized_gist_sel_nd(internal, oid, internal, integer) TO service_role;


--
-- Name: FUNCTION handle_new_user(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.handle_new_user() TO anon;
GRANT ALL ON FUNCTION public.handle_new_user() TO authenticated;
GRANT ALL ON FUNCTION public.handle_new_user() TO service_role;


--
-- Name: FUNCTION handle_ride_match_status_change(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.handle_ride_match_status_change() TO anon;
GRANT ALL ON FUNCTION public.handle_ride_match_status_change() TO authenticated;
GRANT ALL ON FUNCTION public.handle_ride_match_status_change() TO service_role;


--
-- Name: FUNCTION has_active_subscription(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.has_active_subscription(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.has_active_subscription(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.has_active_subscription(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION has_sufficient_credits(p_user_id uuid, p_required_amount integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.has_sufficient_credits(p_user_id uuid, p_required_amount integer) TO anon;
GRANT ALL ON FUNCTION public.has_sufficient_credits(p_user_id uuid, p_required_amount integer) TO authenticated;
GRANT ALL ON FUNCTION public.has_sufficient_credits(p_user_id uuid, p_required_amount integer) TO service_role;


--
-- Name: FUNCTION http(request public.http_request); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http(request public.http_request) TO postgres;
GRANT ALL ON FUNCTION public.http(request public.http_request) TO anon;
GRANT ALL ON FUNCTION public.http(request public.http_request) TO authenticated;
GRANT ALL ON FUNCTION public.http(request public.http_request) TO service_role;


--
-- Name: FUNCTION http_delete(uri character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_delete(uri character varying) TO postgres;
GRANT ALL ON FUNCTION public.http_delete(uri character varying) TO anon;
GRANT ALL ON FUNCTION public.http_delete(uri character varying) TO authenticated;
GRANT ALL ON FUNCTION public.http_delete(uri character varying) TO service_role;


--
-- Name: FUNCTION http_delete(uri character varying, content character varying, content_type character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_delete(uri character varying, content character varying, content_type character varying) TO postgres;
GRANT ALL ON FUNCTION public.http_delete(uri character varying, content character varying, content_type character varying) TO anon;
GRANT ALL ON FUNCTION public.http_delete(uri character varying, content character varying, content_type character varying) TO authenticated;
GRANT ALL ON FUNCTION public.http_delete(uri character varying, content character varying, content_type character varying) TO service_role;


--
-- Name: FUNCTION http_get(uri character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_get(uri character varying) TO postgres;
GRANT ALL ON FUNCTION public.http_get(uri character varying) TO anon;
GRANT ALL ON FUNCTION public.http_get(uri character varying) TO authenticated;
GRANT ALL ON FUNCTION public.http_get(uri character varying) TO service_role;


--
-- Name: FUNCTION http_get(uri character varying, data jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_get(uri character varying, data jsonb) TO postgres;
GRANT ALL ON FUNCTION public.http_get(uri character varying, data jsonb) TO anon;
GRANT ALL ON FUNCTION public.http_get(uri character varying, data jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.http_get(uri character varying, data jsonb) TO service_role;


--
-- Name: FUNCTION http_head(uri character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_head(uri character varying) TO postgres;
GRANT ALL ON FUNCTION public.http_head(uri character varying) TO anon;
GRANT ALL ON FUNCTION public.http_head(uri character varying) TO authenticated;
GRANT ALL ON FUNCTION public.http_head(uri character varying) TO service_role;


--
-- Name: FUNCTION http_header(field character varying, value character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_header(field character varying, value character varying) TO postgres;
GRANT ALL ON FUNCTION public.http_header(field character varying, value character varying) TO anon;
GRANT ALL ON FUNCTION public.http_header(field character varying, value character varying) TO authenticated;
GRANT ALL ON FUNCTION public.http_header(field character varying, value character varying) TO service_role;


--
-- Name: FUNCTION http_list_curlopt(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_list_curlopt() TO postgres;
GRANT ALL ON FUNCTION public.http_list_curlopt() TO anon;
GRANT ALL ON FUNCTION public.http_list_curlopt() TO authenticated;
GRANT ALL ON FUNCTION public.http_list_curlopt() TO service_role;


--
-- Name: FUNCTION http_patch(uri character varying, content character varying, content_type character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_patch(uri character varying, content character varying, content_type character varying) TO postgres;
GRANT ALL ON FUNCTION public.http_patch(uri character varying, content character varying, content_type character varying) TO anon;
GRANT ALL ON FUNCTION public.http_patch(uri character varying, content character varying, content_type character varying) TO authenticated;
GRANT ALL ON FUNCTION public.http_patch(uri character varying, content character varying, content_type character varying) TO service_role;


--
-- Name: FUNCTION http_post(uri character varying, data jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_post(uri character varying, data jsonb) TO postgres;
GRANT ALL ON FUNCTION public.http_post(uri character varying, data jsonb) TO anon;
GRANT ALL ON FUNCTION public.http_post(uri character varying, data jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.http_post(uri character varying, data jsonb) TO service_role;


--
-- Name: FUNCTION http_post(uri character varying, content character varying, content_type character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_post(uri character varying, content character varying, content_type character varying) TO postgres;
GRANT ALL ON FUNCTION public.http_post(uri character varying, content character varying, content_type character varying) TO anon;
GRANT ALL ON FUNCTION public.http_post(uri character varying, content character varying, content_type character varying) TO authenticated;
GRANT ALL ON FUNCTION public.http_post(uri character varying, content character varying, content_type character varying) TO service_role;


--
-- Name: FUNCTION http_put(uri character varying, content character varying, content_type character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_put(uri character varying, content character varying, content_type character varying) TO postgres;
GRANT ALL ON FUNCTION public.http_put(uri character varying, content character varying, content_type character varying) TO anon;
GRANT ALL ON FUNCTION public.http_put(uri character varying, content character varying, content_type character varying) TO authenticated;
GRANT ALL ON FUNCTION public.http_put(uri character varying, content character varying, content_type character varying) TO service_role;


--
-- Name: FUNCTION http_reset_curlopt(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_reset_curlopt() TO postgres;
GRANT ALL ON FUNCTION public.http_reset_curlopt() TO anon;
GRANT ALL ON FUNCTION public.http_reset_curlopt() TO authenticated;
GRANT ALL ON FUNCTION public.http_reset_curlopt() TO service_role;


--
-- Name: FUNCTION http_set_curlopt(curlopt character varying, value character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.http_set_curlopt(curlopt character varying, value character varying) TO postgres;
GRANT ALL ON FUNCTION public.http_set_curlopt(curlopt character varying, value character varying) TO anon;
GRANT ALL ON FUNCTION public.http_set_curlopt(curlopt character varying, value character varying) TO authenticated;
GRANT ALL ON FUNCTION public.http_set_curlopt(curlopt character varying, value character varying) TO service_role;


--
-- Name: FUNCTION increment_ai_request(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.increment_ai_request(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.increment_ai_request(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.increment_ai_request(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION increment_report_view_count(p_share_token text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.increment_report_view_count(p_share_token text) TO anon;
GRANT ALL ON FUNCTION public.increment_report_view_count(p_share_token text) TO authenticated;
GRANT ALL ON FUNCTION public.increment_report_view_count(p_share_token text) TO service_role;


--
-- Name: FUNCTION increment_tracking_access(p_token text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.increment_tracking_access(p_token text) TO anon;
GRANT ALL ON FUNCTION public.increment_tracking_access(p_token text) TO authenticated;
GRANT ALL ON FUNCTION public.increment_tracking_access(p_token text) TO service_role;


--
-- Name: FUNCTION inspection_photos_delete_trigger(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.inspection_photos_delete_trigger() TO anon;
GRANT ALL ON FUNCTION public.inspection_photos_delete_trigger() TO authenticated;
GRANT ALL ON FUNCTION public.inspection_photos_delete_trigger() TO service_role;


--
-- Name: FUNCTION inspection_photos_insert_trigger(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.inspection_photos_insert_trigger() TO anon;
GRANT ALL ON FUNCTION public.inspection_photos_insert_trigger() TO authenticated;
GRANT ALL ON FUNCTION public.inspection_photos_insert_trigger() TO service_role;


--
-- Name: FUNCTION inspection_photos_update_trigger(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.inspection_photos_update_trigger() TO anon;
GRANT ALL ON FUNCTION public.inspection_photos_update_trigger() TO authenticated;
GRANT ALL ON FUNCTION public.inspection_photos_update_trigger() TO service_role;


--
-- Name: FUNCTION is_contained_2d(public.box2df, public.box2df); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.is_contained_2d(public.box2df, public.box2df) TO postgres;
GRANT ALL ON FUNCTION public.is_contained_2d(public.box2df, public.box2df) TO anon;
GRANT ALL ON FUNCTION public.is_contained_2d(public.box2df, public.box2df) TO authenticated;
GRANT ALL ON FUNCTION public.is_contained_2d(public.box2df, public.box2df) TO service_role;


--
-- Name: FUNCTION is_contained_2d(public.box2df, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.is_contained_2d(public.box2df, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.is_contained_2d(public.box2df, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.is_contained_2d(public.box2df, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.is_contained_2d(public.box2df, public.geometry) TO service_role;


--
-- Name: FUNCTION is_contained_2d(public.geometry, public.box2df); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.is_contained_2d(public.geometry, public.box2df) TO postgres;
GRANT ALL ON FUNCTION public.is_contained_2d(public.geometry, public.box2df) TO anon;
GRANT ALL ON FUNCTION public.is_contained_2d(public.geometry, public.box2df) TO authenticated;
GRANT ALL ON FUNCTION public.is_contained_2d(public.geometry, public.box2df) TO service_role;


--
-- Name: FUNCTION is_inspection_complete(p_inspection_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.is_inspection_complete(p_inspection_id uuid) TO anon;
GRANT ALL ON FUNCTION public.is_inspection_complete(p_inspection_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.is_inspection_complete(p_inspection_id uuid) TO service_role;


--
-- Name: FUNCTION join_mission_v2(p_share_code text, p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.join_mission_v2(p_share_code text, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.join_mission_v2(p_share_code text, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.join_mission_v2(p_share_code text, p_user_id uuid) TO service_role;


--
-- Name: FUNCTION join_mission_with_code(p_share_code text, p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.join_mission_with_code(p_share_code text, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.join_mission_with_code(p_share_code text, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.join_mission_with_code(p_share_code text, p_user_id uuid) TO service_role;


--
-- Name: FUNCTION lock_inspection(inspection_uuid uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.lock_inspection(inspection_uuid uuid) TO anon;
GRANT ALL ON FUNCTION public.lock_inspection(inspection_uuid uuid) TO authenticated;
GRANT ALL ON FUNCTION public.lock_inspection(inspection_uuid uuid) TO service_role;


--
-- Name: FUNCTION lockrow(text, text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.lockrow(text, text, text) TO postgres;
GRANT ALL ON FUNCTION public.lockrow(text, text, text) TO anon;
GRANT ALL ON FUNCTION public.lockrow(text, text, text) TO authenticated;
GRANT ALL ON FUNCTION public.lockrow(text, text, text) TO service_role;


--
-- Name: FUNCTION lockrow(text, text, text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.lockrow(text, text, text, text) TO postgres;
GRANT ALL ON FUNCTION public.lockrow(text, text, text, text) TO anon;
GRANT ALL ON FUNCTION public.lockrow(text, text, text, text) TO authenticated;
GRANT ALL ON FUNCTION public.lockrow(text, text, text, text) TO service_role;


--
-- Name: FUNCTION lockrow(text, text, text, timestamp without time zone); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.lockrow(text, text, text, timestamp without time zone) TO postgres;
GRANT ALL ON FUNCTION public.lockrow(text, text, text, timestamp without time zone) TO anon;
GRANT ALL ON FUNCTION public.lockrow(text, text, text, timestamp without time zone) TO authenticated;
GRANT ALL ON FUNCTION public.lockrow(text, text, text, timestamp without time zone) TO service_role;


--
-- Name: FUNCTION lockrow(text, text, text, text, timestamp without time zone); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.lockrow(text, text, text, text, timestamp without time zone) TO postgres;
GRANT ALL ON FUNCTION public.lockrow(text, text, text, text, timestamp without time zone) TO anon;
GRANT ALL ON FUNCTION public.lockrow(text, text, text, text, timestamp without time zone) TO authenticated;
GRANT ALL ON FUNCTION public.lockrow(text, text, text, text, timestamp without time zone) TO service_role;


--
-- Name: FUNCTION log_account_creation_attempt(p_email text, p_phone text, p_ip_address text, p_user_agent text, p_success boolean, p_error_message text, p_duplicate_detected boolean, p_existing_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.log_account_creation_attempt(p_email text, p_phone text, p_ip_address text, p_user_agent text, p_success boolean, p_error_message text, p_duplicate_detected boolean, p_existing_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.log_account_creation_attempt(p_email text, p_phone text, p_ip_address text, p_user_agent text, p_success boolean, p_error_message text, p_duplicate_detected boolean, p_existing_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.log_account_creation_attempt(p_email text, p_phone text, p_ip_address text, p_user_agent text, p_success boolean, p_error_message text, p_duplicate_detected boolean, p_existing_user_id uuid) TO service_role;


--
-- Name: FUNCTION log_admin_status_change(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.log_admin_status_change() TO anon;
GRANT ALL ON FUNCTION public.log_admin_status_change() TO authenticated;
GRANT ALL ON FUNCTION public.log_admin_status_change() TO service_role;


--
-- Name: FUNCTION log_mission_revenue(p_mission_id uuid, p_user_id uuid, p_mission_reference text, p_revenue_type text, p_amount numeric, p_description text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.log_mission_revenue(p_mission_id uuid, p_user_id uuid, p_mission_reference text, p_revenue_type text, p_amount numeric, p_description text) TO anon;
GRANT ALL ON FUNCTION public.log_mission_revenue(p_mission_id uuid, p_user_id uuid, p_mission_reference text, p_revenue_type text, p_amount numeric, p_description text) TO authenticated;
GRANT ALL ON FUNCTION public.log_mission_revenue(p_mission_id uuid, p_user_id uuid, p_mission_reference text, p_revenue_type text, p_amount numeric, p_description text) TO service_role;


--
-- Name: FUNCTION longtransactionsenabled(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.longtransactionsenabled() TO postgres;
GRANT ALL ON FUNCTION public.longtransactionsenabled() TO anon;
GRANT ALL ON FUNCTION public.longtransactionsenabled() TO authenticated;
GRANT ALL ON FUNCTION public.longtransactionsenabled() TO service_role;


--
-- Name: FUNCTION mark_conversation_as_read(p_trip_id uuid, p_other_user_id uuid, p_current_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.mark_conversation_as_read(p_trip_id uuid, p_other_user_id uuid, p_current_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.mark_conversation_as_read(p_trip_id uuid, p_other_user_id uuid, p_current_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.mark_conversation_as_read(p_trip_id uuid, p_other_user_id uuid, p_current_user_id uuid) TO service_role;


--
-- Name: FUNCTION mission_has_both_inspections(p_mission_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.mission_has_both_inspections(p_mission_id uuid) TO anon;
GRANT ALL ON FUNCTION public.mission_has_both_inspections(p_mission_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.mission_has_both_inspections(p_mission_id uuid) TO service_role;


--
-- Name: FUNCTION notify_booking_status_changed(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.notify_booking_status_changed() TO anon;
GRANT ALL ON FUNCTION public.notify_booking_status_changed() TO authenticated;
GRANT ALL ON FUNCTION public.notify_booking_status_changed() TO service_role;


--
-- Name: FUNCTION notify_mission_assigned(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.notify_mission_assigned() TO anon;
GRANT ALL ON FUNCTION public.notify_mission_assigned() TO authenticated;
GRANT ALL ON FUNCTION public.notify_mission_assigned() TO service_role;


--
-- Name: FUNCTION notify_mission_status_changed(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.notify_mission_status_changed() TO anon;
GRANT ALL ON FUNCTION public.notify_mission_status_changed() TO authenticated;
GRANT ALL ON FUNCTION public.notify_mission_status_changed() TO service_role;


--
-- Name: FUNCTION notify_new_booking_request(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.notify_new_booking_request() TO anon;
GRANT ALL ON FUNCTION public.notify_new_booking_request() TO authenticated;
GRANT ALL ON FUNCTION public.notify_new_booking_request() TO service_role;


--
-- Name: FUNCTION notify_new_message(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.notify_new_message() TO anon;
GRANT ALL ON FUNCTION public.notify_new_message() TO authenticated;
GRANT ALL ON FUNCTION public.notify_new_message() TO service_role;


--
-- Name: FUNCTION notify_on_match_change(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.notify_on_match_change() TO anon;
GRANT ALL ON FUNCTION public.notify_on_match_change() TO authenticated;
GRANT ALL ON FUNCTION public.notify_on_match_change() TO service_role;


--
-- Name: FUNCTION notify_on_new_message(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.notify_on_new_message() TO anon;
GRANT ALL ON FUNCTION public.notify_on_new_message() TO authenticated;
GRANT ALL ON FUNCTION public.notify_on_new_message() TO service_role;


--
-- Name: FUNCTION notify_on_ride_match_change(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.notify_on_ride_match_change() TO anon;
GRANT ALL ON FUNCTION public.notify_on_ride_match_change() TO authenticated;
GRANT ALL ON FUNCTION public.notify_on_ride_match_change() TO service_role;


--
-- Name: FUNCTION notify_on_ride_message(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.notify_on_ride_message() TO anon;
GRANT ALL ON FUNCTION public.notify_on_ride_message() TO authenticated;
GRANT ALL ON FUNCTION public.notify_on_ride_message() TO service_role;


--
-- Name: FUNCTION overlaps_2d(public.box2df, public.box2df); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.overlaps_2d(public.box2df, public.box2df) TO postgres;
GRANT ALL ON FUNCTION public.overlaps_2d(public.box2df, public.box2df) TO anon;
GRANT ALL ON FUNCTION public.overlaps_2d(public.box2df, public.box2df) TO authenticated;
GRANT ALL ON FUNCTION public.overlaps_2d(public.box2df, public.box2df) TO service_role;


--
-- Name: FUNCTION overlaps_2d(public.box2df, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.overlaps_2d(public.box2df, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.overlaps_2d(public.box2df, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.overlaps_2d(public.box2df, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.overlaps_2d(public.box2df, public.geometry) TO service_role;


--
-- Name: FUNCTION overlaps_2d(public.geometry, public.box2df); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.overlaps_2d(public.geometry, public.box2df) TO postgres;
GRANT ALL ON FUNCTION public.overlaps_2d(public.geometry, public.box2df) TO anon;
GRANT ALL ON FUNCTION public.overlaps_2d(public.geometry, public.box2df) TO authenticated;
GRANT ALL ON FUNCTION public.overlaps_2d(public.geometry, public.box2df) TO service_role;


--
-- Name: FUNCTION overlaps_geog(public.geography, public.gidx); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.overlaps_geog(public.geography, public.gidx) TO postgres;
GRANT ALL ON FUNCTION public.overlaps_geog(public.geography, public.gidx) TO anon;
GRANT ALL ON FUNCTION public.overlaps_geog(public.geography, public.gidx) TO authenticated;
GRANT ALL ON FUNCTION public.overlaps_geog(public.geography, public.gidx) TO service_role;


--
-- Name: FUNCTION overlaps_geog(public.gidx, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.overlaps_geog(public.gidx, public.geography) TO postgres;
GRANT ALL ON FUNCTION public.overlaps_geog(public.gidx, public.geography) TO anon;
GRANT ALL ON FUNCTION public.overlaps_geog(public.gidx, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.overlaps_geog(public.gidx, public.geography) TO service_role;


--
-- Name: FUNCTION overlaps_geog(public.gidx, public.gidx); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.overlaps_geog(public.gidx, public.gidx) TO postgres;
GRANT ALL ON FUNCTION public.overlaps_geog(public.gidx, public.gidx) TO anon;
GRANT ALL ON FUNCTION public.overlaps_geog(public.gidx, public.gidx) TO authenticated;
GRANT ALL ON FUNCTION public.overlaps_geog(public.gidx, public.gidx) TO service_role;


--
-- Name: FUNCTION overlaps_nd(public.geometry, public.gidx); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.overlaps_nd(public.geometry, public.gidx) TO postgres;
GRANT ALL ON FUNCTION public.overlaps_nd(public.geometry, public.gidx) TO anon;
GRANT ALL ON FUNCTION public.overlaps_nd(public.geometry, public.gidx) TO authenticated;
GRANT ALL ON FUNCTION public.overlaps_nd(public.geometry, public.gidx) TO service_role;


--
-- Name: FUNCTION overlaps_nd(public.gidx, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.overlaps_nd(public.gidx, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.overlaps_nd(public.gidx, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.overlaps_nd(public.gidx, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.overlaps_nd(public.gidx, public.geometry) TO service_role;


--
-- Name: FUNCTION overlaps_nd(public.gidx, public.gidx); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.overlaps_nd(public.gidx, public.gidx) TO postgres;
GRANT ALL ON FUNCTION public.overlaps_nd(public.gidx, public.gidx) TO anon;
GRANT ALL ON FUNCTION public.overlaps_nd(public.gidx, public.gidx) TO authenticated;
GRANT ALL ON FUNCTION public.overlaps_nd(public.gidx, public.gidx) TO service_role;


--
-- Name: FUNCTION pgis_asflatgeobuf_finalfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_finalfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_finalfn(internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_finalfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_finalfn(internal) TO service_role;


--
-- Name: FUNCTION pgis_asflatgeobuf_transfn(internal, anyelement); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement) TO anon;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement) TO service_role;


--
-- Name: FUNCTION pgis_asflatgeobuf_transfn(internal, anyelement, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement, boolean) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement, boolean) TO anon;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement, boolean) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement, boolean) TO service_role;


--
-- Name: FUNCTION pgis_asflatgeobuf_transfn(internal, anyelement, boolean, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement, boolean, text) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement, boolean, text) TO anon;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement, boolean, text) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement, boolean, text) TO service_role;


--
-- Name: FUNCTION pgis_asgeobuf_finalfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asgeobuf_finalfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asgeobuf_finalfn(internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_asgeobuf_finalfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asgeobuf_finalfn(internal) TO service_role;


--
-- Name: FUNCTION pgis_asgeobuf_transfn(internal, anyelement); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asgeobuf_transfn(internal, anyelement) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asgeobuf_transfn(internal, anyelement) TO anon;
GRANT ALL ON FUNCTION public.pgis_asgeobuf_transfn(internal, anyelement) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asgeobuf_transfn(internal, anyelement) TO service_role;


--
-- Name: FUNCTION pgis_asgeobuf_transfn(internal, anyelement, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asgeobuf_transfn(internal, anyelement, text) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asgeobuf_transfn(internal, anyelement, text) TO anon;
GRANT ALL ON FUNCTION public.pgis_asgeobuf_transfn(internal, anyelement, text) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asgeobuf_transfn(internal, anyelement, text) TO service_role;


--
-- Name: FUNCTION pgis_asmvt_combinefn(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asmvt_combinefn(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asmvt_combinefn(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_asmvt_combinefn(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asmvt_combinefn(internal, internal) TO service_role;


--
-- Name: FUNCTION pgis_asmvt_deserialfn(bytea, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asmvt_deserialfn(bytea, internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asmvt_deserialfn(bytea, internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_asmvt_deserialfn(bytea, internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asmvt_deserialfn(bytea, internal) TO service_role;


--
-- Name: FUNCTION pgis_asmvt_finalfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asmvt_finalfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asmvt_finalfn(internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_asmvt_finalfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asmvt_finalfn(internal) TO service_role;


--
-- Name: FUNCTION pgis_asmvt_serialfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asmvt_serialfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asmvt_serialfn(internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_asmvt_serialfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asmvt_serialfn(internal) TO service_role;


--
-- Name: FUNCTION pgis_asmvt_transfn(internal, anyelement); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement) TO anon;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement) TO service_role;


--
-- Name: FUNCTION pgis_asmvt_transfn(internal, anyelement, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text) TO anon;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text) TO service_role;


--
-- Name: FUNCTION pgis_asmvt_transfn(internal, anyelement, text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer) TO anon;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer) TO service_role;


--
-- Name: FUNCTION pgis_asmvt_transfn(internal, anyelement, text, integer, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer, text) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer, text) TO anon;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer, text) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer, text) TO service_role;


--
-- Name: FUNCTION pgis_asmvt_transfn(internal, anyelement, text, integer, text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer, text, text) TO postgres;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer, text, text) TO anon;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer, text, text) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer, text, text) TO service_role;


--
-- Name: FUNCTION pgis_geometry_accum_transfn(internal, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry) TO service_role;


--
-- Name: FUNCTION pgis_geometry_accum_transfn(internal, public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION pgis_geometry_accum_transfn(internal, public.geometry, double precision, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry, double precision, integer) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry, double precision, integer) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry, double precision, integer) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_accum_transfn(internal, public.geometry, double precision, integer) TO service_role;


--
-- Name: FUNCTION pgis_geometry_clusterintersecting_finalfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_clusterintersecting_finalfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_clusterintersecting_finalfn(internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_clusterintersecting_finalfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_clusterintersecting_finalfn(internal) TO service_role;


--
-- Name: FUNCTION pgis_geometry_clusterwithin_finalfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_clusterwithin_finalfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_clusterwithin_finalfn(internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_clusterwithin_finalfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_clusterwithin_finalfn(internal) TO service_role;


--
-- Name: FUNCTION pgis_geometry_collect_finalfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_collect_finalfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_collect_finalfn(internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_collect_finalfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_collect_finalfn(internal) TO service_role;


--
-- Name: FUNCTION pgis_geometry_makeline_finalfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_makeline_finalfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_makeline_finalfn(internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_makeline_finalfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_makeline_finalfn(internal) TO service_role;


--
-- Name: FUNCTION pgis_geometry_polygonize_finalfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_polygonize_finalfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_polygonize_finalfn(internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_polygonize_finalfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_polygonize_finalfn(internal) TO service_role;


--
-- Name: FUNCTION pgis_geometry_union_parallel_combinefn(internal, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_combinefn(internal, internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_combinefn(internal, internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_combinefn(internal, internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_combinefn(internal, internal) TO service_role;


--
-- Name: FUNCTION pgis_geometry_union_parallel_deserialfn(bytea, internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_deserialfn(bytea, internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_deserialfn(bytea, internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_deserialfn(bytea, internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_deserialfn(bytea, internal) TO service_role;


--
-- Name: FUNCTION pgis_geometry_union_parallel_finalfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_finalfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_finalfn(internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_finalfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_finalfn(internal) TO service_role;


--
-- Name: FUNCTION pgis_geometry_union_parallel_serialfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_serialfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_serialfn(internal) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_serialfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_serialfn(internal) TO service_role;


--
-- Name: FUNCTION pgis_geometry_union_parallel_transfn(internal, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_transfn(internal, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_transfn(internal, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_transfn(internal, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_transfn(internal, public.geometry) TO service_role;


--
-- Name: FUNCTION pgis_geometry_union_parallel_transfn(internal, public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_transfn(internal, public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_transfn(internal, public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_transfn(internal, public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.pgis_geometry_union_parallel_transfn(internal, public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION populate_geometry_columns(use_typmod boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.populate_geometry_columns(use_typmod boolean) TO postgres;
GRANT ALL ON FUNCTION public.populate_geometry_columns(use_typmod boolean) TO anon;
GRANT ALL ON FUNCTION public.populate_geometry_columns(use_typmod boolean) TO authenticated;
GRANT ALL ON FUNCTION public.populate_geometry_columns(use_typmod boolean) TO service_role;


--
-- Name: FUNCTION populate_geometry_columns(tbl_oid oid, use_typmod boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.populate_geometry_columns(tbl_oid oid, use_typmod boolean) TO postgres;
GRANT ALL ON FUNCTION public.populate_geometry_columns(tbl_oid oid, use_typmod boolean) TO anon;
GRANT ALL ON FUNCTION public.populate_geometry_columns(tbl_oid oid, use_typmod boolean) TO authenticated;
GRANT ALL ON FUNCTION public.populate_geometry_columns(tbl_oid oid, use_typmod boolean) TO service_role;


--
-- Name: FUNCTION postgis_addbbox(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_addbbox(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.postgis_addbbox(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.postgis_addbbox(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_addbbox(public.geometry) TO service_role;


--
-- Name: FUNCTION postgis_cache_bbox(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_cache_bbox() TO postgres;
GRANT ALL ON FUNCTION public.postgis_cache_bbox() TO anon;
GRANT ALL ON FUNCTION public.postgis_cache_bbox() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_cache_bbox() TO service_role;


--
-- Name: FUNCTION postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text) TO postgres;
GRANT ALL ON FUNCTION public.postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text) TO anon;
GRANT ALL ON FUNCTION public.postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text) TO service_role;


--
-- Name: FUNCTION postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text) TO postgres;
GRANT ALL ON FUNCTION public.postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text) TO anon;
GRANT ALL ON FUNCTION public.postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text) TO service_role;


--
-- Name: FUNCTION postgis_constraint_type(geomschema text, geomtable text, geomcolumn text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_constraint_type(geomschema text, geomtable text, geomcolumn text) TO postgres;
GRANT ALL ON FUNCTION public.postgis_constraint_type(geomschema text, geomtable text, geomcolumn text) TO anon;
GRANT ALL ON FUNCTION public.postgis_constraint_type(geomschema text, geomtable text, geomcolumn text) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_constraint_type(geomschema text, geomtable text, geomcolumn text) TO service_role;


--
-- Name: FUNCTION postgis_dropbbox(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_dropbbox(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.postgis_dropbbox(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.postgis_dropbbox(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_dropbbox(public.geometry) TO service_role;


--
-- Name: FUNCTION postgis_extensions_upgrade(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_extensions_upgrade() TO postgres;
GRANT ALL ON FUNCTION public.postgis_extensions_upgrade() TO anon;
GRANT ALL ON FUNCTION public.postgis_extensions_upgrade() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_extensions_upgrade() TO service_role;


--
-- Name: FUNCTION postgis_full_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_full_version() TO postgres;
GRANT ALL ON FUNCTION public.postgis_full_version() TO anon;
GRANT ALL ON FUNCTION public.postgis_full_version() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_full_version() TO service_role;


--
-- Name: FUNCTION postgis_geos_noop(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_geos_noop(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.postgis_geos_noop(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.postgis_geos_noop(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_geos_noop(public.geometry) TO service_role;


--
-- Name: FUNCTION postgis_geos_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_geos_version() TO postgres;
GRANT ALL ON FUNCTION public.postgis_geos_version() TO anon;
GRANT ALL ON FUNCTION public.postgis_geos_version() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_geos_version() TO service_role;


--
-- Name: FUNCTION postgis_getbbox(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_getbbox(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.postgis_getbbox(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.postgis_getbbox(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_getbbox(public.geometry) TO service_role;


--
-- Name: FUNCTION postgis_hasbbox(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_hasbbox(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.postgis_hasbbox(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.postgis_hasbbox(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_hasbbox(public.geometry) TO service_role;


--
-- Name: FUNCTION postgis_index_supportfn(internal); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_index_supportfn(internal) TO postgres;
GRANT ALL ON FUNCTION public.postgis_index_supportfn(internal) TO anon;
GRANT ALL ON FUNCTION public.postgis_index_supportfn(internal) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_index_supportfn(internal) TO service_role;


--
-- Name: FUNCTION postgis_lib_build_date(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_lib_build_date() TO postgres;
GRANT ALL ON FUNCTION public.postgis_lib_build_date() TO anon;
GRANT ALL ON FUNCTION public.postgis_lib_build_date() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_lib_build_date() TO service_role;


--
-- Name: FUNCTION postgis_lib_revision(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_lib_revision() TO postgres;
GRANT ALL ON FUNCTION public.postgis_lib_revision() TO anon;
GRANT ALL ON FUNCTION public.postgis_lib_revision() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_lib_revision() TO service_role;


--
-- Name: FUNCTION postgis_lib_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_lib_version() TO postgres;
GRANT ALL ON FUNCTION public.postgis_lib_version() TO anon;
GRANT ALL ON FUNCTION public.postgis_lib_version() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_lib_version() TO service_role;


--
-- Name: FUNCTION postgis_libjson_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_libjson_version() TO postgres;
GRANT ALL ON FUNCTION public.postgis_libjson_version() TO anon;
GRANT ALL ON FUNCTION public.postgis_libjson_version() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_libjson_version() TO service_role;


--
-- Name: FUNCTION postgis_liblwgeom_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_liblwgeom_version() TO postgres;
GRANT ALL ON FUNCTION public.postgis_liblwgeom_version() TO anon;
GRANT ALL ON FUNCTION public.postgis_liblwgeom_version() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_liblwgeom_version() TO service_role;


--
-- Name: FUNCTION postgis_libprotobuf_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_libprotobuf_version() TO postgres;
GRANT ALL ON FUNCTION public.postgis_libprotobuf_version() TO anon;
GRANT ALL ON FUNCTION public.postgis_libprotobuf_version() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_libprotobuf_version() TO service_role;


--
-- Name: FUNCTION postgis_libxml_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_libxml_version() TO postgres;
GRANT ALL ON FUNCTION public.postgis_libxml_version() TO anon;
GRANT ALL ON FUNCTION public.postgis_libxml_version() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_libxml_version() TO service_role;


--
-- Name: FUNCTION postgis_noop(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_noop(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.postgis_noop(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.postgis_noop(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_noop(public.geometry) TO service_role;


--
-- Name: FUNCTION postgis_proj_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_proj_version() TO postgres;
GRANT ALL ON FUNCTION public.postgis_proj_version() TO anon;
GRANT ALL ON FUNCTION public.postgis_proj_version() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_proj_version() TO service_role;


--
-- Name: FUNCTION postgis_scripts_build_date(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_scripts_build_date() TO postgres;
GRANT ALL ON FUNCTION public.postgis_scripts_build_date() TO anon;
GRANT ALL ON FUNCTION public.postgis_scripts_build_date() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_scripts_build_date() TO service_role;


--
-- Name: FUNCTION postgis_scripts_installed(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_scripts_installed() TO postgres;
GRANT ALL ON FUNCTION public.postgis_scripts_installed() TO anon;
GRANT ALL ON FUNCTION public.postgis_scripts_installed() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_scripts_installed() TO service_role;


--
-- Name: FUNCTION postgis_scripts_released(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_scripts_released() TO postgres;
GRANT ALL ON FUNCTION public.postgis_scripts_released() TO anon;
GRANT ALL ON FUNCTION public.postgis_scripts_released() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_scripts_released() TO service_role;


--
-- Name: FUNCTION postgis_svn_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_svn_version() TO postgres;
GRANT ALL ON FUNCTION public.postgis_svn_version() TO anon;
GRANT ALL ON FUNCTION public.postgis_svn_version() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_svn_version() TO service_role;


--
-- Name: FUNCTION postgis_transform_geometry(geom public.geometry, text, text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_transform_geometry(geom public.geometry, text, text, integer) TO postgres;
GRANT ALL ON FUNCTION public.postgis_transform_geometry(geom public.geometry, text, text, integer) TO anon;
GRANT ALL ON FUNCTION public.postgis_transform_geometry(geom public.geometry, text, text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_transform_geometry(geom public.geometry, text, text, integer) TO service_role;


--
-- Name: FUNCTION postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean) TO postgres;
GRANT ALL ON FUNCTION public.postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean) TO anon;
GRANT ALL ON FUNCTION public.postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean) TO service_role;


--
-- Name: FUNCTION postgis_typmod_dims(integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_typmod_dims(integer) TO postgres;
GRANT ALL ON FUNCTION public.postgis_typmod_dims(integer) TO anon;
GRANT ALL ON FUNCTION public.postgis_typmod_dims(integer) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_typmod_dims(integer) TO service_role;


--
-- Name: FUNCTION postgis_typmod_srid(integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_typmod_srid(integer) TO postgres;
GRANT ALL ON FUNCTION public.postgis_typmod_srid(integer) TO anon;
GRANT ALL ON FUNCTION public.postgis_typmod_srid(integer) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_typmod_srid(integer) TO service_role;


--
-- Name: FUNCTION postgis_typmod_type(integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_typmod_type(integer) TO postgres;
GRANT ALL ON FUNCTION public.postgis_typmod_type(integer) TO anon;
GRANT ALL ON FUNCTION public.postgis_typmod_type(integer) TO authenticated;
GRANT ALL ON FUNCTION public.postgis_typmod_type(integer) TO service_role;


--
-- Name: FUNCTION postgis_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_version() TO postgres;
GRANT ALL ON FUNCTION public.postgis_version() TO anon;
GRANT ALL ON FUNCTION public.postgis_version() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_version() TO service_role;


--
-- Name: FUNCTION postgis_wagyu_version(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.postgis_wagyu_version() TO postgres;
GRANT ALL ON FUNCTION public.postgis_wagyu_version() TO anon;
GRANT ALL ON FUNCTION public.postgis_wagyu_version() TO authenticated;
GRANT ALL ON FUNCTION public.postgis_wagyu_version() TO service_role;


--
-- Name: FUNCTION prevent_is_admin_self_modification(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.prevent_is_admin_self_modification() TO anon;
GRANT ALL ON FUNCTION public.prevent_is_admin_self_modification() TO authenticated;
GRANT ALL ON FUNCTION public.prevent_is_admin_self_modification() TO service_role;


--
-- Name: FUNCTION prevent_locked_inspection_changes(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.prevent_locked_inspection_changes() TO anon;
GRANT ALL ON FUNCTION public.prevent_locked_inspection_changes() TO authenticated;
GRANT ALL ON FUNCTION public.prevent_locked_inspection_changes() TO service_role;


--
-- Name: FUNCTION process_wallet_transaction(p_user_id uuid, p_type text, p_amount numeric, p_description text, p_reference_type text, p_reference_id uuid, p_metadata jsonb); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.process_wallet_transaction(p_user_id uuid, p_type text, p_amount numeric, p_description text, p_reference_type text, p_reference_id uuid, p_metadata jsonb) TO anon;
GRANT ALL ON FUNCTION public.process_wallet_transaction(p_user_id uuid, p_type text, p_amount numeric, p_description text, p_reference_type text, p_reference_id uuid, p_metadata jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.process_wallet_transaction(p_user_id uuid, p_type text, p_amount numeric, p_description text, p_reference_type text, p_reference_id uuid, p_metadata jsonb) TO service_role;


--
-- Name: FUNCTION refresh_all_user_credits(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.refresh_all_user_credits() TO anon;
GRANT ALL ON FUNCTION public.refresh_all_user_credits() TO authenticated;
GRANT ALL ON FUNCTION public.refresh_all_user_credits() TO service_role;


--
-- Name: FUNCTION regenerate_combined_pdf(p_mission_id uuid); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION public.regenerate_combined_pdf(p_mission_id uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION public.regenerate_combined_pdf(p_mission_id uuid) TO anon;
GRANT ALL ON FUNCTION public.regenerate_combined_pdf(p_mission_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.regenerate_combined_pdf(p_mission_id uuid) TO service_role;


--
-- Name: FUNCTION regenerate_inspection_pdf(p_inspection_id uuid); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION public.regenerate_inspection_pdf(p_inspection_id uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION public.regenerate_inspection_pdf(p_inspection_id uuid) TO anon;
GRANT ALL ON FUNCTION public.regenerate_inspection_pdf(p_inspection_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.regenerate_inspection_pdf(p_inspection_id uuid) TO service_role;


--
-- Name: FUNCTION reject_contact_invitation(p_contact_id uuid, p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.reject_contact_invitation(p_contact_id uuid, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.reject_contact_invitation(p_contact_id uuid, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.reject_contact_invitation(p_contact_id uuid, p_user_id uuid) TO service_role;


--
-- Name: FUNCTION renew_user_credits(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.renew_user_credits(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.renew_user_credits(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.renew_user_credits(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION reset_expired_subscription_credits(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.reset_expired_subscription_credits() TO anon;
GRANT ALL ON FUNCTION public.reset_expired_subscription_credits() TO authenticated;
GRANT ALL ON FUNCTION public.reset_expired_subscription_credits() TO service_role;


--
-- Name: FUNCTION search_rides(p_departure_city text, p_arrival_city text, p_departure_date date, p_min_seats integer, p_max_price numeric); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.search_rides(p_departure_city text, p_arrival_city text, p_departure_date date, p_min_seats integer, p_max_price numeric) TO anon;
GRANT ALL ON FUNCTION public.search_rides(p_departure_city text, p_arrival_city text, p_departure_date date, p_min_seats integer, p_max_price numeric) TO authenticated;
GRANT ALL ON FUNCTION public.search_rides(p_departure_city text, p_arrival_city text, p_departure_date date, p_min_seats integer, p_max_price numeric) TO service_role;


--
-- Name: FUNCTION send_push_notification(p_user_id uuid, p_title text, p_body text, p_data jsonb); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.send_push_notification(p_user_id uuid, p_title text, p_body text, p_data jsonb) TO anon;
GRANT ALL ON FUNCTION public.send_push_notification(p_user_id uuid, p_title text, p_body text, p_data jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.send_push_notification(p_user_id uuid, p_title text, p_body text, p_data jsonb) TO service_role;


--
-- Name: FUNCTION set_availability(p_user_id uuid, p_date date, p_status text, p_start_time time without time zone, p_end_time time without time zone, p_notes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.set_availability(p_user_id uuid, p_date date, p_status text, p_start_time time without time zone, p_end_time time without time zone, p_notes text) TO anon;
GRANT ALL ON FUNCTION public.set_availability(p_user_id uuid, p_date date, p_status text, p_start_time time without time zone, p_end_time time without time zone, p_notes text) TO authenticated;
GRANT ALL ON FUNCTION public.set_availability(p_user_id uuid, p_date date, p_status text, p_start_time time without time zone, p_end_time time without time zone, p_notes text) TO service_role;


--
-- Name: FUNCTION set_availability_range(p_user_id uuid, p_start_date date, p_end_date date, p_status text, p_start_time time without time zone, p_end_time time without time zone, p_notes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.set_availability_range(p_user_id uuid, p_start_date date, p_end_date date, p_status text, p_start_time time without time zone, p_end_time time without time zone, p_notes text) TO anon;
GRANT ALL ON FUNCTION public.set_availability_range(p_user_id uuid, p_start_date date, p_end_date date, p_status text, p_start_time time without time zone, p_end_time time without time zone, p_notes text) TO authenticated;
GRANT ALL ON FUNCTION public.set_availability_range(p_user_id uuid, p_start_date date, p_end_date date, p_status text, p_start_time time without time zone, p_end_time time without time zone, p_notes text) TO service_role;


--
-- Name: FUNCTION set_ride_expiration(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.set_ride_expiration() TO anon;
GRANT ALL ON FUNCTION public.set_ride_expiration() TO authenticated;
GRANT ALL ON FUNCTION public.set_ride_expiration() TO service_role;


--
-- Name: FUNCTION simplify_tracking_route(p_session_id uuid, p_tolerance double precision); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.simplify_tracking_route(p_session_id uuid, p_tolerance double precision) TO anon;
GRANT ALL ON FUNCTION public.simplify_tracking_route(p_session_id uuid, p_tolerance double precision) TO authenticated;
GRANT ALL ON FUNCTION public.simplify_tracking_route(p_session_id uuid, p_tolerance double precision) TO service_role;


--
-- Name: FUNCTION spend_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_reference_type text, p_reference_id text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.spend_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_reference_type text, p_reference_id text) TO anon;
GRANT ALL ON FUNCTION public.spend_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_reference_type text, p_reference_id text) TO authenticated;
GRANT ALL ON FUNCTION public.spend_credits_atomic(p_user_id uuid, p_amount integer, p_description text, p_reference_type text, p_reference_id text) TO service_role;


--
-- Name: FUNCTION st_3dclosestpoint(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3dclosestpoint(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_3dclosestpoint(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_3dclosestpoint(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_3dclosestpoint(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_3ddfullywithin(geom1 public.geometry, geom2 public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3ddfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_3ddfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_3ddfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_3ddfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_3ddistance(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3ddistance(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_3ddistance(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_3ddistance(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_3ddistance(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_3ddwithin(geom1 public.geometry, geom2 public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3ddwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_3ddwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_3ddwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_3ddwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_3dintersects(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3dintersects(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_3dintersects(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_3dintersects(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_3dintersects(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_3dlength(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3dlength(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_3dlength(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_3dlength(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_3dlength(public.geometry) TO service_role;


--
-- Name: FUNCTION st_3dlineinterpolatepoint(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3dlineinterpolatepoint(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_3dlineinterpolatepoint(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_3dlineinterpolatepoint(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_3dlineinterpolatepoint(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_3dlongestline(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3dlongestline(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_3dlongestline(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_3dlongestline(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_3dlongestline(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_3dmakebox(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3dmakebox(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_3dmakebox(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_3dmakebox(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_3dmakebox(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_3dmaxdistance(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3dmaxdistance(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_3dmaxdistance(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_3dmaxdistance(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_3dmaxdistance(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_3dperimeter(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3dperimeter(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_3dperimeter(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_3dperimeter(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_3dperimeter(public.geometry) TO service_role;


--
-- Name: FUNCTION st_3dshortestline(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3dshortestline(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_3dshortestline(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_3dshortestline(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_3dshortestline(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_addmeasure(public.geometry, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_addmeasure(public.geometry, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_addmeasure(public.geometry, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_addmeasure(public.geometry, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_addmeasure(public.geometry, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_addpoint(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_addpoint(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_addpoint(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_addpoint(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_addpoint(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_addpoint(geom1 public.geometry, geom2 public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_addpoint(geom1 public.geometry, geom2 public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_addpoint(geom1 public.geometry, geom2 public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_addpoint(geom1 public.geometry, geom2 public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_addpoint(geom1 public.geometry, geom2 public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_affine(public.geometry, double precision, double precision, double precision, double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_affine(public.geometry, double precision, double precision, double precision, double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_affine(public.geometry, double precision, double precision, double precision, double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_affine(public.geometry, double precision, double precision, double precision, double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_affine(public.geometry, double precision, double precision, double precision, double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_affine(public.geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_affine(public.geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_affine(public.geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_affine(public.geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_affine(public.geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_angle(line1 public.geometry, line2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_angle(line1 public.geometry, line2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_angle(line1 public.geometry, line2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_angle(line1 public.geometry, line2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_angle(line1 public.geometry, line2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_angle(pt1 public.geometry, pt2 public.geometry, pt3 public.geometry, pt4 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_angle(pt1 public.geometry, pt2 public.geometry, pt3 public.geometry, pt4 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_angle(pt1 public.geometry, pt2 public.geometry, pt3 public.geometry, pt4 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_angle(pt1 public.geometry, pt2 public.geometry, pt3 public.geometry, pt4 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_angle(pt1 public.geometry, pt2 public.geometry, pt3 public.geometry, pt4 public.geometry) TO service_role;


--
-- Name: FUNCTION st_area(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_area(text) TO postgres;
GRANT ALL ON FUNCTION public.st_area(text) TO anon;
GRANT ALL ON FUNCTION public.st_area(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_area(text) TO service_role;


--
-- Name: FUNCTION st_area(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_area(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_area(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_area(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_area(public.geometry) TO service_role;


--
-- Name: FUNCTION st_area(geog public.geography, use_spheroid boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_area(geog public.geography, use_spheroid boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_area(geog public.geography, use_spheroid boolean) TO anon;
GRANT ALL ON FUNCTION public.st_area(geog public.geography, use_spheroid boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_area(geog public.geography, use_spheroid boolean) TO service_role;


--
-- Name: FUNCTION st_area2d(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_area2d(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_area2d(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_area2d(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_area2d(public.geometry) TO service_role;


--
-- Name: FUNCTION st_asbinary(public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asbinary(public.geography) TO postgres;
GRANT ALL ON FUNCTION public.st_asbinary(public.geography) TO anon;
GRANT ALL ON FUNCTION public.st_asbinary(public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.st_asbinary(public.geography) TO service_role;


--
-- Name: FUNCTION st_asbinary(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asbinary(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_asbinary(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_asbinary(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_asbinary(public.geometry) TO service_role;


--
-- Name: FUNCTION st_asbinary(public.geography, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asbinary(public.geography, text) TO postgres;
GRANT ALL ON FUNCTION public.st_asbinary(public.geography, text) TO anon;
GRANT ALL ON FUNCTION public.st_asbinary(public.geography, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asbinary(public.geography, text) TO service_role;


--
-- Name: FUNCTION st_asbinary(public.geometry, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asbinary(public.geometry, text) TO postgres;
GRANT ALL ON FUNCTION public.st_asbinary(public.geometry, text) TO anon;
GRANT ALL ON FUNCTION public.st_asbinary(public.geometry, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asbinary(public.geometry, text) TO service_role;


--
-- Name: FUNCTION st_asencodedpolyline(geom public.geometry, nprecision integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asencodedpolyline(geom public.geometry, nprecision integer) TO postgres;
GRANT ALL ON FUNCTION public.st_asencodedpolyline(geom public.geometry, nprecision integer) TO anon;
GRANT ALL ON FUNCTION public.st_asencodedpolyline(geom public.geometry, nprecision integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_asencodedpolyline(geom public.geometry, nprecision integer) TO service_role;


--
-- Name: FUNCTION st_asewkb(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asewkb(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_asewkb(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_asewkb(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_asewkb(public.geometry) TO service_role;


--
-- Name: FUNCTION st_asewkb(public.geometry, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asewkb(public.geometry, text) TO postgres;
GRANT ALL ON FUNCTION public.st_asewkb(public.geometry, text) TO anon;
GRANT ALL ON FUNCTION public.st_asewkb(public.geometry, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asewkb(public.geometry, text) TO service_role;


--
-- Name: FUNCTION st_asewkt(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asewkt(text) TO postgres;
GRANT ALL ON FUNCTION public.st_asewkt(text) TO anon;
GRANT ALL ON FUNCTION public.st_asewkt(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asewkt(text) TO service_role;


--
-- Name: FUNCTION st_asewkt(public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asewkt(public.geography) TO postgres;
GRANT ALL ON FUNCTION public.st_asewkt(public.geography) TO anon;
GRANT ALL ON FUNCTION public.st_asewkt(public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.st_asewkt(public.geography) TO service_role;


--
-- Name: FUNCTION st_asewkt(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asewkt(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_asewkt(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_asewkt(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_asewkt(public.geometry) TO service_role;


--
-- Name: FUNCTION st_asewkt(public.geography, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asewkt(public.geography, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_asewkt(public.geography, integer) TO anon;
GRANT ALL ON FUNCTION public.st_asewkt(public.geography, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_asewkt(public.geography, integer) TO service_role;


--
-- Name: FUNCTION st_asewkt(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asewkt(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_asewkt(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_asewkt(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_asewkt(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_asgeojson(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asgeojson(text) TO postgres;
GRANT ALL ON FUNCTION public.st_asgeojson(text) TO anon;
GRANT ALL ON FUNCTION public.st_asgeojson(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asgeojson(text) TO service_role;


--
-- Name: FUNCTION st_asgeojson(geog public.geography, maxdecimaldigits integer, options integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asgeojson(geog public.geography, maxdecimaldigits integer, options integer) TO postgres;
GRANT ALL ON FUNCTION public.st_asgeojson(geog public.geography, maxdecimaldigits integer, options integer) TO anon;
GRANT ALL ON FUNCTION public.st_asgeojson(geog public.geography, maxdecimaldigits integer, options integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_asgeojson(geog public.geography, maxdecimaldigits integer, options integer) TO service_role;


--
-- Name: FUNCTION st_asgeojson(geom public.geometry, maxdecimaldigits integer, options integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asgeojson(geom public.geometry, maxdecimaldigits integer, options integer) TO postgres;
GRANT ALL ON FUNCTION public.st_asgeojson(geom public.geometry, maxdecimaldigits integer, options integer) TO anon;
GRANT ALL ON FUNCTION public.st_asgeojson(geom public.geometry, maxdecimaldigits integer, options integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_asgeojson(geom public.geometry, maxdecimaldigits integer, options integer) TO service_role;


--
-- Name: FUNCTION st_asgeojson(r record, geom_column text, maxdecimaldigits integer, pretty_bool boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asgeojson(r record, geom_column text, maxdecimaldigits integer, pretty_bool boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_asgeojson(r record, geom_column text, maxdecimaldigits integer, pretty_bool boolean) TO anon;
GRANT ALL ON FUNCTION public.st_asgeojson(r record, geom_column text, maxdecimaldigits integer, pretty_bool boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_asgeojson(r record, geom_column text, maxdecimaldigits integer, pretty_bool boolean) TO service_role;


--
-- Name: FUNCTION st_asgml(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asgml(text) TO postgres;
GRANT ALL ON FUNCTION public.st_asgml(text) TO anon;
GRANT ALL ON FUNCTION public.st_asgml(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asgml(text) TO service_role;


--
-- Name: FUNCTION st_asgml(geom public.geometry, maxdecimaldigits integer, options integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asgml(geom public.geometry, maxdecimaldigits integer, options integer) TO postgres;
GRANT ALL ON FUNCTION public.st_asgml(geom public.geometry, maxdecimaldigits integer, options integer) TO anon;
GRANT ALL ON FUNCTION public.st_asgml(geom public.geometry, maxdecimaldigits integer, options integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_asgml(geom public.geometry, maxdecimaldigits integer, options integer) TO service_role;


--
-- Name: FUNCTION st_asgml(geog public.geography, maxdecimaldigits integer, options integer, nprefix text, id text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asgml(geog public.geography, maxdecimaldigits integer, options integer, nprefix text, id text) TO postgres;
GRANT ALL ON FUNCTION public.st_asgml(geog public.geography, maxdecimaldigits integer, options integer, nprefix text, id text) TO anon;
GRANT ALL ON FUNCTION public.st_asgml(geog public.geography, maxdecimaldigits integer, options integer, nprefix text, id text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asgml(geog public.geography, maxdecimaldigits integer, options integer, nprefix text, id text) TO service_role;


--
-- Name: FUNCTION st_asgml(version integer, geog public.geography, maxdecimaldigits integer, options integer, nprefix text, id text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asgml(version integer, geog public.geography, maxdecimaldigits integer, options integer, nprefix text, id text) TO postgres;
GRANT ALL ON FUNCTION public.st_asgml(version integer, geog public.geography, maxdecimaldigits integer, options integer, nprefix text, id text) TO anon;
GRANT ALL ON FUNCTION public.st_asgml(version integer, geog public.geography, maxdecimaldigits integer, options integer, nprefix text, id text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asgml(version integer, geog public.geography, maxdecimaldigits integer, options integer, nprefix text, id text) TO service_role;


--
-- Name: FUNCTION st_asgml(version integer, geom public.geometry, maxdecimaldigits integer, options integer, nprefix text, id text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asgml(version integer, geom public.geometry, maxdecimaldigits integer, options integer, nprefix text, id text) TO postgres;
GRANT ALL ON FUNCTION public.st_asgml(version integer, geom public.geometry, maxdecimaldigits integer, options integer, nprefix text, id text) TO anon;
GRANT ALL ON FUNCTION public.st_asgml(version integer, geom public.geometry, maxdecimaldigits integer, options integer, nprefix text, id text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asgml(version integer, geom public.geometry, maxdecimaldigits integer, options integer, nprefix text, id text) TO service_role;


--
-- Name: FUNCTION st_ashexewkb(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_ashexewkb(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_ashexewkb(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_ashexewkb(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_ashexewkb(public.geometry) TO service_role;


--
-- Name: FUNCTION st_ashexewkb(public.geometry, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_ashexewkb(public.geometry, text) TO postgres;
GRANT ALL ON FUNCTION public.st_ashexewkb(public.geometry, text) TO anon;
GRANT ALL ON FUNCTION public.st_ashexewkb(public.geometry, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_ashexewkb(public.geometry, text) TO service_role;


--
-- Name: FUNCTION st_askml(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_askml(text) TO postgres;
GRANT ALL ON FUNCTION public.st_askml(text) TO anon;
GRANT ALL ON FUNCTION public.st_askml(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_askml(text) TO service_role;


--
-- Name: FUNCTION st_askml(geog public.geography, maxdecimaldigits integer, nprefix text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_askml(geog public.geography, maxdecimaldigits integer, nprefix text) TO postgres;
GRANT ALL ON FUNCTION public.st_askml(geog public.geography, maxdecimaldigits integer, nprefix text) TO anon;
GRANT ALL ON FUNCTION public.st_askml(geog public.geography, maxdecimaldigits integer, nprefix text) TO authenticated;
GRANT ALL ON FUNCTION public.st_askml(geog public.geography, maxdecimaldigits integer, nprefix text) TO service_role;


--
-- Name: FUNCTION st_askml(geom public.geometry, maxdecimaldigits integer, nprefix text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_askml(geom public.geometry, maxdecimaldigits integer, nprefix text) TO postgres;
GRANT ALL ON FUNCTION public.st_askml(geom public.geometry, maxdecimaldigits integer, nprefix text) TO anon;
GRANT ALL ON FUNCTION public.st_askml(geom public.geometry, maxdecimaldigits integer, nprefix text) TO authenticated;
GRANT ALL ON FUNCTION public.st_askml(geom public.geometry, maxdecimaldigits integer, nprefix text) TO service_role;


--
-- Name: FUNCTION st_aslatlontext(geom public.geometry, tmpl text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_aslatlontext(geom public.geometry, tmpl text) TO postgres;
GRANT ALL ON FUNCTION public.st_aslatlontext(geom public.geometry, tmpl text) TO anon;
GRANT ALL ON FUNCTION public.st_aslatlontext(geom public.geometry, tmpl text) TO authenticated;
GRANT ALL ON FUNCTION public.st_aslatlontext(geom public.geometry, tmpl text) TO service_role;


--
-- Name: FUNCTION st_asmarc21(geom public.geometry, format text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asmarc21(geom public.geometry, format text) TO postgres;
GRANT ALL ON FUNCTION public.st_asmarc21(geom public.geometry, format text) TO anon;
GRANT ALL ON FUNCTION public.st_asmarc21(geom public.geometry, format text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asmarc21(geom public.geometry, format text) TO service_role;


--
-- Name: FUNCTION st_asmvtgeom(geom public.geometry, bounds public.box2d, extent integer, buffer integer, clip_geom boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asmvtgeom(geom public.geometry, bounds public.box2d, extent integer, buffer integer, clip_geom boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_asmvtgeom(geom public.geometry, bounds public.box2d, extent integer, buffer integer, clip_geom boolean) TO anon;
GRANT ALL ON FUNCTION public.st_asmvtgeom(geom public.geometry, bounds public.box2d, extent integer, buffer integer, clip_geom boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_asmvtgeom(geom public.geometry, bounds public.box2d, extent integer, buffer integer, clip_geom boolean) TO service_role;


--
-- Name: FUNCTION st_assvg(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_assvg(text) TO postgres;
GRANT ALL ON FUNCTION public.st_assvg(text) TO anon;
GRANT ALL ON FUNCTION public.st_assvg(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_assvg(text) TO service_role;


--
-- Name: FUNCTION st_assvg(geog public.geography, rel integer, maxdecimaldigits integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_assvg(geog public.geography, rel integer, maxdecimaldigits integer) TO postgres;
GRANT ALL ON FUNCTION public.st_assvg(geog public.geography, rel integer, maxdecimaldigits integer) TO anon;
GRANT ALL ON FUNCTION public.st_assvg(geog public.geography, rel integer, maxdecimaldigits integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_assvg(geog public.geography, rel integer, maxdecimaldigits integer) TO service_role;


--
-- Name: FUNCTION st_assvg(geom public.geometry, rel integer, maxdecimaldigits integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_assvg(geom public.geometry, rel integer, maxdecimaldigits integer) TO postgres;
GRANT ALL ON FUNCTION public.st_assvg(geom public.geometry, rel integer, maxdecimaldigits integer) TO anon;
GRANT ALL ON FUNCTION public.st_assvg(geom public.geometry, rel integer, maxdecimaldigits integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_assvg(geom public.geometry, rel integer, maxdecimaldigits integer) TO service_role;


--
-- Name: FUNCTION st_astext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_astext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_astext(text) TO anon;
GRANT ALL ON FUNCTION public.st_astext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_astext(text) TO service_role;


--
-- Name: FUNCTION st_astext(public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_astext(public.geography) TO postgres;
GRANT ALL ON FUNCTION public.st_astext(public.geography) TO anon;
GRANT ALL ON FUNCTION public.st_astext(public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.st_astext(public.geography) TO service_role;


--
-- Name: FUNCTION st_astext(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_astext(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_astext(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_astext(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_astext(public.geometry) TO service_role;


--
-- Name: FUNCTION st_astext(public.geography, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_astext(public.geography, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_astext(public.geography, integer) TO anon;
GRANT ALL ON FUNCTION public.st_astext(public.geography, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_astext(public.geography, integer) TO service_role;


--
-- Name: FUNCTION st_astext(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_astext(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_astext(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_astext(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_astext(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_astwkb(geom public.geometry, prec integer, prec_z integer, prec_m integer, with_sizes boolean, with_boxes boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_astwkb(geom public.geometry, prec integer, prec_z integer, prec_m integer, with_sizes boolean, with_boxes boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_astwkb(geom public.geometry, prec integer, prec_z integer, prec_m integer, with_sizes boolean, with_boxes boolean) TO anon;
GRANT ALL ON FUNCTION public.st_astwkb(geom public.geometry, prec integer, prec_z integer, prec_m integer, with_sizes boolean, with_boxes boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_astwkb(geom public.geometry, prec integer, prec_z integer, prec_m integer, with_sizes boolean, with_boxes boolean) TO service_role;


--
-- Name: FUNCTION st_astwkb(geom public.geometry[], ids bigint[], prec integer, prec_z integer, prec_m integer, with_sizes boolean, with_boxes boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_astwkb(geom public.geometry[], ids bigint[], prec integer, prec_z integer, prec_m integer, with_sizes boolean, with_boxes boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_astwkb(geom public.geometry[], ids bigint[], prec integer, prec_z integer, prec_m integer, with_sizes boolean, with_boxes boolean) TO anon;
GRANT ALL ON FUNCTION public.st_astwkb(geom public.geometry[], ids bigint[], prec integer, prec_z integer, prec_m integer, with_sizes boolean, with_boxes boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_astwkb(geom public.geometry[], ids bigint[], prec integer, prec_z integer, prec_m integer, with_sizes boolean, with_boxes boolean) TO service_role;


--
-- Name: FUNCTION st_asx3d(geom public.geometry, maxdecimaldigits integer, options integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asx3d(geom public.geometry, maxdecimaldigits integer, options integer) TO postgres;
GRANT ALL ON FUNCTION public.st_asx3d(geom public.geometry, maxdecimaldigits integer, options integer) TO anon;
GRANT ALL ON FUNCTION public.st_asx3d(geom public.geometry, maxdecimaldigits integer, options integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_asx3d(geom public.geometry, maxdecimaldigits integer, options integer) TO service_role;


--
-- Name: FUNCTION st_azimuth(geog1 public.geography, geog2 public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_azimuth(geog1 public.geography, geog2 public.geography) TO postgres;
GRANT ALL ON FUNCTION public.st_azimuth(geog1 public.geography, geog2 public.geography) TO anon;
GRANT ALL ON FUNCTION public.st_azimuth(geog1 public.geography, geog2 public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.st_azimuth(geog1 public.geography, geog2 public.geography) TO service_role;


--
-- Name: FUNCTION st_azimuth(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_azimuth(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_azimuth(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_azimuth(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_azimuth(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_bdmpolyfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_bdmpolyfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_bdmpolyfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_bdmpolyfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_bdmpolyfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_bdpolyfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_bdpolyfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_bdpolyfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_bdpolyfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_bdpolyfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_boundary(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_boundary(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_boundary(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_boundary(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_boundary(public.geometry) TO service_role;


--
-- Name: FUNCTION st_boundingdiagonal(geom public.geometry, fits boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_boundingdiagonal(geom public.geometry, fits boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_boundingdiagonal(geom public.geometry, fits boolean) TO anon;
GRANT ALL ON FUNCTION public.st_boundingdiagonal(geom public.geometry, fits boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_boundingdiagonal(geom public.geometry, fits boolean) TO service_role;


--
-- Name: FUNCTION st_box2dfromgeohash(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_box2dfromgeohash(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_box2dfromgeohash(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_box2dfromgeohash(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_box2dfromgeohash(text, integer) TO service_role;


--
-- Name: FUNCTION st_buffer(text, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_buffer(text, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_buffer(text, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_buffer(text, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_buffer(text, double precision) TO service_role;


--
-- Name: FUNCTION st_buffer(public.geography, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision) TO service_role;


--
-- Name: FUNCTION st_buffer(text, double precision, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_buffer(text, double precision, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_buffer(text, double precision, integer) TO anon;
GRANT ALL ON FUNCTION public.st_buffer(text, double precision, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_buffer(text, double precision, integer) TO service_role;


--
-- Name: FUNCTION st_buffer(text, double precision, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_buffer(text, double precision, text) TO postgres;
GRANT ALL ON FUNCTION public.st_buffer(text, double precision, text) TO anon;
GRANT ALL ON FUNCTION public.st_buffer(text, double precision, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_buffer(text, double precision, text) TO service_role;


--
-- Name: FUNCTION st_buffer(public.geography, double precision, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision, integer) TO anon;
GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision, integer) TO service_role;


--
-- Name: FUNCTION st_buffer(public.geography, double precision, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision, text) TO postgres;
GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision, text) TO anon;
GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_buffer(public.geography, double precision, text) TO service_role;


--
-- Name: FUNCTION st_buffer(geom public.geometry, radius double precision, quadsegs integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_buffer(geom public.geometry, radius double precision, quadsegs integer) TO postgres;
GRANT ALL ON FUNCTION public.st_buffer(geom public.geometry, radius double precision, quadsegs integer) TO anon;
GRANT ALL ON FUNCTION public.st_buffer(geom public.geometry, radius double precision, quadsegs integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_buffer(geom public.geometry, radius double precision, quadsegs integer) TO service_role;


--
-- Name: FUNCTION st_buffer(geom public.geometry, radius double precision, options text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_buffer(geom public.geometry, radius double precision, options text) TO postgres;
GRANT ALL ON FUNCTION public.st_buffer(geom public.geometry, radius double precision, options text) TO anon;
GRANT ALL ON FUNCTION public.st_buffer(geom public.geometry, radius double precision, options text) TO authenticated;
GRANT ALL ON FUNCTION public.st_buffer(geom public.geometry, radius double precision, options text) TO service_role;


--
-- Name: FUNCTION st_buildarea(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_buildarea(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_buildarea(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_buildarea(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_buildarea(public.geometry) TO service_role;


--
-- Name: FUNCTION st_centroid(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_centroid(text) TO postgres;
GRANT ALL ON FUNCTION public.st_centroid(text) TO anon;
GRANT ALL ON FUNCTION public.st_centroid(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_centroid(text) TO service_role;


--
-- Name: FUNCTION st_centroid(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_centroid(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_centroid(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_centroid(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_centroid(public.geometry) TO service_role;


--
-- Name: FUNCTION st_centroid(public.geography, use_spheroid boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_centroid(public.geography, use_spheroid boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_centroid(public.geography, use_spheroid boolean) TO anon;
GRANT ALL ON FUNCTION public.st_centroid(public.geography, use_spheroid boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_centroid(public.geography, use_spheroid boolean) TO service_role;


--
-- Name: FUNCTION st_chaikinsmoothing(public.geometry, integer, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_chaikinsmoothing(public.geometry, integer, boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_chaikinsmoothing(public.geometry, integer, boolean) TO anon;
GRANT ALL ON FUNCTION public.st_chaikinsmoothing(public.geometry, integer, boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_chaikinsmoothing(public.geometry, integer, boolean) TO service_role;


--
-- Name: FUNCTION st_cleangeometry(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_cleangeometry(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_cleangeometry(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_cleangeometry(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_cleangeometry(public.geometry) TO service_role;


--
-- Name: FUNCTION st_clipbybox2d(geom public.geometry, box public.box2d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_clipbybox2d(geom public.geometry, box public.box2d) TO postgres;
GRANT ALL ON FUNCTION public.st_clipbybox2d(geom public.geometry, box public.box2d) TO anon;
GRANT ALL ON FUNCTION public.st_clipbybox2d(geom public.geometry, box public.box2d) TO authenticated;
GRANT ALL ON FUNCTION public.st_clipbybox2d(geom public.geometry, box public.box2d) TO service_role;


--
-- Name: FUNCTION st_closestpoint(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_closestpoint(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_closestpoint(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_closestpoint(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_closestpoint(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_closestpointofapproach(public.geometry, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_closestpointofapproach(public.geometry, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_closestpointofapproach(public.geometry, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_closestpointofapproach(public.geometry, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_closestpointofapproach(public.geometry, public.geometry) TO service_role;


--
-- Name: FUNCTION st_clusterdbscan(public.geometry, eps double precision, minpoints integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_clusterdbscan(public.geometry, eps double precision, minpoints integer) TO postgres;
GRANT ALL ON FUNCTION public.st_clusterdbscan(public.geometry, eps double precision, minpoints integer) TO anon;
GRANT ALL ON FUNCTION public.st_clusterdbscan(public.geometry, eps double precision, minpoints integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_clusterdbscan(public.geometry, eps double precision, minpoints integer) TO service_role;


--
-- Name: FUNCTION st_clusterintersecting(public.geometry[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_clusterintersecting(public.geometry[]) TO postgres;
GRANT ALL ON FUNCTION public.st_clusterintersecting(public.geometry[]) TO anon;
GRANT ALL ON FUNCTION public.st_clusterintersecting(public.geometry[]) TO authenticated;
GRANT ALL ON FUNCTION public.st_clusterintersecting(public.geometry[]) TO service_role;


--
-- Name: FUNCTION st_clusterkmeans(geom public.geometry, k integer, max_radius double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_clusterkmeans(geom public.geometry, k integer, max_radius double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_clusterkmeans(geom public.geometry, k integer, max_radius double precision) TO anon;
GRANT ALL ON FUNCTION public.st_clusterkmeans(geom public.geometry, k integer, max_radius double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_clusterkmeans(geom public.geometry, k integer, max_radius double precision) TO service_role;


--
-- Name: FUNCTION st_clusterwithin(public.geometry[], double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_clusterwithin(public.geometry[], double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_clusterwithin(public.geometry[], double precision) TO anon;
GRANT ALL ON FUNCTION public.st_clusterwithin(public.geometry[], double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_clusterwithin(public.geometry[], double precision) TO service_role;


--
-- Name: FUNCTION st_collect(public.geometry[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_collect(public.geometry[]) TO postgres;
GRANT ALL ON FUNCTION public.st_collect(public.geometry[]) TO anon;
GRANT ALL ON FUNCTION public.st_collect(public.geometry[]) TO authenticated;
GRANT ALL ON FUNCTION public.st_collect(public.geometry[]) TO service_role;


--
-- Name: FUNCTION st_collect(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_collect(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_collect(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_collect(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_collect(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_collectionextract(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_collectionextract(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_collectionextract(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_collectionextract(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_collectionextract(public.geometry) TO service_role;


--
-- Name: FUNCTION st_collectionextract(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_collectionextract(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_collectionextract(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_collectionextract(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_collectionextract(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_collectionhomogenize(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_collectionhomogenize(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_collectionhomogenize(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_collectionhomogenize(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_collectionhomogenize(public.geometry) TO service_role;


--
-- Name: FUNCTION st_combinebbox(public.box2d, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_combinebbox(public.box2d, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_combinebbox(public.box2d, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_combinebbox(public.box2d, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_combinebbox(public.box2d, public.geometry) TO service_role;


--
-- Name: FUNCTION st_combinebbox(public.box3d, public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_combinebbox(public.box3d, public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.st_combinebbox(public.box3d, public.box3d) TO anon;
GRANT ALL ON FUNCTION public.st_combinebbox(public.box3d, public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.st_combinebbox(public.box3d, public.box3d) TO service_role;


--
-- Name: FUNCTION st_combinebbox(public.box3d, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_combinebbox(public.box3d, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_combinebbox(public.box3d, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_combinebbox(public.box3d, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_combinebbox(public.box3d, public.geometry) TO service_role;


--
-- Name: FUNCTION st_concavehull(param_geom public.geometry, param_pctconvex double precision, param_allow_holes boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_concavehull(param_geom public.geometry, param_pctconvex double precision, param_allow_holes boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_concavehull(param_geom public.geometry, param_pctconvex double precision, param_allow_holes boolean) TO anon;
GRANT ALL ON FUNCTION public.st_concavehull(param_geom public.geometry, param_pctconvex double precision, param_allow_holes boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_concavehull(param_geom public.geometry, param_pctconvex double precision, param_allow_holes boolean) TO service_role;


--
-- Name: FUNCTION st_contains(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_contains(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_contains(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_contains(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_contains(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_containsproperly(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_containsproperly(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_containsproperly(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_containsproperly(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_containsproperly(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_convexhull(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_convexhull(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_convexhull(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_convexhull(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_convexhull(public.geometry) TO service_role;


--
-- Name: FUNCTION st_coorddim(geometry public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_coorddim(geometry public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_coorddim(geometry public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_coorddim(geometry public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_coorddim(geometry public.geometry) TO service_role;


--
-- Name: FUNCTION st_coveredby(text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_coveredby(text, text) TO postgres;
GRANT ALL ON FUNCTION public.st_coveredby(text, text) TO anon;
GRANT ALL ON FUNCTION public.st_coveredby(text, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_coveredby(text, text) TO service_role;


--
-- Name: FUNCTION st_coveredby(geog1 public.geography, geog2 public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_coveredby(geog1 public.geography, geog2 public.geography) TO postgres;
GRANT ALL ON FUNCTION public.st_coveredby(geog1 public.geography, geog2 public.geography) TO anon;
GRANT ALL ON FUNCTION public.st_coveredby(geog1 public.geography, geog2 public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.st_coveredby(geog1 public.geography, geog2 public.geography) TO service_role;


--
-- Name: FUNCTION st_coveredby(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_coveredby(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_coveredby(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_coveredby(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_coveredby(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_covers(text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_covers(text, text) TO postgres;
GRANT ALL ON FUNCTION public.st_covers(text, text) TO anon;
GRANT ALL ON FUNCTION public.st_covers(text, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_covers(text, text) TO service_role;


--
-- Name: FUNCTION st_covers(geog1 public.geography, geog2 public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_covers(geog1 public.geography, geog2 public.geography) TO postgres;
GRANT ALL ON FUNCTION public.st_covers(geog1 public.geography, geog2 public.geography) TO anon;
GRANT ALL ON FUNCTION public.st_covers(geog1 public.geography, geog2 public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.st_covers(geog1 public.geography, geog2 public.geography) TO service_role;


--
-- Name: FUNCTION st_covers(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_covers(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_covers(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_covers(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_covers(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_cpawithin(public.geometry, public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_cpawithin(public.geometry, public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_cpawithin(public.geometry, public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_cpawithin(public.geometry, public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_cpawithin(public.geometry, public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_crosses(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_crosses(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_crosses(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_crosses(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_crosses(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_curvetoline(geom public.geometry, tol double precision, toltype integer, flags integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_curvetoline(geom public.geometry, tol double precision, toltype integer, flags integer) TO postgres;
GRANT ALL ON FUNCTION public.st_curvetoline(geom public.geometry, tol double precision, toltype integer, flags integer) TO anon;
GRANT ALL ON FUNCTION public.st_curvetoline(geom public.geometry, tol double precision, toltype integer, flags integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_curvetoline(geom public.geometry, tol double precision, toltype integer, flags integer) TO service_role;


--
-- Name: FUNCTION st_delaunaytriangles(g1 public.geometry, tolerance double precision, flags integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_delaunaytriangles(g1 public.geometry, tolerance double precision, flags integer) TO postgres;
GRANT ALL ON FUNCTION public.st_delaunaytriangles(g1 public.geometry, tolerance double precision, flags integer) TO anon;
GRANT ALL ON FUNCTION public.st_delaunaytriangles(g1 public.geometry, tolerance double precision, flags integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_delaunaytriangles(g1 public.geometry, tolerance double precision, flags integer) TO service_role;


--
-- Name: FUNCTION st_dfullywithin(geom1 public.geometry, geom2 public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_dfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_dfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_dfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_dfullywithin(geom1 public.geometry, geom2 public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_difference(geom1 public.geometry, geom2 public.geometry, gridsize double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_difference(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_difference(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO anon;
GRANT ALL ON FUNCTION public.st_difference(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_difference(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO service_role;


--
-- Name: FUNCTION st_dimension(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_dimension(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_dimension(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_dimension(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_dimension(public.geometry) TO service_role;


--
-- Name: FUNCTION st_disjoint(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_disjoint(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_disjoint(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_disjoint(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_disjoint(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_distance(text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_distance(text, text) TO postgres;
GRANT ALL ON FUNCTION public.st_distance(text, text) TO anon;
GRANT ALL ON FUNCTION public.st_distance(text, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_distance(text, text) TO service_role;


--
-- Name: FUNCTION st_distance(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_distance(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_distance(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_distance(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_distance(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_distance(geog1 public.geography, geog2 public.geography, use_spheroid boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_distance(geog1 public.geography, geog2 public.geography, use_spheroid boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_distance(geog1 public.geography, geog2 public.geography, use_spheroid boolean) TO anon;
GRANT ALL ON FUNCTION public.st_distance(geog1 public.geography, geog2 public.geography, use_spheroid boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_distance(geog1 public.geography, geog2 public.geography, use_spheroid boolean) TO service_role;


--
-- Name: FUNCTION st_distancecpa(public.geometry, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_distancecpa(public.geometry, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_distancecpa(public.geometry, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_distancecpa(public.geometry, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_distancecpa(public.geometry, public.geometry) TO service_role;


--
-- Name: FUNCTION st_distancesphere(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_distancesphere(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_distancesphere(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_distancesphere(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_distancesphere(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_distancesphere(geom1 public.geometry, geom2 public.geometry, radius double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_distancesphere(geom1 public.geometry, geom2 public.geometry, radius double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_distancesphere(geom1 public.geometry, geom2 public.geometry, radius double precision) TO anon;
GRANT ALL ON FUNCTION public.st_distancesphere(geom1 public.geometry, geom2 public.geometry, radius double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_distancesphere(geom1 public.geometry, geom2 public.geometry, radius double precision) TO service_role;


--
-- Name: FUNCTION st_distancespheroid(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_distancespheroid(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_distancespheroid(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_distancespheroid(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_distancespheroid(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_distancespheroid(geom1 public.geometry, geom2 public.geometry, public.spheroid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_distancespheroid(geom1 public.geometry, geom2 public.geometry, public.spheroid) TO postgres;
GRANT ALL ON FUNCTION public.st_distancespheroid(geom1 public.geometry, geom2 public.geometry, public.spheroid) TO anon;
GRANT ALL ON FUNCTION public.st_distancespheroid(geom1 public.geometry, geom2 public.geometry, public.spheroid) TO authenticated;
GRANT ALL ON FUNCTION public.st_distancespheroid(geom1 public.geometry, geom2 public.geometry, public.spheroid) TO service_role;


--
-- Name: FUNCTION st_dump(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_dump(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_dump(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_dump(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_dump(public.geometry) TO service_role;


--
-- Name: FUNCTION st_dumppoints(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_dumppoints(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_dumppoints(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_dumppoints(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_dumppoints(public.geometry) TO service_role;


--
-- Name: FUNCTION st_dumprings(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_dumprings(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_dumprings(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_dumprings(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_dumprings(public.geometry) TO service_role;


--
-- Name: FUNCTION st_dumpsegments(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_dumpsegments(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_dumpsegments(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_dumpsegments(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_dumpsegments(public.geometry) TO service_role;


--
-- Name: FUNCTION st_dwithin(text, text, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_dwithin(text, text, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_dwithin(text, text, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_dwithin(text, text, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_dwithin(text, text, double precision) TO service_role;


--
-- Name: FUNCTION st_dwithin(geom1 public.geometry, geom2 public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_dwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_dwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_dwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_dwithin(geom1 public.geometry, geom2 public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_dwithin(geog1 public.geography, geog2 public.geography, tolerance double precision, use_spheroid boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_dwithin(geog1 public.geography, geog2 public.geography, tolerance double precision, use_spheroid boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_dwithin(geog1 public.geography, geog2 public.geography, tolerance double precision, use_spheroid boolean) TO anon;
GRANT ALL ON FUNCTION public.st_dwithin(geog1 public.geography, geog2 public.geography, tolerance double precision, use_spheroid boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_dwithin(geog1 public.geography, geog2 public.geography, tolerance double precision, use_spheroid boolean) TO service_role;


--
-- Name: FUNCTION st_endpoint(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_endpoint(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_endpoint(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_endpoint(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_endpoint(public.geometry) TO service_role;


--
-- Name: FUNCTION st_envelope(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_envelope(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_envelope(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_envelope(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_envelope(public.geometry) TO service_role;


--
-- Name: FUNCTION st_equals(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_equals(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_equals(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_equals(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_equals(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_estimatedextent(text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_estimatedextent(text, text) TO postgres;
GRANT ALL ON FUNCTION public.st_estimatedextent(text, text) TO anon;
GRANT ALL ON FUNCTION public.st_estimatedextent(text, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_estimatedextent(text, text) TO service_role;


--
-- Name: FUNCTION st_estimatedextent(text, text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_estimatedextent(text, text, text) TO postgres;
GRANT ALL ON FUNCTION public.st_estimatedextent(text, text, text) TO anon;
GRANT ALL ON FUNCTION public.st_estimatedextent(text, text, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_estimatedextent(text, text, text) TO service_role;


--
-- Name: FUNCTION st_estimatedextent(text, text, text, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_estimatedextent(text, text, text, boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_estimatedextent(text, text, text, boolean) TO anon;
GRANT ALL ON FUNCTION public.st_estimatedextent(text, text, text, boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_estimatedextent(text, text, text, boolean) TO service_role;


--
-- Name: FUNCTION st_expand(public.box2d, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_expand(public.box2d, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_expand(public.box2d, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_expand(public.box2d, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_expand(public.box2d, double precision) TO service_role;


--
-- Name: FUNCTION st_expand(public.box3d, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_expand(public.box3d, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_expand(public.box3d, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_expand(public.box3d, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_expand(public.box3d, double precision) TO service_role;


--
-- Name: FUNCTION st_expand(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_expand(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_expand(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_expand(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_expand(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_expand(box public.box2d, dx double precision, dy double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_expand(box public.box2d, dx double precision, dy double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_expand(box public.box2d, dx double precision, dy double precision) TO anon;
GRANT ALL ON FUNCTION public.st_expand(box public.box2d, dx double precision, dy double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_expand(box public.box2d, dx double precision, dy double precision) TO service_role;


--
-- Name: FUNCTION st_expand(box public.box3d, dx double precision, dy double precision, dz double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_expand(box public.box3d, dx double precision, dy double precision, dz double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_expand(box public.box3d, dx double precision, dy double precision, dz double precision) TO anon;
GRANT ALL ON FUNCTION public.st_expand(box public.box3d, dx double precision, dy double precision, dz double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_expand(box public.box3d, dx double precision, dy double precision, dz double precision) TO service_role;


--
-- Name: FUNCTION st_expand(geom public.geometry, dx double precision, dy double precision, dz double precision, dm double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_expand(geom public.geometry, dx double precision, dy double precision, dz double precision, dm double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_expand(geom public.geometry, dx double precision, dy double precision, dz double precision, dm double precision) TO anon;
GRANT ALL ON FUNCTION public.st_expand(geom public.geometry, dx double precision, dy double precision, dz double precision, dm double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_expand(geom public.geometry, dx double precision, dy double precision, dz double precision, dm double precision) TO service_role;


--
-- Name: FUNCTION st_exteriorring(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_exteriorring(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_exteriorring(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_exteriorring(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_exteriorring(public.geometry) TO service_role;


--
-- Name: FUNCTION st_filterbym(public.geometry, double precision, double precision, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_filterbym(public.geometry, double precision, double precision, boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_filterbym(public.geometry, double precision, double precision, boolean) TO anon;
GRANT ALL ON FUNCTION public.st_filterbym(public.geometry, double precision, double precision, boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_filterbym(public.geometry, double precision, double precision, boolean) TO service_role;


--
-- Name: FUNCTION st_findextent(text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_findextent(text, text) TO postgres;
GRANT ALL ON FUNCTION public.st_findextent(text, text) TO anon;
GRANT ALL ON FUNCTION public.st_findextent(text, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_findextent(text, text) TO service_role;


--
-- Name: FUNCTION st_findextent(text, text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_findextent(text, text, text) TO postgres;
GRANT ALL ON FUNCTION public.st_findextent(text, text, text) TO anon;
GRANT ALL ON FUNCTION public.st_findextent(text, text, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_findextent(text, text, text) TO service_role;


--
-- Name: FUNCTION st_flipcoordinates(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_flipcoordinates(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_flipcoordinates(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_flipcoordinates(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_flipcoordinates(public.geometry) TO service_role;


--
-- Name: FUNCTION st_force2d(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_force2d(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_force2d(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_force2d(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_force2d(public.geometry) TO service_role;


--
-- Name: FUNCTION st_force3d(geom public.geometry, zvalue double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_force3d(geom public.geometry, zvalue double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_force3d(geom public.geometry, zvalue double precision) TO anon;
GRANT ALL ON FUNCTION public.st_force3d(geom public.geometry, zvalue double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_force3d(geom public.geometry, zvalue double precision) TO service_role;


--
-- Name: FUNCTION st_force3dm(geom public.geometry, mvalue double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_force3dm(geom public.geometry, mvalue double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_force3dm(geom public.geometry, mvalue double precision) TO anon;
GRANT ALL ON FUNCTION public.st_force3dm(geom public.geometry, mvalue double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_force3dm(geom public.geometry, mvalue double precision) TO service_role;


--
-- Name: FUNCTION st_force3dz(geom public.geometry, zvalue double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_force3dz(geom public.geometry, zvalue double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_force3dz(geom public.geometry, zvalue double precision) TO anon;
GRANT ALL ON FUNCTION public.st_force3dz(geom public.geometry, zvalue double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_force3dz(geom public.geometry, zvalue double precision) TO service_role;


--
-- Name: FUNCTION st_force4d(geom public.geometry, zvalue double precision, mvalue double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_force4d(geom public.geometry, zvalue double precision, mvalue double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_force4d(geom public.geometry, zvalue double precision, mvalue double precision) TO anon;
GRANT ALL ON FUNCTION public.st_force4d(geom public.geometry, zvalue double precision, mvalue double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_force4d(geom public.geometry, zvalue double precision, mvalue double precision) TO service_role;


--
-- Name: FUNCTION st_forcecollection(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_forcecollection(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_forcecollection(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_forcecollection(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_forcecollection(public.geometry) TO service_role;


--
-- Name: FUNCTION st_forcecurve(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_forcecurve(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_forcecurve(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_forcecurve(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_forcecurve(public.geometry) TO service_role;


--
-- Name: FUNCTION st_forcepolygonccw(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_forcepolygonccw(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_forcepolygonccw(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_forcepolygonccw(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_forcepolygonccw(public.geometry) TO service_role;


--
-- Name: FUNCTION st_forcepolygoncw(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_forcepolygoncw(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_forcepolygoncw(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_forcepolygoncw(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_forcepolygoncw(public.geometry) TO service_role;


--
-- Name: FUNCTION st_forcerhr(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_forcerhr(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_forcerhr(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_forcerhr(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_forcerhr(public.geometry) TO service_role;


--
-- Name: FUNCTION st_forcesfs(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_forcesfs(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_forcesfs(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_forcesfs(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_forcesfs(public.geometry) TO service_role;


--
-- Name: FUNCTION st_forcesfs(public.geometry, version text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_forcesfs(public.geometry, version text) TO postgres;
GRANT ALL ON FUNCTION public.st_forcesfs(public.geometry, version text) TO anon;
GRANT ALL ON FUNCTION public.st_forcesfs(public.geometry, version text) TO authenticated;
GRANT ALL ON FUNCTION public.st_forcesfs(public.geometry, version text) TO service_role;


--
-- Name: FUNCTION st_frechetdistance(geom1 public.geometry, geom2 public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_frechetdistance(geom1 public.geometry, geom2 public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_frechetdistance(geom1 public.geometry, geom2 public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_frechetdistance(geom1 public.geometry, geom2 public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_frechetdistance(geom1 public.geometry, geom2 public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_fromflatgeobuf(anyelement, bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_fromflatgeobuf(anyelement, bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_fromflatgeobuf(anyelement, bytea) TO anon;
GRANT ALL ON FUNCTION public.st_fromflatgeobuf(anyelement, bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_fromflatgeobuf(anyelement, bytea) TO service_role;


--
-- Name: FUNCTION st_fromflatgeobuftotable(text, text, bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_fromflatgeobuftotable(text, text, bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_fromflatgeobuftotable(text, text, bytea) TO anon;
GRANT ALL ON FUNCTION public.st_fromflatgeobuftotable(text, text, bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_fromflatgeobuftotable(text, text, bytea) TO service_role;


--
-- Name: FUNCTION st_generatepoints(area public.geometry, npoints integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_generatepoints(area public.geometry, npoints integer) TO postgres;
GRANT ALL ON FUNCTION public.st_generatepoints(area public.geometry, npoints integer) TO anon;
GRANT ALL ON FUNCTION public.st_generatepoints(area public.geometry, npoints integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_generatepoints(area public.geometry, npoints integer) TO service_role;


--
-- Name: FUNCTION st_generatepoints(area public.geometry, npoints integer, seed integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_generatepoints(area public.geometry, npoints integer, seed integer) TO postgres;
GRANT ALL ON FUNCTION public.st_generatepoints(area public.geometry, npoints integer, seed integer) TO anon;
GRANT ALL ON FUNCTION public.st_generatepoints(area public.geometry, npoints integer, seed integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_generatepoints(area public.geometry, npoints integer, seed integer) TO service_role;


--
-- Name: FUNCTION st_geogfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geogfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_geogfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_geogfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_geogfromtext(text) TO service_role;


--
-- Name: FUNCTION st_geogfromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geogfromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_geogfromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_geogfromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_geogfromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_geographyfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geographyfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_geographyfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_geographyfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_geographyfromtext(text) TO service_role;


--
-- Name: FUNCTION st_geohash(geog public.geography, maxchars integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geohash(geog public.geography, maxchars integer) TO postgres;
GRANT ALL ON FUNCTION public.st_geohash(geog public.geography, maxchars integer) TO anon;
GRANT ALL ON FUNCTION public.st_geohash(geog public.geography, maxchars integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_geohash(geog public.geography, maxchars integer) TO service_role;


--
-- Name: FUNCTION st_geohash(geom public.geometry, maxchars integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geohash(geom public.geometry, maxchars integer) TO postgres;
GRANT ALL ON FUNCTION public.st_geohash(geom public.geometry, maxchars integer) TO anon;
GRANT ALL ON FUNCTION public.st_geohash(geom public.geometry, maxchars integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_geohash(geom public.geometry, maxchars integer) TO service_role;


--
-- Name: FUNCTION st_geomcollfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomcollfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_geomcollfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_geomcollfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomcollfromtext(text) TO service_role;


--
-- Name: FUNCTION st_geomcollfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomcollfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_geomcollfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_geomcollfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomcollfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_geomcollfromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomcollfromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_geomcollfromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_geomcollfromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomcollfromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_geomcollfromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomcollfromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_geomcollfromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_geomcollfromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomcollfromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_geometricmedian(g public.geometry, tolerance double precision, max_iter integer, fail_if_not_converged boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geometricmedian(g public.geometry, tolerance double precision, max_iter integer, fail_if_not_converged boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_geometricmedian(g public.geometry, tolerance double precision, max_iter integer, fail_if_not_converged boolean) TO anon;
GRANT ALL ON FUNCTION public.st_geometricmedian(g public.geometry, tolerance double precision, max_iter integer, fail_if_not_converged boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_geometricmedian(g public.geometry, tolerance double precision, max_iter integer, fail_if_not_converged boolean) TO service_role;


--
-- Name: FUNCTION st_geometryfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geometryfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_geometryfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_geometryfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_geometryfromtext(text) TO service_role;


--
-- Name: FUNCTION st_geometryfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geometryfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_geometryfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_geometryfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_geometryfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_geometryn(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geometryn(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_geometryn(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_geometryn(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_geometryn(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_geometrytype(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geometrytype(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_geometrytype(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_geometrytype(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_geometrytype(public.geometry) TO service_role;


--
-- Name: FUNCTION st_geomfromewkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromewkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromewkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromewkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromewkb(bytea) TO service_role;


--
-- Name: FUNCTION st_geomfromewkt(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromewkt(text) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromewkt(text) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromewkt(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromewkt(text) TO service_role;


--
-- Name: FUNCTION st_geomfromgeohash(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromgeohash(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromgeohash(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromgeohash(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromgeohash(text, integer) TO service_role;


--
-- Name: FUNCTION st_geomfromgeojson(json); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromgeojson(json) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromgeojson(json) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromgeojson(json) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromgeojson(json) TO service_role;


--
-- Name: FUNCTION st_geomfromgeojson(jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromgeojson(jsonb) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromgeojson(jsonb) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromgeojson(jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromgeojson(jsonb) TO service_role;


--
-- Name: FUNCTION st_geomfromgeojson(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromgeojson(text) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromgeojson(text) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromgeojson(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromgeojson(text) TO service_role;


--
-- Name: FUNCTION st_geomfromgml(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromgml(text) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromgml(text) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromgml(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromgml(text) TO service_role;


--
-- Name: FUNCTION st_geomfromgml(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromgml(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromgml(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromgml(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromgml(text, integer) TO service_role;


--
-- Name: FUNCTION st_geomfromkml(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromkml(text) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromkml(text) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromkml(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromkml(text) TO service_role;


--
-- Name: FUNCTION st_geomfrommarc21(marc21xml text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfrommarc21(marc21xml text) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfrommarc21(marc21xml text) TO anon;
GRANT ALL ON FUNCTION public.st_geomfrommarc21(marc21xml text) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfrommarc21(marc21xml text) TO service_role;


--
-- Name: FUNCTION st_geomfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromtext(text) TO service_role;


--
-- Name: FUNCTION st_geomfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_geomfromtwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromtwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromtwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromtwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromtwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_geomfromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_geomfromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_geomfromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_geomfromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_geomfromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_geomfromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_gmltosql(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_gmltosql(text) TO postgres;
GRANT ALL ON FUNCTION public.st_gmltosql(text) TO anon;
GRANT ALL ON FUNCTION public.st_gmltosql(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_gmltosql(text) TO service_role;


--
-- Name: FUNCTION st_gmltosql(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_gmltosql(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_gmltosql(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_gmltosql(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_gmltosql(text, integer) TO service_role;


--
-- Name: FUNCTION st_hasarc(geometry public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_hasarc(geometry public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_hasarc(geometry public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_hasarc(geometry public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_hasarc(geometry public.geometry) TO service_role;


--
-- Name: FUNCTION st_hausdorffdistance(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_hausdorffdistance(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_hausdorffdistance(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_hausdorffdistance(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_hausdorffdistance(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_hausdorffdistance(geom1 public.geometry, geom2 public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_hausdorffdistance(geom1 public.geometry, geom2 public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_hausdorffdistance(geom1 public.geometry, geom2 public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_hausdorffdistance(geom1 public.geometry, geom2 public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_hausdorffdistance(geom1 public.geometry, geom2 public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_hexagon(size double precision, cell_i integer, cell_j integer, origin public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_hexagon(size double precision, cell_i integer, cell_j integer, origin public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_hexagon(size double precision, cell_i integer, cell_j integer, origin public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_hexagon(size double precision, cell_i integer, cell_j integer, origin public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_hexagon(size double precision, cell_i integer, cell_j integer, origin public.geometry) TO service_role;


--
-- Name: FUNCTION st_hexagongrid(size double precision, bounds public.geometry, OUT geom public.geometry, OUT i integer, OUT j integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_hexagongrid(size double precision, bounds public.geometry, OUT geom public.geometry, OUT i integer, OUT j integer) TO postgres;
GRANT ALL ON FUNCTION public.st_hexagongrid(size double precision, bounds public.geometry, OUT geom public.geometry, OUT i integer, OUT j integer) TO anon;
GRANT ALL ON FUNCTION public.st_hexagongrid(size double precision, bounds public.geometry, OUT geom public.geometry, OUT i integer, OUT j integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_hexagongrid(size double precision, bounds public.geometry, OUT geom public.geometry, OUT i integer, OUT j integer) TO service_role;


--
-- Name: FUNCTION st_interiorringn(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_interiorringn(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_interiorringn(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_interiorringn(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_interiorringn(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_interpolatepoint(line public.geometry, point public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_interpolatepoint(line public.geometry, point public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_interpolatepoint(line public.geometry, point public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_interpolatepoint(line public.geometry, point public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_interpolatepoint(line public.geometry, point public.geometry) TO service_role;


--
-- Name: FUNCTION st_intersection(text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_intersection(text, text) TO postgres;
GRANT ALL ON FUNCTION public.st_intersection(text, text) TO anon;
GRANT ALL ON FUNCTION public.st_intersection(text, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_intersection(text, text) TO service_role;


--
-- Name: FUNCTION st_intersection(public.geography, public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_intersection(public.geography, public.geography) TO postgres;
GRANT ALL ON FUNCTION public.st_intersection(public.geography, public.geography) TO anon;
GRANT ALL ON FUNCTION public.st_intersection(public.geography, public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.st_intersection(public.geography, public.geography) TO service_role;


--
-- Name: FUNCTION st_intersection(geom1 public.geometry, geom2 public.geometry, gridsize double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_intersection(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_intersection(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO anon;
GRANT ALL ON FUNCTION public.st_intersection(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_intersection(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO service_role;


--
-- Name: FUNCTION st_intersects(text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_intersects(text, text) TO postgres;
GRANT ALL ON FUNCTION public.st_intersects(text, text) TO anon;
GRANT ALL ON FUNCTION public.st_intersects(text, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_intersects(text, text) TO service_role;


--
-- Name: FUNCTION st_intersects(geog1 public.geography, geog2 public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_intersects(geog1 public.geography, geog2 public.geography) TO postgres;
GRANT ALL ON FUNCTION public.st_intersects(geog1 public.geography, geog2 public.geography) TO anon;
GRANT ALL ON FUNCTION public.st_intersects(geog1 public.geography, geog2 public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.st_intersects(geog1 public.geography, geog2 public.geography) TO service_role;


--
-- Name: FUNCTION st_intersects(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_intersects(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_intersects(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_intersects(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_intersects(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_isclosed(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_isclosed(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_isclosed(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_isclosed(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_isclosed(public.geometry) TO service_role;


--
-- Name: FUNCTION st_iscollection(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_iscollection(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_iscollection(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_iscollection(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_iscollection(public.geometry) TO service_role;


--
-- Name: FUNCTION st_isempty(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_isempty(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_isempty(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_isempty(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_isempty(public.geometry) TO service_role;


--
-- Name: FUNCTION st_ispolygonccw(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_ispolygonccw(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_ispolygonccw(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_ispolygonccw(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_ispolygonccw(public.geometry) TO service_role;


--
-- Name: FUNCTION st_ispolygoncw(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_ispolygoncw(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_ispolygoncw(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_ispolygoncw(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_ispolygoncw(public.geometry) TO service_role;


--
-- Name: FUNCTION st_isring(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_isring(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_isring(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_isring(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_isring(public.geometry) TO service_role;


--
-- Name: FUNCTION st_issimple(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_issimple(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_issimple(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_issimple(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_issimple(public.geometry) TO service_role;


--
-- Name: FUNCTION st_isvalid(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_isvalid(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_isvalid(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_isvalid(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_isvalid(public.geometry) TO service_role;


--
-- Name: FUNCTION st_isvalid(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_isvalid(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_isvalid(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_isvalid(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_isvalid(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_isvaliddetail(geom public.geometry, flags integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_isvaliddetail(geom public.geometry, flags integer) TO postgres;
GRANT ALL ON FUNCTION public.st_isvaliddetail(geom public.geometry, flags integer) TO anon;
GRANT ALL ON FUNCTION public.st_isvaliddetail(geom public.geometry, flags integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_isvaliddetail(geom public.geometry, flags integer) TO service_role;


--
-- Name: FUNCTION st_isvalidreason(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_isvalidreason(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_isvalidreason(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_isvalidreason(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_isvalidreason(public.geometry) TO service_role;


--
-- Name: FUNCTION st_isvalidreason(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_isvalidreason(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_isvalidreason(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_isvalidreason(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_isvalidreason(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_isvalidtrajectory(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_isvalidtrajectory(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_isvalidtrajectory(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_isvalidtrajectory(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_isvalidtrajectory(public.geometry) TO service_role;


--
-- Name: FUNCTION st_length(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_length(text) TO postgres;
GRANT ALL ON FUNCTION public.st_length(text) TO anon;
GRANT ALL ON FUNCTION public.st_length(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_length(text) TO service_role;


--
-- Name: FUNCTION st_length(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_length(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_length(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_length(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_length(public.geometry) TO service_role;


--
-- Name: FUNCTION st_length(geog public.geography, use_spheroid boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_length(geog public.geography, use_spheroid boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_length(geog public.geography, use_spheroid boolean) TO anon;
GRANT ALL ON FUNCTION public.st_length(geog public.geography, use_spheroid boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_length(geog public.geography, use_spheroid boolean) TO service_role;


--
-- Name: FUNCTION st_length2d(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_length2d(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_length2d(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_length2d(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_length2d(public.geometry) TO service_role;


--
-- Name: FUNCTION st_length2dspheroid(public.geometry, public.spheroid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_length2dspheroid(public.geometry, public.spheroid) TO postgres;
GRANT ALL ON FUNCTION public.st_length2dspheroid(public.geometry, public.spheroid) TO anon;
GRANT ALL ON FUNCTION public.st_length2dspheroid(public.geometry, public.spheroid) TO authenticated;
GRANT ALL ON FUNCTION public.st_length2dspheroid(public.geometry, public.spheroid) TO service_role;


--
-- Name: FUNCTION st_lengthspheroid(public.geometry, public.spheroid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_lengthspheroid(public.geometry, public.spheroid) TO postgres;
GRANT ALL ON FUNCTION public.st_lengthspheroid(public.geometry, public.spheroid) TO anon;
GRANT ALL ON FUNCTION public.st_lengthspheroid(public.geometry, public.spheroid) TO authenticated;
GRANT ALL ON FUNCTION public.st_lengthspheroid(public.geometry, public.spheroid) TO service_role;


--
-- Name: FUNCTION st_letters(letters text, font json); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_letters(letters text, font json) TO postgres;
GRANT ALL ON FUNCTION public.st_letters(letters text, font json) TO anon;
GRANT ALL ON FUNCTION public.st_letters(letters text, font json) TO authenticated;
GRANT ALL ON FUNCTION public.st_letters(letters text, font json) TO service_role;


--
-- Name: FUNCTION st_linecrossingdirection(line1 public.geometry, line2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linecrossingdirection(line1 public.geometry, line2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_linecrossingdirection(line1 public.geometry, line2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_linecrossingdirection(line1 public.geometry, line2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_linecrossingdirection(line1 public.geometry, line2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_linefromencodedpolyline(txtin text, nprecision integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linefromencodedpolyline(txtin text, nprecision integer) TO postgres;
GRANT ALL ON FUNCTION public.st_linefromencodedpolyline(txtin text, nprecision integer) TO anon;
GRANT ALL ON FUNCTION public.st_linefromencodedpolyline(txtin text, nprecision integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_linefromencodedpolyline(txtin text, nprecision integer) TO service_role;


--
-- Name: FUNCTION st_linefrommultipoint(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linefrommultipoint(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_linefrommultipoint(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_linefrommultipoint(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_linefrommultipoint(public.geometry) TO service_role;


--
-- Name: FUNCTION st_linefromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linefromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_linefromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_linefromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_linefromtext(text) TO service_role;


--
-- Name: FUNCTION st_linefromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linefromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_linefromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_linefromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_linefromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_linefromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linefromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_linefromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_linefromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_linefromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_linefromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linefromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_linefromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_linefromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_linefromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_lineinterpolatepoint(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_lineinterpolatepoint(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_lineinterpolatepoint(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_lineinterpolatepoint(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_lineinterpolatepoint(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_lineinterpolatepoints(public.geometry, double precision, repeat boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_lineinterpolatepoints(public.geometry, double precision, repeat boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_lineinterpolatepoints(public.geometry, double precision, repeat boolean) TO anon;
GRANT ALL ON FUNCTION public.st_lineinterpolatepoints(public.geometry, double precision, repeat boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_lineinterpolatepoints(public.geometry, double precision, repeat boolean) TO service_role;


--
-- Name: FUNCTION st_linelocatepoint(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linelocatepoint(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_linelocatepoint(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_linelocatepoint(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_linelocatepoint(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_linemerge(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linemerge(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_linemerge(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_linemerge(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_linemerge(public.geometry) TO service_role;


--
-- Name: FUNCTION st_linemerge(public.geometry, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linemerge(public.geometry, boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_linemerge(public.geometry, boolean) TO anon;
GRANT ALL ON FUNCTION public.st_linemerge(public.geometry, boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_linemerge(public.geometry, boolean) TO service_role;


--
-- Name: FUNCTION st_linestringfromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linestringfromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_linestringfromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_linestringfromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_linestringfromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_linestringfromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linestringfromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_linestringfromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_linestringfromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_linestringfromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_linesubstring(public.geometry, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linesubstring(public.geometry, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_linesubstring(public.geometry, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_linesubstring(public.geometry, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_linesubstring(public.geometry, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_linetocurve(geometry public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_linetocurve(geometry public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_linetocurve(geometry public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_linetocurve(geometry public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_linetocurve(geometry public.geometry) TO service_role;


--
-- Name: FUNCTION st_locatealong(geometry public.geometry, measure double precision, leftrightoffset double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_locatealong(geometry public.geometry, measure double precision, leftrightoffset double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_locatealong(geometry public.geometry, measure double precision, leftrightoffset double precision) TO anon;
GRANT ALL ON FUNCTION public.st_locatealong(geometry public.geometry, measure double precision, leftrightoffset double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_locatealong(geometry public.geometry, measure double precision, leftrightoffset double precision) TO service_role;


--
-- Name: FUNCTION st_locatebetween(geometry public.geometry, frommeasure double precision, tomeasure double precision, leftrightoffset double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_locatebetween(geometry public.geometry, frommeasure double precision, tomeasure double precision, leftrightoffset double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_locatebetween(geometry public.geometry, frommeasure double precision, tomeasure double precision, leftrightoffset double precision) TO anon;
GRANT ALL ON FUNCTION public.st_locatebetween(geometry public.geometry, frommeasure double precision, tomeasure double precision, leftrightoffset double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_locatebetween(geometry public.geometry, frommeasure double precision, tomeasure double precision, leftrightoffset double precision) TO service_role;


--
-- Name: FUNCTION st_locatebetweenelevations(geometry public.geometry, fromelevation double precision, toelevation double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_locatebetweenelevations(geometry public.geometry, fromelevation double precision, toelevation double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_locatebetweenelevations(geometry public.geometry, fromelevation double precision, toelevation double precision) TO anon;
GRANT ALL ON FUNCTION public.st_locatebetweenelevations(geometry public.geometry, fromelevation double precision, toelevation double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_locatebetweenelevations(geometry public.geometry, fromelevation double precision, toelevation double precision) TO service_role;


--
-- Name: FUNCTION st_longestline(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_longestline(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_longestline(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_longestline(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_longestline(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_m(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_m(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_m(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_m(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_m(public.geometry) TO service_role;


--
-- Name: FUNCTION st_makebox2d(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makebox2d(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_makebox2d(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_makebox2d(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_makebox2d(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_makeenvelope(double precision, double precision, double precision, double precision, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makeenvelope(double precision, double precision, double precision, double precision, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_makeenvelope(double precision, double precision, double precision, double precision, integer) TO anon;
GRANT ALL ON FUNCTION public.st_makeenvelope(double precision, double precision, double precision, double precision, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_makeenvelope(double precision, double precision, double precision, double precision, integer) TO service_role;


--
-- Name: FUNCTION st_makeline(public.geometry[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makeline(public.geometry[]) TO postgres;
GRANT ALL ON FUNCTION public.st_makeline(public.geometry[]) TO anon;
GRANT ALL ON FUNCTION public.st_makeline(public.geometry[]) TO authenticated;
GRANT ALL ON FUNCTION public.st_makeline(public.geometry[]) TO service_role;


--
-- Name: FUNCTION st_makeline(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makeline(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_makeline(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_makeline(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_makeline(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_makepoint(double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_makepoint(double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_makepoint(double precision, double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_makepoint(double precision, double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_makepointm(double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makepointm(double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_makepointm(double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_makepointm(double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_makepointm(double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_makepolygon(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makepolygon(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_makepolygon(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_makepolygon(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_makepolygon(public.geometry) TO service_role;


--
-- Name: FUNCTION st_makepolygon(public.geometry, public.geometry[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makepolygon(public.geometry, public.geometry[]) TO postgres;
GRANT ALL ON FUNCTION public.st_makepolygon(public.geometry, public.geometry[]) TO anon;
GRANT ALL ON FUNCTION public.st_makepolygon(public.geometry, public.geometry[]) TO authenticated;
GRANT ALL ON FUNCTION public.st_makepolygon(public.geometry, public.geometry[]) TO service_role;


--
-- Name: FUNCTION st_makevalid(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makevalid(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_makevalid(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_makevalid(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_makevalid(public.geometry) TO service_role;


--
-- Name: FUNCTION st_makevalid(geom public.geometry, params text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makevalid(geom public.geometry, params text) TO postgres;
GRANT ALL ON FUNCTION public.st_makevalid(geom public.geometry, params text) TO anon;
GRANT ALL ON FUNCTION public.st_makevalid(geom public.geometry, params text) TO authenticated;
GRANT ALL ON FUNCTION public.st_makevalid(geom public.geometry, params text) TO service_role;


--
-- Name: FUNCTION st_maxdistance(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_maxdistance(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_maxdistance(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_maxdistance(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_maxdistance(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_maximuminscribedcircle(public.geometry, OUT center public.geometry, OUT nearest public.geometry, OUT radius double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_maximuminscribedcircle(public.geometry, OUT center public.geometry, OUT nearest public.geometry, OUT radius double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_maximuminscribedcircle(public.geometry, OUT center public.geometry, OUT nearest public.geometry, OUT radius double precision) TO anon;
GRANT ALL ON FUNCTION public.st_maximuminscribedcircle(public.geometry, OUT center public.geometry, OUT nearest public.geometry, OUT radius double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_maximuminscribedcircle(public.geometry, OUT center public.geometry, OUT nearest public.geometry, OUT radius double precision) TO service_role;


--
-- Name: FUNCTION st_memsize(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_memsize(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_memsize(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_memsize(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_memsize(public.geometry) TO service_role;


--
-- Name: FUNCTION st_minimumboundingcircle(inputgeom public.geometry, segs_per_quarter integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_minimumboundingcircle(inputgeom public.geometry, segs_per_quarter integer) TO postgres;
GRANT ALL ON FUNCTION public.st_minimumboundingcircle(inputgeom public.geometry, segs_per_quarter integer) TO anon;
GRANT ALL ON FUNCTION public.st_minimumboundingcircle(inputgeom public.geometry, segs_per_quarter integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_minimumboundingcircle(inputgeom public.geometry, segs_per_quarter integer) TO service_role;


--
-- Name: FUNCTION st_minimumboundingradius(public.geometry, OUT center public.geometry, OUT radius double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_minimumboundingradius(public.geometry, OUT center public.geometry, OUT radius double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_minimumboundingradius(public.geometry, OUT center public.geometry, OUT radius double precision) TO anon;
GRANT ALL ON FUNCTION public.st_minimumboundingradius(public.geometry, OUT center public.geometry, OUT radius double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_minimumboundingradius(public.geometry, OUT center public.geometry, OUT radius double precision) TO service_role;


--
-- Name: FUNCTION st_minimumclearance(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_minimumclearance(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_minimumclearance(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_minimumclearance(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_minimumclearance(public.geometry) TO service_role;


--
-- Name: FUNCTION st_minimumclearanceline(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_minimumclearanceline(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_minimumclearanceline(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_minimumclearanceline(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_minimumclearanceline(public.geometry) TO service_role;


--
-- Name: FUNCTION st_mlinefromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mlinefromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_mlinefromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_mlinefromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_mlinefromtext(text) TO service_role;


--
-- Name: FUNCTION st_mlinefromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mlinefromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_mlinefromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_mlinefromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_mlinefromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_mlinefromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mlinefromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_mlinefromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_mlinefromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_mlinefromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_mlinefromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mlinefromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_mlinefromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_mlinefromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_mlinefromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_mpointfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mpointfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_mpointfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_mpointfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_mpointfromtext(text) TO service_role;


--
-- Name: FUNCTION st_mpointfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mpointfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_mpointfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_mpointfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_mpointfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_mpointfromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mpointfromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_mpointfromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_mpointfromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_mpointfromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_mpointfromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mpointfromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_mpointfromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_mpointfromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_mpointfromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_mpolyfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mpolyfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_mpolyfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_mpolyfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_mpolyfromtext(text) TO service_role;


--
-- Name: FUNCTION st_mpolyfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mpolyfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_mpolyfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_mpolyfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_mpolyfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_mpolyfromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mpolyfromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_mpolyfromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_mpolyfromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_mpolyfromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_mpolyfromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_mpolyfromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_mpolyfromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_mpolyfromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_mpolyfromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_multi(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_multi(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_multi(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_multi(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_multi(public.geometry) TO service_role;


--
-- Name: FUNCTION st_multilinefromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_multilinefromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_multilinefromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_multilinefromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_multilinefromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_multilinestringfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_multilinestringfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_multilinestringfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_multilinestringfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_multilinestringfromtext(text) TO service_role;


--
-- Name: FUNCTION st_multilinestringfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_multilinestringfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_multilinestringfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_multilinestringfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_multilinestringfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_multipointfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_multipointfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_multipointfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_multipointfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_multipointfromtext(text) TO service_role;


--
-- Name: FUNCTION st_multipointfromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_multipointfromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_multipointfromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_multipointfromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_multipointfromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_multipointfromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_multipointfromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_multipointfromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_multipointfromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_multipointfromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_multipolyfromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_multipolyfromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_multipolyfromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_multipolyfromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_multipolyfromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_multipolyfromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_multipolyfromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_multipolyfromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_multipolyfromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_multipolyfromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_multipolygonfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_multipolygonfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_multipolygonfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_multipolygonfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_multipolygonfromtext(text) TO service_role;


--
-- Name: FUNCTION st_multipolygonfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_multipolygonfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_multipolygonfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_multipolygonfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_multipolygonfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_ndims(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_ndims(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_ndims(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_ndims(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_ndims(public.geometry) TO service_role;


--
-- Name: FUNCTION st_node(g public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_node(g public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_node(g public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_node(g public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_node(g public.geometry) TO service_role;


--
-- Name: FUNCTION st_normalize(geom public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_normalize(geom public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_normalize(geom public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_normalize(geom public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_normalize(geom public.geometry) TO service_role;


--
-- Name: FUNCTION st_npoints(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_npoints(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_npoints(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_npoints(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_npoints(public.geometry) TO service_role;


--
-- Name: FUNCTION st_nrings(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_nrings(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_nrings(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_nrings(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_nrings(public.geometry) TO service_role;


--
-- Name: FUNCTION st_numgeometries(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_numgeometries(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_numgeometries(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_numgeometries(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_numgeometries(public.geometry) TO service_role;


--
-- Name: FUNCTION st_numinteriorring(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_numinteriorring(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_numinteriorring(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_numinteriorring(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_numinteriorring(public.geometry) TO service_role;


--
-- Name: FUNCTION st_numinteriorrings(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_numinteriorrings(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_numinteriorrings(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_numinteriorrings(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_numinteriorrings(public.geometry) TO service_role;


--
-- Name: FUNCTION st_numpatches(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_numpatches(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_numpatches(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_numpatches(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_numpatches(public.geometry) TO service_role;


--
-- Name: FUNCTION st_numpoints(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_numpoints(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_numpoints(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_numpoints(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_numpoints(public.geometry) TO service_role;


--
-- Name: FUNCTION st_offsetcurve(line public.geometry, distance double precision, params text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_offsetcurve(line public.geometry, distance double precision, params text) TO postgres;
GRANT ALL ON FUNCTION public.st_offsetcurve(line public.geometry, distance double precision, params text) TO anon;
GRANT ALL ON FUNCTION public.st_offsetcurve(line public.geometry, distance double precision, params text) TO authenticated;
GRANT ALL ON FUNCTION public.st_offsetcurve(line public.geometry, distance double precision, params text) TO service_role;


--
-- Name: FUNCTION st_orderingequals(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_orderingequals(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_orderingequals(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_orderingequals(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_orderingequals(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_orientedenvelope(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_orientedenvelope(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_orientedenvelope(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_orientedenvelope(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_orientedenvelope(public.geometry) TO service_role;


--
-- Name: FUNCTION st_overlaps(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_overlaps(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_overlaps(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_overlaps(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_overlaps(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_patchn(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_patchn(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_patchn(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_patchn(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_patchn(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_perimeter(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_perimeter(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_perimeter(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_perimeter(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_perimeter(public.geometry) TO service_role;


--
-- Name: FUNCTION st_perimeter(geog public.geography, use_spheroid boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_perimeter(geog public.geography, use_spheroid boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_perimeter(geog public.geography, use_spheroid boolean) TO anon;
GRANT ALL ON FUNCTION public.st_perimeter(geog public.geography, use_spheroid boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_perimeter(geog public.geography, use_spheroid boolean) TO service_role;


--
-- Name: FUNCTION st_perimeter2d(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_perimeter2d(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_perimeter2d(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_perimeter2d(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_perimeter2d(public.geometry) TO service_role;


--
-- Name: FUNCTION st_point(double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_point(double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_point(double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_point(double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_point(double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_point(double precision, double precision, srid integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_point(double precision, double precision, srid integer) TO postgres;
GRANT ALL ON FUNCTION public.st_point(double precision, double precision, srid integer) TO anon;
GRANT ALL ON FUNCTION public.st_point(double precision, double precision, srid integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_point(double precision, double precision, srid integer) TO service_role;


--
-- Name: FUNCTION st_pointfromgeohash(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_pointfromgeohash(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_pointfromgeohash(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_pointfromgeohash(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_pointfromgeohash(text, integer) TO service_role;


--
-- Name: FUNCTION st_pointfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_pointfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_pointfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_pointfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_pointfromtext(text) TO service_role;


--
-- Name: FUNCTION st_pointfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_pointfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_pointfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_pointfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_pointfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_pointfromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_pointfromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_pointfromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_pointfromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_pointfromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_pointfromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_pointfromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_pointfromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_pointfromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_pointfromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_pointinsidecircle(public.geometry, double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_pointinsidecircle(public.geometry, double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_pointinsidecircle(public.geometry, double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_pointinsidecircle(public.geometry, double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_pointinsidecircle(public.geometry, double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_pointm(xcoordinate double precision, ycoordinate double precision, mcoordinate double precision, srid integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_pointm(xcoordinate double precision, ycoordinate double precision, mcoordinate double precision, srid integer) TO postgres;
GRANT ALL ON FUNCTION public.st_pointm(xcoordinate double precision, ycoordinate double precision, mcoordinate double precision, srid integer) TO anon;
GRANT ALL ON FUNCTION public.st_pointm(xcoordinate double precision, ycoordinate double precision, mcoordinate double precision, srid integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_pointm(xcoordinate double precision, ycoordinate double precision, mcoordinate double precision, srid integer) TO service_role;


--
-- Name: FUNCTION st_pointn(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_pointn(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_pointn(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_pointn(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_pointn(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_pointonsurface(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_pointonsurface(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_pointonsurface(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_pointonsurface(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_pointonsurface(public.geometry) TO service_role;


--
-- Name: FUNCTION st_points(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_points(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_points(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_points(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_points(public.geometry) TO service_role;


--
-- Name: FUNCTION st_pointz(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, srid integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_pointz(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, srid integer) TO postgres;
GRANT ALL ON FUNCTION public.st_pointz(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, srid integer) TO anon;
GRANT ALL ON FUNCTION public.st_pointz(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, srid integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_pointz(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, srid integer) TO service_role;


--
-- Name: FUNCTION st_pointzm(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, mcoordinate double precision, srid integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_pointzm(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, mcoordinate double precision, srid integer) TO postgres;
GRANT ALL ON FUNCTION public.st_pointzm(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, mcoordinate double precision, srid integer) TO anon;
GRANT ALL ON FUNCTION public.st_pointzm(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, mcoordinate double precision, srid integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_pointzm(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, mcoordinate double precision, srid integer) TO service_role;


--
-- Name: FUNCTION st_polyfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_polyfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_polyfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_polyfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_polyfromtext(text) TO service_role;


--
-- Name: FUNCTION st_polyfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_polyfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_polyfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_polyfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_polyfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_polyfromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_polyfromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_polyfromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_polyfromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_polyfromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_polyfromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_polyfromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_polyfromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_polyfromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_polyfromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_polygon(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_polygon(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_polygon(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_polygon(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_polygon(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_polygonfromtext(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_polygonfromtext(text) TO postgres;
GRANT ALL ON FUNCTION public.st_polygonfromtext(text) TO anon;
GRANT ALL ON FUNCTION public.st_polygonfromtext(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_polygonfromtext(text) TO service_role;


--
-- Name: FUNCTION st_polygonfromtext(text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_polygonfromtext(text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_polygonfromtext(text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_polygonfromtext(text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_polygonfromtext(text, integer) TO service_role;


--
-- Name: FUNCTION st_polygonfromwkb(bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_polygonfromwkb(bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_polygonfromwkb(bytea) TO anon;
GRANT ALL ON FUNCTION public.st_polygonfromwkb(bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_polygonfromwkb(bytea) TO service_role;


--
-- Name: FUNCTION st_polygonfromwkb(bytea, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_polygonfromwkb(bytea, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_polygonfromwkb(bytea, integer) TO anon;
GRANT ALL ON FUNCTION public.st_polygonfromwkb(bytea, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_polygonfromwkb(bytea, integer) TO service_role;


--
-- Name: FUNCTION st_polygonize(public.geometry[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_polygonize(public.geometry[]) TO postgres;
GRANT ALL ON FUNCTION public.st_polygonize(public.geometry[]) TO anon;
GRANT ALL ON FUNCTION public.st_polygonize(public.geometry[]) TO authenticated;
GRANT ALL ON FUNCTION public.st_polygonize(public.geometry[]) TO service_role;


--
-- Name: FUNCTION st_project(geog public.geography, distance double precision, azimuth double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_project(geog public.geography, distance double precision, azimuth double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_project(geog public.geography, distance double precision, azimuth double precision) TO anon;
GRANT ALL ON FUNCTION public.st_project(geog public.geography, distance double precision, azimuth double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_project(geog public.geography, distance double precision, azimuth double precision) TO service_role;


--
-- Name: FUNCTION st_quantizecoordinates(g public.geometry, prec_x integer, prec_y integer, prec_z integer, prec_m integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_quantizecoordinates(g public.geometry, prec_x integer, prec_y integer, prec_z integer, prec_m integer) TO postgres;
GRANT ALL ON FUNCTION public.st_quantizecoordinates(g public.geometry, prec_x integer, prec_y integer, prec_z integer, prec_m integer) TO anon;
GRANT ALL ON FUNCTION public.st_quantizecoordinates(g public.geometry, prec_x integer, prec_y integer, prec_z integer, prec_m integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_quantizecoordinates(g public.geometry, prec_x integer, prec_y integer, prec_z integer, prec_m integer) TO service_role;


--
-- Name: FUNCTION st_reduceprecision(geom public.geometry, gridsize double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_reduceprecision(geom public.geometry, gridsize double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_reduceprecision(geom public.geometry, gridsize double precision) TO anon;
GRANT ALL ON FUNCTION public.st_reduceprecision(geom public.geometry, gridsize double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_reduceprecision(geom public.geometry, gridsize double precision) TO service_role;


--
-- Name: FUNCTION st_relate(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_relate(geom1 public.geometry, geom2 public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_relate(geom1 public.geometry, geom2 public.geometry, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry, text) TO postgres;
GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry, text) TO anon;
GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_relate(geom1 public.geometry, geom2 public.geometry, text) TO service_role;


--
-- Name: FUNCTION st_relatematch(text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_relatematch(text, text) TO postgres;
GRANT ALL ON FUNCTION public.st_relatematch(text, text) TO anon;
GRANT ALL ON FUNCTION public.st_relatematch(text, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_relatematch(text, text) TO service_role;


--
-- Name: FUNCTION st_removepoint(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_removepoint(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_removepoint(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_removepoint(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_removepoint(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_removerepeatedpoints(geom public.geometry, tolerance double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_removerepeatedpoints(geom public.geometry, tolerance double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_removerepeatedpoints(geom public.geometry, tolerance double precision) TO anon;
GRANT ALL ON FUNCTION public.st_removerepeatedpoints(geom public.geometry, tolerance double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_removerepeatedpoints(geom public.geometry, tolerance double precision) TO service_role;


--
-- Name: FUNCTION st_reverse(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_reverse(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_reverse(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_reverse(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_reverse(public.geometry) TO service_role;


--
-- Name: FUNCTION st_rotate(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_rotate(public.geometry, double precision, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision, public.geometry) TO service_role;


--
-- Name: FUNCTION st_rotate(public.geometry, double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_rotate(public.geometry, double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_rotatex(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_rotatex(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_rotatex(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_rotatex(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_rotatex(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_rotatey(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_rotatey(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_rotatey(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_rotatey(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_rotatey(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_rotatez(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_rotatez(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_rotatez(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_rotatez(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_rotatez(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_scale(public.geometry, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_scale(public.geometry, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, public.geometry) TO service_role;


--
-- Name: FUNCTION st_scale(public.geometry, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_scale(public.geometry, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_scale(public.geometry, public.geometry, origin public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_scale(public.geometry, public.geometry, origin public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, public.geometry, origin public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, public.geometry, origin public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, public.geometry, origin public.geometry) TO service_role;


--
-- Name: FUNCTION st_scale(public.geometry, double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_scale(public.geometry, double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_scale(public.geometry, double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_scroll(public.geometry, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_scroll(public.geometry, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_scroll(public.geometry, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_scroll(public.geometry, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_scroll(public.geometry, public.geometry) TO service_role;


--
-- Name: FUNCTION st_segmentize(geog public.geography, max_segment_length double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_segmentize(geog public.geography, max_segment_length double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_segmentize(geog public.geography, max_segment_length double precision) TO anon;
GRANT ALL ON FUNCTION public.st_segmentize(geog public.geography, max_segment_length double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_segmentize(geog public.geography, max_segment_length double precision) TO service_role;


--
-- Name: FUNCTION st_segmentize(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_segmentize(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_segmentize(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_segmentize(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_segmentize(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_seteffectivearea(public.geometry, double precision, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_seteffectivearea(public.geometry, double precision, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_seteffectivearea(public.geometry, double precision, integer) TO anon;
GRANT ALL ON FUNCTION public.st_seteffectivearea(public.geometry, double precision, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_seteffectivearea(public.geometry, double precision, integer) TO service_role;


--
-- Name: FUNCTION st_setpoint(public.geometry, integer, public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_setpoint(public.geometry, integer, public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_setpoint(public.geometry, integer, public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_setpoint(public.geometry, integer, public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_setpoint(public.geometry, integer, public.geometry) TO service_role;


--
-- Name: FUNCTION st_setsrid(geog public.geography, srid integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_setsrid(geog public.geography, srid integer) TO postgres;
GRANT ALL ON FUNCTION public.st_setsrid(geog public.geography, srid integer) TO anon;
GRANT ALL ON FUNCTION public.st_setsrid(geog public.geography, srid integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_setsrid(geog public.geography, srid integer) TO service_role;


--
-- Name: FUNCTION st_setsrid(geom public.geometry, srid integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_setsrid(geom public.geometry, srid integer) TO postgres;
GRANT ALL ON FUNCTION public.st_setsrid(geom public.geometry, srid integer) TO anon;
GRANT ALL ON FUNCTION public.st_setsrid(geom public.geometry, srid integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_setsrid(geom public.geometry, srid integer) TO service_role;


--
-- Name: FUNCTION st_sharedpaths(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_sharedpaths(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_sharedpaths(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_sharedpaths(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_sharedpaths(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_shiftlongitude(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_shiftlongitude(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_shiftlongitude(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_shiftlongitude(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_shiftlongitude(public.geometry) TO service_role;


--
-- Name: FUNCTION st_shortestline(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_shortestline(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_shortestline(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_shortestline(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_shortestline(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_simplify(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_simplify(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_simplify(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_simplify(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_simplify(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_simplify(public.geometry, double precision, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_simplify(public.geometry, double precision, boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_simplify(public.geometry, double precision, boolean) TO anon;
GRANT ALL ON FUNCTION public.st_simplify(public.geometry, double precision, boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_simplify(public.geometry, double precision, boolean) TO service_role;


--
-- Name: FUNCTION st_simplifypolygonhull(geom public.geometry, vertex_fraction double precision, is_outer boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_simplifypolygonhull(geom public.geometry, vertex_fraction double precision, is_outer boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_simplifypolygonhull(geom public.geometry, vertex_fraction double precision, is_outer boolean) TO anon;
GRANT ALL ON FUNCTION public.st_simplifypolygonhull(geom public.geometry, vertex_fraction double precision, is_outer boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_simplifypolygonhull(geom public.geometry, vertex_fraction double precision, is_outer boolean) TO service_role;


--
-- Name: FUNCTION st_simplifypreservetopology(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_simplifypreservetopology(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_simplifypreservetopology(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_simplifypreservetopology(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_simplifypreservetopology(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_simplifyvw(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_simplifyvw(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_simplifyvw(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_simplifyvw(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_simplifyvw(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_snap(geom1 public.geometry, geom2 public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_snap(geom1 public.geometry, geom2 public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_snap(geom1 public.geometry, geom2 public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_snap(geom1 public.geometry, geom2 public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_snap(geom1 public.geometry, geom2 public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_snaptogrid(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_snaptogrid(public.geometry, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_snaptogrid(public.geometry, double precision, double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision, double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision, double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision, double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_snaptogrid(public.geometry, double precision, double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_snaptogrid(geom1 public.geometry, geom2 public.geometry, double precision, double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_snaptogrid(geom1 public.geometry, geom2 public.geometry, double precision, double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_snaptogrid(geom1 public.geometry, geom2 public.geometry, double precision, double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_snaptogrid(geom1 public.geometry, geom2 public.geometry, double precision, double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_snaptogrid(geom1 public.geometry, geom2 public.geometry, double precision, double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_split(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_split(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_split(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_split(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_split(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_square(size double precision, cell_i integer, cell_j integer, origin public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_square(size double precision, cell_i integer, cell_j integer, origin public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_square(size double precision, cell_i integer, cell_j integer, origin public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_square(size double precision, cell_i integer, cell_j integer, origin public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_square(size double precision, cell_i integer, cell_j integer, origin public.geometry) TO service_role;


--
-- Name: FUNCTION st_squaregrid(size double precision, bounds public.geometry, OUT geom public.geometry, OUT i integer, OUT j integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_squaregrid(size double precision, bounds public.geometry, OUT geom public.geometry, OUT i integer, OUT j integer) TO postgres;
GRANT ALL ON FUNCTION public.st_squaregrid(size double precision, bounds public.geometry, OUT geom public.geometry, OUT i integer, OUT j integer) TO anon;
GRANT ALL ON FUNCTION public.st_squaregrid(size double precision, bounds public.geometry, OUT geom public.geometry, OUT i integer, OUT j integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_squaregrid(size double precision, bounds public.geometry, OUT geom public.geometry, OUT i integer, OUT j integer) TO service_role;


--
-- Name: FUNCTION st_srid(geog public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_srid(geog public.geography) TO postgres;
GRANT ALL ON FUNCTION public.st_srid(geog public.geography) TO anon;
GRANT ALL ON FUNCTION public.st_srid(geog public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.st_srid(geog public.geography) TO service_role;


--
-- Name: FUNCTION st_srid(geom public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_srid(geom public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_srid(geom public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_srid(geom public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_srid(geom public.geometry) TO service_role;


--
-- Name: FUNCTION st_startpoint(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_startpoint(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_startpoint(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_startpoint(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_startpoint(public.geometry) TO service_role;


--
-- Name: FUNCTION st_subdivide(geom public.geometry, maxvertices integer, gridsize double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_subdivide(geom public.geometry, maxvertices integer, gridsize double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_subdivide(geom public.geometry, maxvertices integer, gridsize double precision) TO anon;
GRANT ALL ON FUNCTION public.st_subdivide(geom public.geometry, maxvertices integer, gridsize double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_subdivide(geom public.geometry, maxvertices integer, gridsize double precision) TO service_role;


--
-- Name: FUNCTION st_summary(public.geography); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_summary(public.geography) TO postgres;
GRANT ALL ON FUNCTION public.st_summary(public.geography) TO anon;
GRANT ALL ON FUNCTION public.st_summary(public.geography) TO authenticated;
GRANT ALL ON FUNCTION public.st_summary(public.geography) TO service_role;


--
-- Name: FUNCTION st_summary(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_summary(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_summary(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_summary(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_summary(public.geometry) TO service_role;


--
-- Name: FUNCTION st_swapordinates(geom public.geometry, ords cstring); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_swapordinates(geom public.geometry, ords cstring) TO postgres;
GRANT ALL ON FUNCTION public.st_swapordinates(geom public.geometry, ords cstring) TO anon;
GRANT ALL ON FUNCTION public.st_swapordinates(geom public.geometry, ords cstring) TO authenticated;
GRANT ALL ON FUNCTION public.st_swapordinates(geom public.geometry, ords cstring) TO service_role;


--
-- Name: FUNCTION st_symdifference(geom1 public.geometry, geom2 public.geometry, gridsize double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_symdifference(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_symdifference(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO anon;
GRANT ALL ON FUNCTION public.st_symdifference(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_symdifference(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO service_role;


--
-- Name: FUNCTION st_symmetricdifference(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_symmetricdifference(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_symmetricdifference(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_symmetricdifference(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_symmetricdifference(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_tileenvelope(zoom integer, x integer, y integer, bounds public.geometry, margin double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_tileenvelope(zoom integer, x integer, y integer, bounds public.geometry, margin double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_tileenvelope(zoom integer, x integer, y integer, bounds public.geometry, margin double precision) TO anon;
GRANT ALL ON FUNCTION public.st_tileenvelope(zoom integer, x integer, y integer, bounds public.geometry, margin double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_tileenvelope(zoom integer, x integer, y integer, bounds public.geometry, margin double precision) TO service_role;


--
-- Name: FUNCTION st_touches(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_touches(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_touches(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_touches(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_touches(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_transform(public.geometry, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_transform(public.geometry, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_transform(public.geometry, integer) TO anon;
GRANT ALL ON FUNCTION public.st_transform(public.geometry, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_transform(public.geometry, integer) TO service_role;


--
-- Name: FUNCTION st_transform(geom public.geometry, to_proj text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, to_proj text) TO postgres;
GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, to_proj text) TO anon;
GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, to_proj text) TO authenticated;
GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, to_proj text) TO service_role;


--
-- Name: FUNCTION st_transform(geom public.geometry, from_proj text, to_srid integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, from_proj text, to_srid integer) TO postgres;
GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, from_proj text, to_srid integer) TO anon;
GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, from_proj text, to_srid integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, from_proj text, to_srid integer) TO service_role;


--
-- Name: FUNCTION st_transform(geom public.geometry, from_proj text, to_proj text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, from_proj text, to_proj text) TO postgres;
GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, from_proj text, to_proj text) TO anon;
GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, from_proj text, to_proj text) TO authenticated;
GRANT ALL ON FUNCTION public.st_transform(geom public.geometry, from_proj text, to_proj text) TO service_role;


--
-- Name: FUNCTION st_translate(public.geometry, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_translate(public.geometry, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_translate(public.geometry, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_translate(public.geometry, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_translate(public.geometry, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_translate(public.geometry, double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_translate(public.geometry, double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_translate(public.geometry, double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_translate(public.geometry, double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_translate(public.geometry, double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_transscale(public.geometry, double precision, double precision, double precision, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_transscale(public.geometry, double precision, double precision, double precision, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_transscale(public.geometry, double precision, double precision, double precision, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_transscale(public.geometry, double precision, double precision, double precision, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_transscale(public.geometry, double precision, double precision, double precision, double precision) TO service_role;


--
-- Name: FUNCTION st_triangulatepolygon(g1 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_triangulatepolygon(g1 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_triangulatepolygon(g1 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_triangulatepolygon(g1 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_triangulatepolygon(g1 public.geometry) TO service_role;


--
-- Name: FUNCTION st_unaryunion(public.geometry, gridsize double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_unaryunion(public.geometry, gridsize double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_unaryunion(public.geometry, gridsize double precision) TO anon;
GRANT ALL ON FUNCTION public.st_unaryunion(public.geometry, gridsize double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_unaryunion(public.geometry, gridsize double precision) TO service_role;


--
-- Name: FUNCTION st_union(public.geometry[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_union(public.geometry[]) TO postgres;
GRANT ALL ON FUNCTION public.st_union(public.geometry[]) TO anon;
GRANT ALL ON FUNCTION public.st_union(public.geometry[]) TO authenticated;
GRANT ALL ON FUNCTION public.st_union(public.geometry[]) TO service_role;


--
-- Name: FUNCTION st_union(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_union(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_union(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_union(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_union(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_union(geom1 public.geometry, geom2 public.geometry, gridsize double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_union(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_union(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO anon;
GRANT ALL ON FUNCTION public.st_union(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_union(geom1 public.geometry, geom2 public.geometry, gridsize double precision) TO service_role;


--
-- Name: FUNCTION st_voronoilines(g1 public.geometry, tolerance double precision, extend_to public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_voronoilines(g1 public.geometry, tolerance double precision, extend_to public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_voronoilines(g1 public.geometry, tolerance double precision, extend_to public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_voronoilines(g1 public.geometry, tolerance double precision, extend_to public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_voronoilines(g1 public.geometry, tolerance double precision, extend_to public.geometry) TO service_role;


--
-- Name: FUNCTION st_voronoipolygons(g1 public.geometry, tolerance double precision, extend_to public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_voronoipolygons(g1 public.geometry, tolerance double precision, extend_to public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_voronoipolygons(g1 public.geometry, tolerance double precision, extend_to public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_voronoipolygons(g1 public.geometry, tolerance double precision, extend_to public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_voronoipolygons(g1 public.geometry, tolerance double precision, extend_to public.geometry) TO service_role;


--
-- Name: FUNCTION st_within(geom1 public.geometry, geom2 public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_within(geom1 public.geometry, geom2 public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_within(geom1 public.geometry, geom2 public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_within(geom1 public.geometry, geom2 public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_within(geom1 public.geometry, geom2 public.geometry) TO service_role;


--
-- Name: FUNCTION st_wkbtosql(wkb bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_wkbtosql(wkb bytea) TO postgres;
GRANT ALL ON FUNCTION public.st_wkbtosql(wkb bytea) TO anon;
GRANT ALL ON FUNCTION public.st_wkbtosql(wkb bytea) TO authenticated;
GRANT ALL ON FUNCTION public.st_wkbtosql(wkb bytea) TO service_role;


--
-- Name: FUNCTION st_wkttosql(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_wkttosql(text) TO postgres;
GRANT ALL ON FUNCTION public.st_wkttosql(text) TO anon;
GRANT ALL ON FUNCTION public.st_wkttosql(text) TO authenticated;
GRANT ALL ON FUNCTION public.st_wkttosql(text) TO service_role;


--
-- Name: FUNCTION st_wrapx(geom public.geometry, wrap double precision, move double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_wrapx(geom public.geometry, wrap double precision, move double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_wrapx(geom public.geometry, wrap double precision, move double precision) TO anon;
GRANT ALL ON FUNCTION public.st_wrapx(geom public.geometry, wrap double precision, move double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_wrapx(geom public.geometry, wrap double precision, move double precision) TO service_role;


--
-- Name: FUNCTION st_x(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_x(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_x(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_x(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_x(public.geometry) TO service_role;


--
-- Name: FUNCTION st_xmax(public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_xmax(public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.st_xmax(public.box3d) TO anon;
GRANT ALL ON FUNCTION public.st_xmax(public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.st_xmax(public.box3d) TO service_role;


--
-- Name: FUNCTION st_xmin(public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_xmin(public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.st_xmin(public.box3d) TO anon;
GRANT ALL ON FUNCTION public.st_xmin(public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.st_xmin(public.box3d) TO service_role;


--
-- Name: FUNCTION st_y(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_y(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_y(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_y(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_y(public.geometry) TO service_role;


--
-- Name: FUNCTION st_ymax(public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_ymax(public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.st_ymax(public.box3d) TO anon;
GRANT ALL ON FUNCTION public.st_ymax(public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.st_ymax(public.box3d) TO service_role;


--
-- Name: FUNCTION st_ymin(public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_ymin(public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.st_ymin(public.box3d) TO anon;
GRANT ALL ON FUNCTION public.st_ymin(public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.st_ymin(public.box3d) TO service_role;


--
-- Name: FUNCTION st_z(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_z(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_z(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_z(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_z(public.geometry) TO service_role;


--
-- Name: FUNCTION st_zmax(public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_zmax(public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.st_zmax(public.box3d) TO anon;
GRANT ALL ON FUNCTION public.st_zmax(public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.st_zmax(public.box3d) TO service_role;


--
-- Name: FUNCTION st_zmflag(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_zmflag(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_zmflag(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_zmflag(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_zmflag(public.geometry) TO service_role;


--
-- Name: FUNCTION st_zmin(public.box3d); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_zmin(public.box3d) TO postgres;
GRANT ALL ON FUNCTION public.st_zmin(public.box3d) TO anon;
GRANT ALL ON FUNCTION public.st_zmin(public.box3d) TO authenticated;
GRANT ALL ON FUNCTION public.st_zmin(public.box3d) TO service_role;


--
-- Name: FUNCTION storage_upload_public(p_bucket_name text, p_file_path text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.storage_upload_public(p_bucket_name text, p_file_path text) TO anon;
GRANT ALL ON FUNCTION public.storage_upload_public(p_bucket_name text, p_file_path text) TO authenticated;
GRANT ALL ON FUNCTION public.storage_upload_public(p_bucket_name text, p_file_path text) TO service_role;


--
-- Name: FUNCTION sync_client_data_to_invoice(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.sync_client_data_to_invoice() TO anon;
GRANT ALL ON FUNCTION public.sync_client_data_to_invoice() TO authenticated;
GRANT ALL ON FUNCTION public.sync_client_data_to_invoice() TO service_role;


--
-- Name: FUNCTION sync_client_data_to_quote(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.sync_client_data_to_quote() TO anon;
GRANT ALL ON FUNCTION public.sync_client_data_to_quote() TO authenticated;
GRANT ALL ON FUNCTION public.sync_client_data_to_quote() TO service_role;


--
-- Name: FUNCTION sync_credits_bidirectional(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.sync_credits_bidirectional() TO anon;
GRANT ALL ON FUNCTION public.sync_credits_bidirectional() TO authenticated;
GRANT ALL ON FUNCTION public.sync_credits_bidirectional() TO service_role;


--
-- Name: FUNCTION sync_invoice_date(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.sync_invoice_date() TO anon;
GRANT ALL ON FUNCTION public.sync_invoice_date() TO authenticated;
GRANT ALL ON FUNCTION public.sync_invoice_date() TO service_role;


--
-- Name: FUNCTION sync_profile_credits_from_user_credits(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.sync_profile_credits_from_user_credits() TO anon;
GRANT ALL ON FUNCTION public.sync_profile_credits_from_user_credits() TO authenticated;
GRANT ALL ON FUNCTION public.sync_profile_credits_from_user_credits() TO service_role;


--
-- Name: FUNCTION test_tracking_simulation(p_mission_id uuid, p_user_id uuid, p_start_lat double precision, p_start_lng double precision, p_end_lat double precision, p_end_lng double precision, p_steps integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.test_tracking_simulation(p_mission_id uuid, p_user_id uuid, p_start_lat double precision, p_start_lng double precision, p_end_lat double precision, p_end_lng double precision, p_steps integer) TO anon;
GRANT ALL ON FUNCTION public.test_tracking_simulation(p_mission_id uuid, p_user_id uuid, p_start_lat double precision, p_start_lng double precision, p_end_lat double precision, p_end_lng double precision, p_steps integer) TO authenticated;
GRANT ALL ON FUNCTION public.test_tracking_simulation(p_mission_id uuid, p_user_id uuid, p_start_lat double precision, p_start_lng double precision, p_end_lat double precision, p_end_lng double precision, p_steps integer) TO service_role;


--
-- Name: FUNCTION text_to_bytea(data text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.text_to_bytea(data text) TO postgres;
GRANT ALL ON FUNCTION public.text_to_bytea(data text) TO anon;
GRANT ALL ON FUNCTION public.text_to_bytea(data text) TO authenticated;
GRANT ALL ON FUNCTION public.text_to_bytea(data text) TO service_role;


--
-- Name: FUNCTION toggle_auto_renew(p_user_id uuid, p_enable boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.toggle_auto_renew(p_user_id uuid, p_enable boolean) TO anon;
GRANT ALL ON FUNCTION public.toggle_auto_renew(p_user_id uuid, p_enable boolean) TO authenticated;
GRANT ALL ON FUNCTION public.toggle_auto_renew(p_user_id uuid, p_enable boolean) TO service_role;


--
-- Name: FUNCTION trigger_combined_pdf_generation(); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION public.trigger_combined_pdf_generation() FROM PUBLIC;
GRANT ALL ON FUNCTION public.trigger_combined_pdf_generation() TO anon;
GRANT ALL ON FUNCTION public.trigger_combined_pdf_generation() TO authenticated;
GRANT ALL ON FUNCTION public.trigger_combined_pdf_generation() TO service_role;


--
-- Name: FUNCTION trigger_pdf_generation(); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION public.trigger_pdf_generation() FROM PUBLIC;
GRANT ALL ON FUNCTION public.trigger_pdf_generation() TO anon;
GRANT ALL ON FUNCTION public.trigger_pdf_generation() TO authenticated;
GRANT ALL ON FUNCTION public.trigger_pdf_generation() TO service_role;


--
-- Name: FUNCTION trigger_reset_credits_on_expiration(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.trigger_reset_credits_on_expiration() TO anon;
GRANT ALL ON FUNCTION public.trigger_reset_credits_on_expiration() TO authenticated;
GRANT ALL ON FUNCTION public.trigger_reset_credits_on_expiration() TO service_role;


--
-- Name: FUNCTION trigger_update_profile_completion(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.trigger_update_profile_completion() TO anon;
GRANT ALL ON FUNCTION public.trigger_update_profile_completion() TO authenticated;
GRANT ALL ON FUNCTION public.trigger_update_profile_completion() TO service_role;


--
-- Name: FUNCTION unlockrows(text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.unlockrows(text) TO postgres;
GRANT ALL ON FUNCTION public.unlockrows(text) TO anon;
GRANT ALL ON FUNCTION public.unlockrows(text) TO authenticated;
GRANT ALL ON FUNCTION public.unlockrows(text) TO service_role;


--
-- Name: FUNCTION update_ai_conversation_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_ai_conversation_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_ai_conversation_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_ai_conversation_updated_at() TO service_role;


--
-- Name: FUNCTION update_alert_votes(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_alert_votes() TO anon;
GRANT ALL ON FUNCTION public.update_alert_votes() TO authenticated;
GRANT ALL ON FUNCTION public.update_alert_votes() TO service_role;


--
-- Name: FUNCTION update_app_versions_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_app_versions_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_app_versions_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_app_versions_updated_at() TO service_role;


--
-- Name: FUNCTION update_attachments_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_attachments_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_attachments_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_attachments_updated_at() TO service_role;


--
-- Name: FUNCTION update_availability_timestamp(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_availability_timestamp() TO anon;
GRANT ALL ON FUNCTION public.update_availability_timestamp() TO authenticated;
GRANT ALL ON FUNCTION public.update_availability_timestamp() TO service_role;


--
-- Name: FUNCTION update_average_rating(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_average_rating() TO anon;
GRANT ALL ON FUNCTION public.update_average_rating() TO authenticated;
GRANT ALL ON FUNCTION public.update_average_rating() TO service_role;


--
-- Name: FUNCTION update_conversation_last_message(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_conversation_last_message() TO anon;
GRANT ALL ON FUNCTION public.update_conversation_last_message() TO authenticated;
GRANT ALL ON FUNCTION public.update_conversation_last_message() TO service_role;


--
-- Name: FUNCTION update_covoiturage_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_covoiturage_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_covoiturage_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_covoiturage_updated_at() TO service_role;


--
-- Name: FUNCTION update_driver_rating(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_driver_rating() TO anon;
GRANT ALL ON FUNCTION public.update_driver_rating() TO authenticated;
GRANT ALL ON FUNCTION public.update_driver_rating() TO service_role;


--
-- Name: FUNCTION update_driver_stats(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_driver_stats() TO anon;
GRANT ALL ON FUNCTION public.update_driver_stats() TO authenticated;
GRANT ALL ON FUNCTION public.update_driver_stats() TO service_role;


--
-- Name: FUNCTION update_inspection_damages_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_inspection_damages_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_inspection_damages_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_inspection_damages_updated_at() TO service_role;


--
-- Name: FUNCTION update_inspection_documents_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_inspection_documents_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_inspection_documents_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_inspection_documents_updated_at() TO service_role;


--
-- Name: FUNCTION update_navigation_sessions_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_navigation_sessions_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_navigation_sessions_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_navigation_sessions_updated_at() TO service_role;


--
-- Name: FUNCTION update_photo_metadata(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_photo_metadata() TO anon;
GRANT ALL ON FUNCTION public.update_photo_metadata() TO authenticated;
GRANT ALL ON FUNCTION public.update_photo_metadata() TO service_role;


--
-- Name: FUNCTION update_pricing_grids_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_pricing_grids_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_pricing_grids_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_pricing_grids_updated_at() TO service_role;


--
-- Name: FUNCTION update_public_reports_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_public_reports_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_public_reports_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_public_reports_updated_at() TO service_role;


--
-- Name: FUNCTION update_push_tokens_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_push_tokens_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_push_tokens_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_push_tokens_updated_at() TO service_role;


--
-- Name: FUNCTION update_quote_accepted_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_quote_accepted_at() TO anon;
GRANT ALL ON FUNCTION public.update_quote_accepted_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_quote_accepted_at() TO service_role;


--
-- Name: FUNCTION update_quote_converted_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_quote_converted_at() TO anon;
GRANT ALL ON FUNCTION public.update_quote_converted_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_quote_converted_at() TO service_role;


--
-- Name: FUNCTION update_quote_rejected_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_quote_rejected_at() TO anon;
GRANT ALL ON FUNCTION public.update_quote_rejected_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_quote_rejected_at() TO service_role;


--
-- Name: FUNCTION update_quote_sent_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_quote_sent_at() TO anon;
GRANT ALL ON FUNCTION public.update_quote_sent_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_quote_sent_at() TO service_role;


--
-- Name: FUNCTION update_quotes_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_quotes_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_quotes_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_quotes_updated_at() TO service_role;


--
-- Name: FUNCTION update_shop_quote_requests_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_shop_quote_requests_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_shop_quote_requests_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_shop_quote_requests_updated_at() TO service_role;


--
-- Name: FUNCTION update_subscription_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_subscription_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_subscription_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_subscription_updated_at() TO service_role;


--
-- Name: FUNCTION update_tracking_session_stats(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_tracking_session_stats() TO anon;
GRANT ALL ON FUNCTION public.update_tracking_session_stats() TO authenticated;
GRANT ALL ON FUNCTION public.update_tracking_session_stats() TO service_role;


--
-- Name: FUNCTION update_tracking_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_tracking_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_tracking_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_tracking_updated_at() TO service_role;


--
-- Name: FUNCTION update_trip_available_seats(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_trip_available_seats() TO anon;
GRANT ALL ON FUNCTION public.update_trip_available_seats() TO authenticated;
GRANT ALL ON FUNCTION public.update_trip_available_seats() TO service_role;


--
-- Name: FUNCTION update_trip_on_message(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_trip_on_message() TO anon;
GRANT ALL ON FUNCTION public.update_trip_on_message() TO authenticated;
GRANT ALL ON FUNCTION public.update_trip_on_message() TO service_role;


--
-- Name: FUNCTION update_unified_docs_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_unified_docs_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_unified_docs_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_unified_docs_updated_at() TO service_role;


--
-- Name: FUNCTION update_updated_at_column(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_updated_at_column() TO anon;
GRANT ALL ON FUNCTION public.update_updated_at_column() TO authenticated;
GRANT ALL ON FUNCTION public.update_updated_at_column() TO service_role;


--
-- Name: FUNCTION update_user_ai_memory_timestamp(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_user_ai_memory_timestamp() TO anon;
GRANT ALL ON FUNCTION public.update_user_ai_memory_timestamp() TO authenticated;
GRANT ALL ON FUNCTION public.update_user_ai_memory_timestamp() TO service_role;


--
-- Name: FUNCTION update_user_devices_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_user_devices_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_user_devices_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_user_devices_updated_at() TO service_role;


--
-- Name: FUNCTION update_user_location(p_lat double precision, p_lng double precision); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_user_location(p_lat double precision, p_lng double precision) TO anon;
GRANT ALL ON FUNCTION public.update_user_location(p_lat double precision, p_lng double precision) TO authenticated;
GRANT ALL ON FUNCTION public.update_user_location(p_lat double precision, p_lng double precision) TO service_role;


--
-- Name: FUNCTION update_user_rating(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_user_rating() TO anon;
GRANT ALL ON FUNCTION public.update_user_rating() TO authenticated;
GRANT ALL ON FUNCTION public.update_user_rating() TO service_role;


--
-- Name: FUNCTION update_user_stats_on_rating(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_user_stats_on_rating() TO anon;
GRANT ALL ON FUNCTION public.update_user_stats_on_rating() TO authenticated;
GRANT ALL ON FUNCTION public.update_user_stats_on_rating() TO service_role;


--
-- Name: FUNCTION update_wallet_transaction_timestamp(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_wallet_transaction_timestamp() TO anon;
GRANT ALL ON FUNCTION public.update_wallet_transaction_timestamp() TO authenticated;
GRANT ALL ON FUNCTION public.update_wallet_transaction_timestamp() TO service_role;


--
-- Name: FUNCTION updategeometrysrid(character varying, character varying, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.updategeometrysrid(character varying, character varying, integer) TO postgres;
GRANT ALL ON FUNCTION public.updategeometrysrid(character varying, character varying, integer) TO anon;
GRANT ALL ON FUNCTION public.updategeometrysrid(character varying, character varying, integer) TO authenticated;
GRANT ALL ON FUNCTION public.updategeometrysrid(character varying, character varying, integer) TO service_role;


--
-- Name: FUNCTION updategeometrysrid(character varying, character varying, character varying, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.updategeometrysrid(character varying, character varying, character varying, integer) TO postgres;
GRANT ALL ON FUNCTION public.updategeometrysrid(character varying, character varying, character varying, integer) TO anon;
GRANT ALL ON FUNCTION public.updategeometrysrid(character varying, character varying, character varying, integer) TO authenticated;
GRANT ALL ON FUNCTION public.updategeometrysrid(character varying, character varying, character varying, integer) TO service_role;


--
-- Name: FUNCTION updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer) TO postgres;
GRANT ALL ON FUNCTION public.updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer) TO anon;
GRANT ALL ON FUNCTION public.updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer) TO authenticated;
GRANT ALL ON FUNCTION public.updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer) TO service_role;


--
-- Name: FUNCTION upload_avatar_bypass_rls(p_user_id uuid, p_file_path text, p_public_url text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.upload_avatar_bypass_rls(p_user_id uuid, p_file_path text, p_public_url text) TO anon;
GRANT ALL ON FUNCTION public.upload_avatar_bypass_rls(p_user_id uuid, p_file_path text, p_public_url text) TO authenticated;
GRANT ALL ON FUNCTION public.upload_avatar_bypass_rls(p_user_id uuid, p_file_path text, p_public_url text) TO service_role;


--
-- Name: FUNCTION upsert_planning_stats(p_user_id uuid, p_km_saved double precision, p_hours_saved double precision, p_match_accepted boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.upsert_planning_stats(p_user_id uuid, p_km_saved double precision, p_hours_saved double precision, p_match_accepted boolean) TO anon;
GRANT ALL ON FUNCTION public.upsert_planning_stats(p_user_id uuid, p_km_saved double precision, p_hours_saved double precision, p_match_accepted boolean) TO authenticated;
GRANT ALL ON FUNCTION public.upsert_planning_stats(p_user_id uuid, p_km_saved double precision, p_hours_saved double precision, p_match_accepted boolean) TO service_role;


--
-- Name: FUNCTION upsert_push_token(p_token text, p_platform text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.upsert_push_token(p_token text, p_platform text) TO anon;
GRANT ALL ON FUNCTION public.upsert_push_token(p_token text, p_platform text) TO authenticated;
GRANT ALL ON FUNCTION public.upsert_push_token(p_token text, p_platform text) TO service_role;


--
-- Name: FUNCTION urlencode(string bytea); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.urlencode(string bytea) TO postgres;
GRANT ALL ON FUNCTION public.urlencode(string bytea) TO anon;
GRANT ALL ON FUNCTION public.urlencode(string bytea) TO authenticated;
GRANT ALL ON FUNCTION public.urlencode(string bytea) TO service_role;


--
-- Name: FUNCTION urlencode(data jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.urlencode(data jsonb) TO postgres;
GRANT ALL ON FUNCTION public.urlencode(data jsonb) TO anon;
GRANT ALL ON FUNCTION public.urlencode(data jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.urlencode(data jsonb) TO service_role;


--
-- Name: FUNCTION urlencode(string character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.urlencode(string character varying) TO postgres;
GRANT ALL ON FUNCTION public.urlencode(string character varying) TO anon;
GRANT ALL ON FUNCTION public.urlencode(string character varying) TO authenticated;
GRANT ALL ON FUNCTION public.urlencode(string character varying) TO service_role;


--
-- Name: FUNCTION apply_rls(wal jsonb, max_record_bytes integer); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO postgres;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO anon;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO authenticated;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO service_role;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO supabase_realtime_admin;


--
-- Name: FUNCTION broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) TO postgres;
GRANT ALL ON FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) TO dashboard_user;


--
-- Name: FUNCTION build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO postgres;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO anon;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO authenticated;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO service_role;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO supabase_realtime_admin;


--
-- Name: FUNCTION "cast"(val text, type_ regtype); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO postgres;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO dashboard_user;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO anon;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO authenticated;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO service_role;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO supabase_realtime_admin;


--
-- Name: FUNCTION check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO postgres;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO anon;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO authenticated;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO service_role;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO supabase_realtime_admin;


--
-- Name: FUNCTION is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO postgres;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO anon;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO authenticated;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO service_role;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO supabase_realtime_admin;


--
-- Name: FUNCTION list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO postgres;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO anon;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO authenticated;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO service_role;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO supabase_realtime_admin;


--
-- Name: FUNCTION quote_wal2json(entity regclass); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO postgres;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO anon;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO authenticated;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO service_role;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO supabase_realtime_admin;


--
-- Name: FUNCTION send(payload jsonb, event text, topic text, private boolean); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) TO postgres;
GRANT ALL ON FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) TO dashboard_user;


--
-- Name: FUNCTION subscription_check_filters(); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO postgres;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO dashboard_user;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO anon;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO authenticated;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO service_role;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO supabase_realtime_admin;


--
-- Name: FUNCTION to_regrole(role_name text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO postgres;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO anon;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO authenticated;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO service_role;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO supabase_realtime_admin;


--
-- Name: FUNCTION topic(); Type: ACL; Schema: realtime; Owner: supabase_realtime_admin
--

GRANT ALL ON FUNCTION realtime.topic() TO postgres;
GRANT ALL ON FUNCTION realtime.topic() TO dashboard_user;


--
-- Name: FUNCTION _crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea) TO service_role;


--
-- Name: FUNCTION create_secret(new_secret text, new_name text, new_description text, new_key_id uuid); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault.create_secret(new_secret text, new_name text, new_description text, new_key_id uuid) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION vault.create_secret(new_secret text, new_name text, new_description text, new_key_id uuid) TO service_role;


--
-- Name: FUNCTION update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault.update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION vault.update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid) TO service_role;


--
-- Name: FUNCTION st_3dextent(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_3dextent(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_3dextent(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_3dextent(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_3dextent(public.geometry) TO service_role;


--
-- Name: FUNCTION st_asflatgeobuf(anyelement); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement) TO postgres;
GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement) TO anon;
GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement) TO authenticated;
GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement) TO service_role;


--
-- Name: FUNCTION st_asflatgeobuf(anyelement, boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement, boolean) TO postgres;
GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement, boolean) TO anon;
GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement, boolean) TO authenticated;
GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement, boolean) TO service_role;


--
-- Name: FUNCTION st_asflatgeobuf(anyelement, boolean, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement, boolean, text) TO postgres;
GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement, boolean, text) TO anon;
GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement, boolean, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asflatgeobuf(anyelement, boolean, text) TO service_role;


--
-- Name: FUNCTION st_asgeobuf(anyelement); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asgeobuf(anyelement) TO postgres;
GRANT ALL ON FUNCTION public.st_asgeobuf(anyelement) TO anon;
GRANT ALL ON FUNCTION public.st_asgeobuf(anyelement) TO authenticated;
GRANT ALL ON FUNCTION public.st_asgeobuf(anyelement) TO service_role;


--
-- Name: FUNCTION st_asgeobuf(anyelement, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asgeobuf(anyelement, text) TO postgres;
GRANT ALL ON FUNCTION public.st_asgeobuf(anyelement, text) TO anon;
GRANT ALL ON FUNCTION public.st_asgeobuf(anyelement, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asgeobuf(anyelement, text) TO service_role;


--
-- Name: FUNCTION st_asmvt(anyelement); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asmvt(anyelement) TO postgres;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement) TO anon;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement) TO authenticated;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement) TO service_role;


--
-- Name: FUNCTION st_asmvt(anyelement, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text) TO postgres;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text) TO anon;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text) TO service_role;


--
-- Name: FUNCTION st_asmvt(anyelement, text, integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer) TO postgres;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer) TO anon;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer) TO authenticated;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer) TO service_role;


--
-- Name: FUNCTION st_asmvt(anyelement, text, integer, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer, text) TO postgres;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer, text) TO anon;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer, text) TO service_role;


--
-- Name: FUNCTION st_asmvt(anyelement, text, integer, text, text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer, text, text) TO postgres;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer, text, text) TO anon;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer, text, text) TO authenticated;
GRANT ALL ON FUNCTION public.st_asmvt(anyelement, text, integer, text, text) TO service_role;


--
-- Name: FUNCTION st_clusterintersecting(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_clusterintersecting(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_clusterintersecting(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_clusterintersecting(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_clusterintersecting(public.geometry) TO service_role;


--
-- Name: FUNCTION st_clusterwithin(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_clusterwithin(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_clusterwithin(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_clusterwithin(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_clusterwithin(public.geometry, double precision) TO service_role;


--
-- Name: FUNCTION st_collect(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_collect(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_collect(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_collect(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_collect(public.geometry) TO service_role;


--
-- Name: FUNCTION st_extent(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_extent(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_extent(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_extent(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_extent(public.geometry) TO service_role;


--
-- Name: FUNCTION st_makeline(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_makeline(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_makeline(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_makeline(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_makeline(public.geometry) TO service_role;


--
-- Name: FUNCTION st_memcollect(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_memcollect(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_memcollect(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_memcollect(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_memcollect(public.geometry) TO service_role;


--
-- Name: FUNCTION st_memunion(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_memunion(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_memunion(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_memunion(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_memunion(public.geometry) TO service_role;


--
-- Name: FUNCTION st_polygonize(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_polygonize(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_polygonize(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_polygonize(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_polygonize(public.geometry) TO service_role;


--
-- Name: FUNCTION st_union(public.geometry); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_union(public.geometry) TO postgres;
GRANT ALL ON FUNCTION public.st_union(public.geometry) TO anon;
GRANT ALL ON FUNCTION public.st_union(public.geometry) TO authenticated;
GRANT ALL ON FUNCTION public.st_union(public.geometry) TO service_role;


--
-- Name: FUNCTION st_union(public.geometry, double precision); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.st_union(public.geometry, double precision) TO postgres;
GRANT ALL ON FUNCTION public.st_union(public.geometry, double precision) TO anon;
GRANT ALL ON FUNCTION public.st_union(public.geometry, double precision) TO authenticated;
GRANT ALL ON FUNCTION public.st_union(public.geometry, double precision) TO service_role;


--
-- Name: TABLE audit_log_entries; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.audit_log_entries TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.audit_log_entries TO postgres;
GRANT SELECT ON TABLE auth.audit_log_entries TO postgres WITH GRANT OPTION;


--
-- Name: TABLE flow_state; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.flow_state TO postgres;
GRANT SELECT ON TABLE auth.flow_state TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.flow_state TO dashboard_user;


--
-- Name: TABLE identities; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.identities TO postgres;
GRANT SELECT ON TABLE auth.identities TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.identities TO dashboard_user;


--
-- Name: TABLE instances; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.instances TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.instances TO postgres;
GRANT SELECT ON TABLE auth.instances TO postgres WITH GRANT OPTION;


--
-- Name: TABLE mfa_amr_claims; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.mfa_amr_claims TO postgres;
GRANT SELECT ON TABLE auth.mfa_amr_claims TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_amr_claims TO dashboard_user;


--
-- Name: TABLE mfa_challenges; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.mfa_challenges TO postgres;
GRANT SELECT ON TABLE auth.mfa_challenges TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_challenges TO dashboard_user;


--
-- Name: TABLE mfa_factors; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.mfa_factors TO postgres;
GRANT SELECT ON TABLE auth.mfa_factors TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_factors TO dashboard_user;


--
-- Name: TABLE oauth_authorizations; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.oauth_authorizations TO postgres;
GRANT ALL ON TABLE auth.oauth_authorizations TO dashboard_user;


--
-- Name: TABLE oauth_client_states; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.oauth_client_states TO postgres;
GRANT ALL ON TABLE auth.oauth_client_states TO dashboard_user;


--
-- Name: TABLE oauth_clients; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.oauth_clients TO postgres;
GRANT ALL ON TABLE auth.oauth_clients TO dashboard_user;


--
-- Name: TABLE oauth_consents; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.oauth_consents TO postgres;
GRANT ALL ON TABLE auth.oauth_consents TO dashboard_user;


--
-- Name: TABLE one_time_tokens; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.one_time_tokens TO postgres;
GRANT SELECT ON TABLE auth.one_time_tokens TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.one_time_tokens TO dashboard_user;


--
-- Name: TABLE refresh_tokens; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.refresh_tokens TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.refresh_tokens TO postgres;
GRANT SELECT ON TABLE auth.refresh_tokens TO postgres WITH GRANT OPTION;


--
-- Name: SEQUENCE refresh_tokens_id_seq; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON SEQUENCE auth.refresh_tokens_id_seq TO dashboard_user;
GRANT ALL ON SEQUENCE auth.refresh_tokens_id_seq TO postgres;


--
-- Name: TABLE saml_providers; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.saml_providers TO postgres;
GRANT SELECT ON TABLE auth.saml_providers TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.saml_providers TO dashboard_user;


--
-- Name: TABLE saml_relay_states; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.saml_relay_states TO postgres;
GRANT SELECT ON TABLE auth.saml_relay_states TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.saml_relay_states TO dashboard_user;


--
-- Name: TABLE schema_migrations; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT SELECT ON TABLE auth.schema_migrations TO postgres WITH GRANT OPTION;


--
-- Name: TABLE sessions; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.sessions TO postgres;
GRANT SELECT ON TABLE auth.sessions TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sessions TO dashboard_user;


--
-- Name: TABLE sso_domains; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.sso_domains TO postgres;
GRANT SELECT ON TABLE auth.sso_domains TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sso_domains TO dashboard_user;


--
-- Name: TABLE sso_providers; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.sso_providers TO postgres;
GRANT SELECT ON TABLE auth.sso_providers TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sso_providers TO dashboard_user;


--
-- Name: TABLE users; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.users TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.users TO postgres;
GRANT SELECT ON TABLE auth.users TO postgres WITH GRANT OPTION;


--
-- Name: TABLE pg_stat_statements; Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON TABLE extensions.pg_stat_statements FROM postgres;
GRANT ALL ON TABLE extensions.pg_stat_statements TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE extensions.pg_stat_statements TO dashboard_user;


--
-- Name: TABLE pg_stat_statements_info; Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON TABLE extensions.pg_stat_statements_info FROM postgres;
GRANT ALL ON TABLE extensions.pg_stat_statements_info TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE extensions.pg_stat_statements_info TO dashboard_user;


--
-- Name: TABLE account_creation_attempts; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.account_creation_attempts TO anon;
GRANT ALL ON TABLE public.account_creation_attempts TO authenticated;
GRANT ALL ON TABLE public.account_creation_attempts TO service_role;


--
-- Name: TABLE user_devices; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.user_devices TO anon;
GRANT ALL ON TABLE public.user_devices TO authenticated;
GRANT ALL ON TABLE public.user_devices TO service_role;


--
-- Name: TABLE active_devices; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.active_devices TO anon;
GRANT ALL ON TABLE public.active_devices TO authenticated;
GRANT ALL ON TABLE public.active_devices TO service_role;


--
-- Name: TABLE mission_tracking_live; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.mission_tracking_live TO anon;
GRANT ALL ON TABLE public.mission_tracking_live TO authenticated;
GRANT ALL ON TABLE public.mission_tracking_live TO service_role;


--
-- Name: TABLE missions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.missions TO anon;
GRANT ALL ON TABLE public.missions TO authenticated;
GRANT ALL ON TABLE public.missions TO service_role;


--
-- Name: TABLE profiles; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.profiles TO anon;
GRANT ALL ON TABLE public.profiles TO authenticated;
GRANT ALL ON TABLE public.profiles TO service_role;


--
-- Name: TABLE ride_offers; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.ride_offers TO anon;
GRANT ALL ON TABLE public.ride_offers TO authenticated;
GRANT ALL ON TABLE public.ride_offers TO service_role;


--
-- Name: TABLE active_drivers_on_road; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.active_drivers_on_road TO anon;
GRANT ALL ON TABLE public.active_drivers_on_road TO authenticated;
GRANT ALL ON TABLE public.active_drivers_on_road TO service_role;


--
-- Name: TABLE subscriptions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.subscriptions TO anon;
GRANT ALL ON TABLE public.subscriptions TO authenticated;
GRANT ALL ON TABLE public.subscriptions TO service_role;


--
-- Name: TABLE admin_auto_renew_status; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.admin_auto_renew_status TO anon;
GRANT ALL ON TABLE public.admin_auto_renew_status TO authenticated;
GRANT ALL ON TABLE public.admin_auto_renew_status TO service_role;


--
-- Name: TABLE app_versions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.app_versions TO anon;
GRANT ALL ON TABLE public.app_versions TO authenticated;
GRANT ALL ON TABLE public.app_versions TO service_role;


--
-- Name: TABLE attachments; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.attachments TO anon;
GRANT ALL ON TABLE public.attachments TO authenticated;
GRANT ALL ON TABLE public.attachments TO service_role;


--
-- Name: TABLE availability_calendar; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.availability_calendar TO anon;
GRANT ALL ON TABLE public.availability_calendar TO authenticated;
GRANT ALL ON TABLE public.availability_calendar TO service_role;


--
-- Name: TABLE calendar_events; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.calendar_events TO anon;
GRANT ALL ON TABLE public.calendar_events TO authenticated;
GRANT ALL ON TABLE public.calendar_events TO service_role;


--
-- Name: TABLE calendar_permissions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.calendar_permissions TO anon;
GRANT ALL ON TABLE public.calendar_permissions TO authenticated;
GRANT ALL ON TABLE public.calendar_permissions TO service_role;


--
-- Name: TABLE carpooling_messages; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.carpooling_messages TO anon;
GRANT ALL ON TABLE public.carpooling_messages TO authenticated;
GRANT ALL ON TABLE public.carpooling_messages TO service_role;


--
-- Name: TABLE carpooling_trips; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.carpooling_trips TO anon;
GRANT ALL ON TABLE public.carpooling_trips TO authenticated;
GRANT ALL ON TABLE public.carpooling_trips TO service_role;


--
-- Name: TABLE carpooling_active_conversations; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.carpooling_active_conversations TO anon;
GRANT ALL ON TABLE public.carpooling_active_conversations TO authenticated;
GRANT ALL ON TABLE public.carpooling_active_conversations TO service_role;


--
-- Name: TABLE carpooling_bookings; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.carpooling_bookings TO anon;
GRANT ALL ON TABLE public.carpooling_bookings TO authenticated;
GRANT ALL ON TABLE public.carpooling_bookings TO service_role;


--
-- Name: TABLE invoices; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.invoices TO anon;
GRANT ALL ON TABLE public.invoices TO authenticated;
GRANT ALL ON TABLE public.invoices TO service_role;


--
-- Name: TABLE client_companies; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.client_companies TO anon;
GRANT ALL ON TABLE public.client_companies TO authenticated;
GRANT ALL ON TABLE public.client_companies TO service_role;


--
-- Name: TABLE clients; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.clients TO anon;
GRANT ALL ON TABLE public.clients TO authenticated;
GRANT ALL ON TABLE public.clients TO service_role;


--
-- Name: TABLE contacts; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.contacts TO anon;
GRANT ALL ON TABLE public.contacts TO authenticated;
GRANT ALL ON TABLE public.contacts TO service_role;


--
-- Name: TABLE contact_availability; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.contact_availability TO anon;
GRANT ALL ON TABLE public.contact_availability TO authenticated;
GRANT ALL ON TABLE public.contact_availability TO service_role;


--
-- Name: TABLE contact_invitations_received; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.contact_invitations_received TO anon;
GRANT ALL ON TABLE public.contact_invitations_received TO authenticated;
GRANT ALL ON TABLE public.contact_invitations_received TO service_role;


--
-- Name: TABLE contact_invitations_sent; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.contact_invitations_sent TO anon;
GRANT ALL ON TABLE public.contact_invitations_sent TO authenticated;
GRANT ALL ON TABLE public.contact_invitations_sent TO service_role;


--
-- Name: TABLE contact_requests; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.contact_requests TO anon;
GRANT ALL ON TABLE public.contact_requests TO authenticated;
GRANT ALL ON TABLE public.contact_requests TO service_role;


--
-- Name: TABLE convoy_plannings; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.convoy_plannings TO anon;
GRANT ALL ON TABLE public.convoy_plannings TO authenticated;
GRANT ALL ON TABLE public.convoy_plannings TO service_role;


--
-- Name: TABLE covoiturage_trips; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.covoiturage_trips TO anon;
GRANT ALL ON TABLE public.covoiturage_trips TO authenticated;
GRANT ALL ON TABLE public.covoiturage_trips TO service_role;


--
-- Name: TABLE credit_transactions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.credit_transactions TO anon;
GRANT ALL ON TABLE public.credit_transactions TO authenticated;
GRANT ALL ON TABLE public.credit_transactions TO service_role;


--
-- Name: TABLE deletion_requests; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.deletion_requests TO anon;
GRANT ALL ON TABLE public.deletion_requests TO authenticated;
GRANT ALL ON TABLE public.deletion_requests TO service_role;


--
-- Name: TABLE documents; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.documents TO anon;
GRANT ALL ON TABLE public.documents TO authenticated;
GRANT ALL ON TABLE public.documents TO service_role;


--
-- Name: TABLE gps_location_points; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.gps_location_points TO anon;
GRANT ALL ON TABLE public.gps_location_points TO authenticated;
GRANT ALL ON TABLE public.gps_location_points TO service_role;


--
-- Name: TABLE gps_tracking_sessions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.gps_tracking_sessions TO anon;
GRANT ALL ON TABLE public.gps_tracking_sessions TO authenticated;
GRANT ALL ON TABLE public.gps_tracking_sessions TO service_role;


--
-- Name: TABLE inspection_damages; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.inspection_damages TO anon;
GRANT ALL ON TABLE public.inspection_damages TO authenticated;
GRANT ALL ON TABLE public.inspection_damages TO service_role;


--
-- Name: TABLE inspection_documents; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.inspection_documents TO anon;
GRANT ALL ON TABLE public.inspection_documents TO authenticated;
GRANT ALL ON TABLE public.inspection_documents TO service_role;


--
-- Name: TABLE inspection_expenses; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.inspection_expenses TO anon;
GRANT ALL ON TABLE public.inspection_expenses TO authenticated;
GRANT ALL ON TABLE public.inspection_expenses TO service_role;


--
-- Name: TABLE inspection_pdfs; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.inspection_pdfs TO anon;
GRANT ALL ON TABLE public.inspection_pdfs TO authenticated;
GRANT ALL ON TABLE public.inspection_pdfs TO service_role;


--
-- Name: TABLE inspection_photos_v2; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.inspection_photos_v2 TO anon;
GRANT ALL ON TABLE public.inspection_photos_v2 TO authenticated;
GRANT ALL ON TABLE public.inspection_photos_v2 TO service_role;


--
-- Name: TABLE inspection_photos; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.inspection_photos TO anon;
GRANT ALL ON TABLE public.inspection_photos TO authenticated;
GRANT ALL ON TABLE public.inspection_photos TO service_role;


--
-- Name: TABLE inspection_report_shares; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.inspection_report_shares TO anon;
GRANT ALL ON TABLE public.inspection_report_shares TO authenticated;
GRANT ALL ON TABLE public.inspection_report_shares TO service_role;


--
-- Name: TABLE inspections; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.inspections TO anon;
GRANT ALL ON TABLE public.inspections TO authenticated;
GRANT ALL ON TABLE public.inspections TO service_role;


--
-- Name: TABLE invoice_items; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.invoice_items TO anon;
GRANT ALL ON TABLE public.invoice_items TO authenticated;
GRANT ALL ON TABLE public.invoice_items TO service_role;


--
-- Name: TABLE mission_assignments; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.mission_assignments TO anon;
GRANT ALL ON TABLE public.mission_assignments TO authenticated;
GRANT ALL ON TABLE public.mission_assignments TO service_role;


--
-- Name: TABLE mission_locations; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.mission_locations TO anon;
GRANT ALL ON TABLE public.mission_locations TO authenticated;
GRANT ALL ON TABLE public.mission_locations TO service_role;


--
-- Name: TABLE mission_revenue_logs; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.mission_revenue_logs TO anon;
GRANT ALL ON TABLE public.mission_revenue_logs TO authenticated;
GRANT ALL ON TABLE public.mission_revenue_logs TO service_role;


--
-- Name: TABLE mission_tracking_history; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.mission_tracking_history TO anon;
GRANT ALL ON TABLE public.mission_tracking_history TO authenticated;
GRANT ALL ON TABLE public.mission_tracking_history TO service_role;


--
-- Name: TABLE missions_with_active_tracking; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.missions_with_active_tracking TO anon;
GRANT ALL ON TABLE public.missions_with_active_tracking TO authenticated;
GRANT ALL ON TABLE public.missions_with_active_tracking TO service_role;


--
-- Name: TABLE navigation_sessions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.navigation_sessions TO anon;
GRANT ALL ON TABLE public.navigation_sessions TO authenticated;
GRANT ALL ON TABLE public.navigation_sessions TO service_role;


--
-- Name: TABLE navigation_alerts; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.navigation_alerts TO anon;
GRANT ALL ON TABLE public.navigation_alerts TO authenticated;
GRANT ALL ON TABLE public.navigation_alerts TO service_role;


--
-- Name: TABLE navigation_current_month_dashboard; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.navigation_current_month_dashboard TO anon;
GRANT ALL ON TABLE public.navigation_current_month_dashboard TO authenticated;
GRANT ALL ON TABLE public.navigation_current_month_dashboard TO service_role;


--
-- Name: TABLE navigation_daily_stats; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.navigation_daily_stats TO anon;
GRANT ALL ON TABLE public.navigation_daily_stats TO authenticated;
GRANT ALL ON TABLE public.navigation_daily_stats TO service_role;


--
-- Name: TABLE navigation_hourly_patterns; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.navigation_hourly_patterns TO anon;
GRANT ALL ON TABLE public.navigation_hourly_patterns TO authenticated;
GRANT ALL ON TABLE public.navigation_hourly_patterns TO service_role;


--
-- Name: TABLE navigation_mission_stats; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.navigation_mission_stats TO anon;
GRANT ALL ON TABLE public.navigation_mission_stats TO authenticated;
GRANT ALL ON TABLE public.navigation_mission_stats TO service_role;


--
-- Name: TABLE navigation_monthly_stats; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.navigation_monthly_stats TO anon;
GRANT ALL ON TABLE public.navigation_monthly_stats TO authenticated;
GRANT ALL ON TABLE public.navigation_monthly_stats TO service_role;


--
-- Name: TABLE navigation_top_missions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.navigation_top_missions TO anon;
GRANT ALL ON TABLE public.navigation_top_missions TO authenticated;
GRANT ALL ON TABLE public.navigation_top_missions TO service_role;


--
-- Name: TABLE notifications; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.notifications TO anon;
GRANT ALL ON TABLE public.notifications TO authenticated;
GRANT ALL ON TABLE public.notifications TO service_role;


--
-- Name: TABLE pending_contact_requests; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.pending_contact_requests TO anon;
GRANT ALL ON TABLE public.pending_contact_requests TO authenticated;
GRANT ALL ON TABLE public.pending_contact_requests TO service_role;


--
-- Name: TABLE phone_verifications; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.phone_verifications TO service_role;


--
-- Name: TABLE planning_matches; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.planning_matches TO anon;
GRANT ALL ON TABLE public.planning_matches TO authenticated;
GRANT ALL ON TABLE public.planning_matches TO service_role;


--
-- Name: TABLE planning_messages; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.planning_messages TO anon;
GRANT ALL ON TABLE public.planning_messages TO authenticated;
GRANT ALL ON TABLE public.planning_messages TO service_role;


--
-- Name: TABLE planning_notifications; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.planning_notifications TO anon;
GRANT ALL ON TABLE public.planning_notifications TO authenticated;
GRANT ALL ON TABLE public.planning_notifications TO service_role;


--
-- Name: TABLE planning_stats; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.planning_stats TO anon;
GRANT ALL ON TABLE public.planning_stats TO authenticated;
GRANT ALL ON TABLE public.planning_stats TO service_role;


--
-- Name: TABLE planning_waypoints; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.planning_waypoints TO anon;
GRANT ALL ON TABLE public.planning_waypoints TO authenticated;
GRANT ALL ON TABLE public.planning_waypoints TO service_role;


--
-- Name: TABLE pricing_grids; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.pricing_grids TO anon;
GRANT ALL ON TABLE public.pricing_grids TO authenticated;
GRANT ALL ON TABLE public.pricing_grids TO service_role;


--
-- Name: TABLE public_inspection_reports; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.public_inspection_reports TO anon;
GRANT ALL ON TABLE public.public_inspection_reports TO authenticated;
GRANT ALL ON TABLE public.public_inspection_reports TO service_role;


--
-- Name: TABLE public_tracking_links; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.public_tracking_links TO anon;
GRANT ALL ON TABLE public.public_tracking_links TO authenticated;
GRANT ALL ON TABLE public.public_tracking_links TO service_role;


--
-- Name: TABLE push_tokens; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.push_tokens TO anon;
GRANT ALL ON TABLE public.push_tokens TO authenticated;
GRANT ALL ON TABLE public.push_tokens TO service_role;


--
-- Name: TABLE quote_items; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.quote_items TO anon;
GRANT ALL ON TABLE public.quote_items TO authenticated;
GRANT ALL ON TABLE public.quote_items TO service_role;


--
-- Name: TABLE quotes; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.quotes TO anon;
GRANT ALL ON TABLE public.quotes TO authenticated;
GRANT ALL ON TABLE public.quotes TO service_role;


--
-- Name: TABLE quote_statistics; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.quote_statistics TO anon;
GRANT ALL ON TABLE public.quote_statistics TO authenticated;
GRANT ALL ON TABLE public.quote_statistics TO service_role;


--
-- Name: TABLE ride_matches; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.ride_matches TO anon;
GRANT ALL ON TABLE public.ride_matches TO authenticated;
GRANT ALL ON TABLE public.ride_matches TO service_role;


--
-- Name: TABLE ride_messages; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.ride_messages TO anon;
GRANT ALL ON TABLE public.ride_messages TO authenticated;
GRANT ALL ON TABLE public.ride_messages TO service_role;


--
-- Name: TABLE ride_ratings; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.ride_ratings TO anon;
GRANT ALL ON TABLE public.ride_ratings TO authenticated;
GRANT ALL ON TABLE public.ride_ratings TO service_role;


--
-- Name: TABLE ride_requests; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.ride_requests TO anon;
GRANT ALL ON TABLE public.ride_requests TO authenticated;
GRANT ALL ON TABLE public.ride_requests TO service_role;


--
-- Name: TABLE shop_items; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.shop_items TO anon;
GRANT ALL ON TABLE public.shop_items TO authenticated;
GRANT ALL ON TABLE public.shop_items TO service_role;


--
-- Name: TABLE shop_quote_requests; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.shop_quote_requests TO anon;
GRANT ALL ON TABLE public.shop_quote_requests TO authenticated;
GRANT ALL ON TABLE public.shop_quote_requests TO service_role;


--
-- Name: TABLE signup_attempts; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.signup_attempts TO anon;
GRANT ALL ON TABLE public.signup_attempts TO authenticated;
GRANT ALL ON TABLE public.signup_attempts TO service_role;


--
-- Name: TABLE storage_stats; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.storage_stats TO anon;
GRANT ALL ON TABLE public.storage_stats TO authenticated;
GRANT ALL ON TABLE public.storage_stats TO service_role;


--
-- Name: TABLE support_conversations; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.support_conversations TO anon;
GRANT ALL ON TABLE public.support_conversations TO authenticated;
GRANT ALL ON TABLE public.support_conversations TO service_role;


--
-- Name: TABLE support_messages; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.support_messages TO anon;
GRANT ALL ON TABLE public.support_messages TO authenticated;
GRANT ALL ON TABLE public.support_messages TO service_role;


--
-- Name: TABLE support_tickets; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.support_tickets TO anon;
GRANT ALL ON TABLE public.support_tickets TO authenticated;
GRANT ALL ON TABLE public.support_tickets TO service_role;


--
-- Name: TABLE suspicious_accounts; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.suspicious_accounts TO anon;
GRANT ALL ON TABLE public.suspicious_accounts TO authenticated;
GRANT ALL ON TABLE public.suspicious_accounts TO service_role;


--
-- Name: TABLE tracking_performance_stats; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.tracking_performance_stats TO anon;
GRANT ALL ON TABLE public.tracking_performance_stats TO authenticated;
GRANT ALL ON TABLE public.tracking_performance_stats TO service_role;


--
-- Name: TABLE transactions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.transactions TO anon;
GRANT ALL ON TABLE public.transactions TO authenticated;
GRANT ALL ON TABLE public.transactions TO service_role;


--
-- Name: TABLE unified_scanned_documents; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.unified_scanned_documents TO anon;
GRANT ALL ON TABLE public.unified_scanned_documents TO authenticated;
GRANT ALL ON TABLE public.unified_scanned_documents TO service_role;


--
-- Name: TABLE user_consents; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.user_consents TO anon;
GRANT ALL ON TABLE public.user_consents TO authenticated;
GRANT ALL ON TABLE public.user_consents TO service_role;


--
-- Name: TABLE user_credits; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.user_credits TO anon;
GRANT ALL ON TABLE public.user_credits TO authenticated;
GRANT ALL ON TABLE public.user_credits TO service_role;


--
-- Name: TABLE user_document_stats; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.user_document_stats TO anon;
GRANT ALL ON TABLE public.user_document_stats TO authenticated;
GRANT ALL ON TABLE public.user_document_stats TO service_role;


--
-- Name: TABLE user_monthly_revenue_stats; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.user_monthly_revenue_stats TO anon;
GRANT ALL ON TABLE public.user_monthly_revenue_stats TO authenticated;
GRANT ALL ON TABLE public.user_monthly_revenue_stats TO service_role;


--
-- Name: TABLE user_push_tokens; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.user_push_tokens TO anon;
GRANT ALL ON TABLE public.user_push_tokens TO authenticated;
GRANT ALL ON TABLE public.user_push_tokens TO service_role;


--
-- Name: TABLE vehicle_inspections; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.vehicle_inspections TO anon;
GRANT ALL ON TABLE public.vehicle_inspections TO authenticated;
GRANT ALL ON TABLE public.vehicle_inspections TO service_role;


--
-- Name: TABLE v_inspection_reports; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.v_inspection_reports TO anon;
GRANT ALL ON TABLE public.v_inspection_reports TO authenticated;
GRANT ALL ON TABLE public.v_inspection_reports TO service_role;


--
-- Name: TABLE messages; Type: ACL; Schema: realtime; Owner: supabase_realtime_admin
--

GRANT ALL ON TABLE realtime.messages TO postgres;
GRANT ALL ON TABLE realtime.messages TO dashboard_user;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO anon;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO authenticated;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO service_role;


--
-- Name: TABLE messages_2026_02_15; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2026_02_15 TO postgres;
GRANT ALL ON TABLE realtime.messages_2026_02_15 TO dashboard_user;


--
-- Name: TABLE messages_2026_02_16; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2026_02_16 TO postgres;
GRANT ALL ON TABLE realtime.messages_2026_02_16 TO dashboard_user;


--
-- Name: TABLE messages_2026_02_17; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2026_02_17 TO postgres;
GRANT ALL ON TABLE realtime.messages_2026_02_17 TO dashboard_user;


--
-- Name: TABLE messages_2026_02_18; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2026_02_18 TO postgres;
GRANT ALL ON TABLE realtime.messages_2026_02_18 TO dashboard_user;


--
-- Name: TABLE messages_2026_02_19; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2026_02_19 TO postgres;
GRANT ALL ON TABLE realtime.messages_2026_02_19 TO dashboard_user;


--
-- Name: TABLE messages_2026_02_20; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2026_02_20 TO postgres;
GRANT ALL ON TABLE realtime.messages_2026_02_20 TO dashboard_user;


--
-- Name: TABLE messages_2026_02_21; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2026_02_21 TO postgres;
GRANT ALL ON TABLE realtime.messages_2026_02_21 TO dashboard_user;


--
-- Name: TABLE schema_migrations; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.schema_migrations TO postgres;
GRANT ALL ON TABLE realtime.schema_migrations TO dashboard_user;
GRANT SELECT ON TABLE realtime.schema_migrations TO anon;
GRANT SELECT ON TABLE realtime.schema_migrations TO authenticated;
GRANT SELECT ON TABLE realtime.schema_migrations TO service_role;
GRANT ALL ON TABLE realtime.schema_migrations TO supabase_realtime_admin;


--
-- Name: TABLE subscription; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.subscription TO postgres;
GRANT ALL ON TABLE realtime.subscription TO dashboard_user;
GRANT SELECT ON TABLE realtime.subscription TO anon;
GRANT SELECT ON TABLE realtime.subscription TO authenticated;
GRANT SELECT ON TABLE realtime.subscription TO service_role;
GRANT ALL ON TABLE realtime.subscription TO supabase_realtime_admin;


--
-- Name: SEQUENCE subscription_id_seq; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO postgres;
GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO dashboard_user;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO anon;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO authenticated;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO service_role;
GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO supabase_realtime_admin;


--
-- Name: TABLE buckets; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

REVOKE ALL ON TABLE storage.buckets FROM supabase_storage_admin;
GRANT ALL ON TABLE storage.buckets TO supabase_storage_admin WITH GRANT OPTION;
GRANT ALL ON TABLE storage.buckets TO anon;
GRANT ALL ON TABLE storage.buckets TO authenticated;
GRANT ALL ON TABLE storage.buckets TO service_role;
GRANT ALL ON TABLE storage.buckets TO postgres WITH GRANT OPTION;


--
-- Name: TABLE buckets_analytics; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.buckets_analytics TO service_role;
GRANT ALL ON TABLE storage.buckets_analytics TO authenticated;
GRANT ALL ON TABLE storage.buckets_analytics TO anon;


--
-- Name: TABLE buckets_vectors; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT SELECT ON TABLE storage.buckets_vectors TO service_role;
GRANT SELECT ON TABLE storage.buckets_vectors TO authenticated;
GRANT SELECT ON TABLE storage.buckets_vectors TO anon;


--
-- Name: TABLE objects; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

REVOKE ALL ON TABLE storage.objects FROM supabase_storage_admin;
GRANT ALL ON TABLE storage.objects TO supabase_storage_admin WITH GRANT OPTION;
GRANT ALL ON TABLE storage.objects TO anon;
GRANT ALL ON TABLE storage.objects TO authenticated;
GRANT ALL ON TABLE storage.objects TO service_role;
GRANT ALL ON TABLE storage.objects TO postgres WITH GRANT OPTION;


--
-- Name: TABLE s3_multipart_uploads; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.s3_multipart_uploads TO service_role;
GRANT SELECT ON TABLE storage.s3_multipart_uploads TO authenticated;
GRANT SELECT ON TABLE storage.s3_multipart_uploads TO anon;


--
-- Name: TABLE s3_multipart_uploads_parts; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.s3_multipart_uploads_parts TO service_role;
GRANT SELECT ON TABLE storage.s3_multipart_uploads_parts TO authenticated;
GRANT SELECT ON TABLE storage.s3_multipart_uploads_parts TO anon;


--
-- Name: TABLE vector_indexes; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT SELECT ON TABLE storage.vector_indexes TO service_role;
GRANT SELECT ON TABLE storage.vector_indexes TO authenticated;
GRANT SELECT ON TABLE storage.vector_indexes TO anon;


--
-- Name: TABLE secrets; Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT SELECT,REFERENCES,DELETE,TRUNCATE ON TABLE vault.secrets TO postgres WITH GRANT OPTION;
GRANT SELECT,DELETE ON TABLE vault.secrets TO service_role;


--
-- Name: TABLE decrypted_secrets; Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT SELECT,REFERENCES,DELETE,TRUNCATE ON TABLE vault.decrypted_secrets TO postgres WITH GRANT OPTION;
GRANT SELECT,DELETE ON TABLE vault.decrypted_secrets TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON SEQUENCES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON FUNCTIONS TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON TABLES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON SEQUENCES TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON FUNCTIONS TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON TABLES TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON SEQUENCES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON FUNCTIONS TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON TABLES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO service_role;


--
-- Name: issue_graphql_placeholder; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_graphql_placeholder ON sql_drop
         WHEN TAG IN ('DROP EXTENSION')
   EXECUTE FUNCTION extensions.set_graphql_placeholder();


ALTER EVENT TRIGGER issue_graphql_placeholder OWNER TO supabase_admin;

--
-- Name: issue_pg_cron_access; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_pg_cron_access ON ddl_command_end
         WHEN TAG IN ('CREATE EXTENSION')
   EXECUTE FUNCTION extensions.grant_pg_cron_access();


ALTER EVENT TRIGGER issue_pg_cron_access OWNER TO supabase_admin;

--
-- Name: issue_pg_graphql_access; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_pg_graphql_access ON ddl_command_end
         WHEN TAG IN ('CREATE FUNCTION')
   EXECUTE FUNCTION extensions.grant_pg_graphql_access();


ALTER EVENT TRIGGER issue_pg_graphql_access OWNER TO supabase_admin;

--
-- Name: issue_pg_net_access; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_pg_net_access ON ddl_command_end
         WHEN TAG IN ('CREATE EXTENSION')
   EXECUTE FUNCTION extensions.grant_pg_net_access();


ALTER EVENT TRIGGER issue_pg_net_access OWNER TO supabase_admin;

--
-- Name: pgrst_ddl_watch; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER pgrst_ddl_watch ON ddl_command_end
   EXECUTE FUNCTION extensions.pgrst_ddl_watch();


ALTER EVENT TRIGGER pgrst_ddl_watch OWNER TO supabase_admin;

--
-- Name: pgrst_drop_watch; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER pgrst_drop_watch ON sql_drop
   EXECUTE FUNCTION extensions.pgrst_drop_watch();


ALTER EVENT TRIGGER pgrst_drop_watch OWNER TO supabase_admin;

--
-- PostgreSQL database dump complete
--

\unrestrict uSfZdqbqhDLfdiWcebdf7bVHiHLTUWaNEc4mwTcw8d1fUIGlfaW5gx4fyH2JXE1

