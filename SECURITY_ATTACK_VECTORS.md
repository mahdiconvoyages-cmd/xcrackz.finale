# üõ°Ô∏è VECTEURS D'ATTAQUE & PROTECTIONS - ANALYSE COMPL√àTE

## ‚ö†Ô∏è Comment un attaquant POURRAIT-IL essayer de contourner la s√©curit√© ?

Analysons **TOUTES** les tentatives possibles et pourquoi elles **√âCHOUENT**.

---

## üéØ ATTAQUE 1: Modifier l'URL manuellement

### üî¥ Tentative de l'attaquant :
```
Je ne suis pas admin, mais je vais taper:
http://localhost:5174/admin/support
```

### ‚úÖ Pourquoi √ßa √âCHOUE :

**Flux de s√©curit√©** :
```tsx
// App.tsx - Route
<Route path="/admin/support" element={
  <AdminRoute>  {/* ‚Üê Checkpoint 1 */}
    <AdminSupport />
  </AdminRoute>
} />

// AdminRoute.tsx - V√©rification
export default function AdminRoute({ children }) {
  const { user } = useAuth();          // ‚Üê User connect√© ?
  const { isAdmin } = useAdmin();      // ‚Üê Requ√™te BDD is_admin

  if (!user) {
    return <Navigate to="/login" />;   // ‚Üê BLOQU√â: Pas connect√©
  }

  if (!isAdmin) {
    return <Navigate to="/dashboard" />; // ‚Üê BLOQU√â: Pas admin
  }

  return <>{children}</>;  // ‚Üê Jamais atteint si pas admin
}
```

**R√©sultat** :
- ‚ùå `useAdmin()` fait une **vraie requ√™te Supabase**
- ‚ùå Supabase retourne `is_admin = false`
- ‚ùå **Redirection automatique** vers `/dashboard`
- üõ°Ô∏è **Page jamais affich√©e**

---

## üéØ ATTAQUE 2: Modifier le code JavaScript dans le navigateur

### üî¥ Tentative de l'attaquant :
```javascript
// Dans la console Chrome DevTools
localStorage.setItem('isAdmin', 'true');
// ou
window.isAdmin = true;
```

### ‚úÖ Pourquoi √ßa √âCHOUE :

**Ce que l'attaquant ne comprend pas** :
```tsx
// useAdmin.ts - La SOURCE de v√©rit√© est la BDD
const { data } = await supabase
  .from('profiles')
  .select('is_admin')
  .eq('id', user.id)
  .maybeSingle();

setIsAdmin(data?.is_admin || false);  // ‚Üê Vient de SUPABASE, pas du localStorage
```

**Flux r√©el** :
1. Attaquant modifie `localStorage` ‚ùå
2. `useAdmin()` **ignore compl√®tement** le localStorage
3. `useAdmin()` fait une **requ√™te HTTP √† Supabase**
4. Supabase retourne `{ is_admin: false }`
5. `isAdmin` state = `false`
6. **Redirection** vers `/dashboard`

**Pourquoi c'est impossible** :
- Le state `isAdmin` vient d'une **requ√™te serveur**, pas d'une variable locale
- Modifier des variables JS locales ne change **PAS** la base de donn√©es
- √Ä chaque rechargement, nouvelle requ√™te ‚Üí vraie valeur r√©cup√©r√©e

---

## üéØ ATTAQUE 3: Modifier le code source React (DevTools)

### üî¥ Tentative de l'attaquant :
```javascript
// Dans React DevTools
// Trouver le composant AdminRoute
// Modifier le state isAdmin = true
```

### ‚úÖ Pourquoi √ßa √âCHOUE :

**Sc√©nario** :
1. ‚úÖ Attaquant r√©ussit √† modifier `isAdmin = true` dans React DevTools
2. ‚úÖ La page AdminSupport s'affiche (temporairement)
3. ‚ùå **MAIS** quand la page fait une requ√™te pour charger les donn√©es...

```tsx
// AdminSupport.tsx
const loadQuoteRequests = async () => {
  const { data, error } = await supabase
    .from('shop_quote_requests')
    .select('*');  // ‚Üê Requ√™te bloqu√©e par RLS !
    
  if (error) {
    // Error: 403 Forbidden - RLS policy failed
    console.error('Permission denied');
  }
};
```

**RLS Policy c√¥t√© serveur** :
```sql
CREATE POLICY "Admins can view all quote requests"
  ON public.shop_quote_requests
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid()  -- ‚Üê auth.uid() = vrai ID utilisateur
      AND profiles.is_admin = true     -- ‚Üê V√©rifi√© dans la BDD
    )
  );
```

**R√©sultat** :
- ‚úÖ Page affich√©e (frontend hack√©)
- ‚ùå **AUCUNE DONN√âE** retourn√©e (backend prot√©g√©)
- ‚ùå Erreur 403 Forbidden sur toutes les requ√™tes
- üõ°Ô∏è **Attaquant voit une page vide**

---

## üéØ ATTAQUE 4: Intercepter et modifier les requ√™tes HTTP (Proxy/Burp Suite)

### üî¥ Tentative de l'attaquant :
```
Utiliser un proxy HTTP (Burp Suite, Charles, etc.)
Intercepter la requ√™te:
GET /rest/v1/profiles?id=eq.xxx

Modifier la r√©ponse:
{ "is_admin": true }  ‚Üê Fausse r√©ponse
```

### ‚úÖ Pourquoi √ßa √âCHOUE :

**Probl√®me 1 : JWT Token**
```javascript
// Chaque requ√™te Supabase inclut un JWT
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...

// Ce JWT contient:
{
  "sub": "user-uuid",
  "email": "attacker@example.com",
  "role": "authenticated"
}
```

Le JWT est **sign√© par Supabase** avec une cl√© secr√®te.
- ‚ùå Impossible de forger un JWT valide sans la cl√© secr√®te
- ‚ùå Modifier le JWT ‚Üí Signature invalide ‚Üí Requ√™te rejet√©e

**Probl√®me 2 : RLS Policies sur TOUTES les requ√™tes**

M√™me si l'attaquant modifie la r√©ponse `{ is_admin: true }`, quand il essaie de r√©cup√©rer les donn√©es :

```sql
-- Requ√™te de l'attaquant
SELECT * FROM shop_quote_requests;

-- Supabase ex√©cute VRAIMENT:
SELECT * FROM shop_quote_requests
WHERE (
  -- RLS Policy appliqu√©e automatiquement
  EXISTS (
    SELECT 1 FROM profiles
    WHERE profiles.id = auth.uid()  -- ‚Üê JWT v√©rifi√© ici
    AND profiles.is_admin = true     -- ‚Üê V√©rifi√© dans la BDD
  )
);

-- R√©sultat: 0 lignes (is_admin = false dans la BDD)
```

**R√©sultat** :
- ‚ùå JWT emp√™che la falsification d'identit√©
- ‚ùå RLS policies ex√©cut√©es **c√¥t√© serveur PostgreSQL**
- ‚ùå Impossible de modifier la r√©ponse SQL
- üõ°Ô∏è **Aucune donn√©e sensible retourn√©e**

---

## üéØ ATTAQUE 5: Injection SQL

### üî¥ Tentative de l'attaquant :
```javascript
// Essayer d'injecter du SQL malveillant
const maliciousId = "xxx' OR '1'='1";

await supabase
  .from('profiles')
  .select('is_admin')
  .eq('id', maliciousId);  // ‚Üê Injection ?
```

### ‚úÖ Pourquoi √ßa √âCHOUE :

**Supabase utilise des requ√™tes pr√©par√©es (Prepared Statements)** :

```sql
-- Ce que l'attaquant VEUT ex√©cuter:
SELECT is_admin FROM profiles WHERE id = 'xxx' OR '1'='1';

-- Ce que Supabase EX√âCUTE VRAIMENT:
SELECT is_admin FROM profiles WHERE id = $1;
-- Avec $1 = "xxx' OR '1'='1" (trait√© comme STRING litt√©rale)

-- R√©sultat: Aucune ligne (UUID invalide)
```

**Protection automatique** :
- ‚úÖ Supabase **√©chappe automatiquement** tous les param√®tres
- ‚úÖ Impossible d'injecter du SQL
- ‚úÖ UUID validation (format strict)
- üõ°Ô∏è **Injection SQL impossible**

---

## üéØ ATTAQUE 6: Cr√©er un faux compte admin dans la BDD

### üî¥ Tentative de l'attaquant :
```sql
-- Essayer d'ex√©cuter directement:
UPDATE profiles SET is_admin = true WHERE id = 'mon-user-id';
```

### ‚úÖ Pourquoi √ßa √âCHOUE :

**RLS Policy sur la table profiles** :
```sql
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can update own profile" 
  ON public.profiles 
  FOR UPDATE 
  TO authenticated 
  USING (auth.uid() = id)      -- ‚Üê Peut seulement modifier SON profil
  WITH CHECK (auth.uid() = id);
```

**Ce qui se passe** :
1. Attaquant essaie : `UPDATE profiles SET is_admin = true WHERE id = 'xxx'`
2. PostgreSQL v√©rifie la RLS policy
3. Policy dit : "Tu peux modifier SEULEMENT **ton** profil (`auth.uid() = id`)"
4. **MAIS** la policy ne sp√©cifie **PAS** quelles colonnes peuvent √™tre modifi√©es !

**‚ö†Ô∏è PROBL√àME POTENTIEL D√âTECT√â !**

La RLS actuelle permet √† un utilisateur de modifier **n'importe quelle colonne** de son profil, y compris `is_admin` !

```sql
-- Ceci pourrait FONCTIONNER (si pas d'autres protections):
UPDATE profiles 
SET is_admin = true 
WHERE id = auth.uid();  -- ‚Üê Son propre ID
```

---

## üö® VULN√âRABILIT√â CRITIQUE: Colonne is_admin modifiable ?

### üî¥ Test de s√©curit√© :

```javascript
// Un utilisateur normal pourrait essayer:
const { data, error } = await supabase
  .from('profiles')
  .update({ is_admin: true })
  .eq('id', user.id);

// Si √ßa r√©ussit ‚Üí FAILLE DE S√âCURIT√â !
```

### ‚úÖ SOLUTIONS (√† impl√©menter) :

#### **Solution 1: Policy stricte sur les colonnes**

```sql
-- Cr√©er une policy s√©par√©e pour is_admin
DROP POLICY "Users can update own profile" ON public.profiles;

-- Users peuvent modifier leur profil SAUF is_admin
CREATE POLICY "Users can update own profile" 
  ON public.profiles 
  FOR UPDATE 
  TO authenticated 
  USING (auth.uid() = id)
  WITH CHECK (
    auth.uid() = id 
    AND OLD.is_admin = NEW.is_admin  -- ‚Üê is_admin ne peut PAS changer
  );

-- Seuls les admins peuvent modifier is_admin
CREATE POLICY "Only admins can modify admin status"
  ON public.profiles
  FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE id = auth.uid() 
      AND is_admin = true
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE id = auth.uid() 
      AND is_admin = true
    )
  );
```

#### **Solution 2: Trigger PostgreSQL**

```sql
-- Emp√™cher la modification de is_admin via trigger
CREATE OR REPLACE FUNCTION prevent_is_admin_modification()
RETURNS TRIGGER AS $$
BEGIN
  -- Si changement de is_admin par un non-admin
  IF OLD.is_admin != NEW.is_admin THEN
    -- V√©rifier si l'utilisateur actuel est admin
    IF NOT EXISTS (
      SELECT 1 FROM profiles 
      WHERE id = auth.uid() 
      AND is_admin = true
    ) THEN
      RAISE EXCEPTION 'Only admins can modify admin status';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER protect_is_admin_column
  BEFORE UPDATE ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION prevent_is_admin_modification();
```

#### **Solution 3: Column-level permissions (PostgreSQL natif)**

```sql
-- R√©voquer les permissions UPDATE sur la colonne is_admin
REVOKE UPDATE (is_admin) ON profiles FROM authenticated;

-- Seul le r√¥le service_role peut modifier is_admin
GRANT UPDATE (is_admin) ON profiles TO service_role;
```

---

## üîß MIGRATION SQL DE S√âCURIT√â RECOMMAND√âE

Cr√©ons une migration pour **s√©curiser la colonne is_admin** :

```sql
-- ============================================
-- MIGRATION: Prot√©ger la colonne is_admin
-- Date: 14 octobre 2025
-- ============================================

-- Solution 1: Trigger (RECOMMAND√â - Plus simple)
CREATE OR REPLACE FUNCTION prevent_is_admin_self_modification()
RETURNS TRIGGER AS $$
BEGIN
  -- Si l'utilisateur essaie de changer son propre is_admin
  IF OLD.is_admin != NEW.is_admin AND OLD.id = auth.uid() THEN
    -- V√©rifier s'il est d√©j√† admin
    IF NOT OLD.is_admin THEN
      RAISE EXCEPTION 'Permission denied: Cannot grant yourself admin privileges';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER protect_is_admin_modification
  BEFORE UPDATE ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION prevent_is_admin_self_modification();

COMMENT ON FUNCTION prevent_is_admin_self_modification() IS 
'Emp√™che les utilisateurs de se donner eux-m√™mes les droits admin';
```

---

## üéØ ATTAQUE 7: XSS (Cross-Site Scripting)

### üî¥ Tentative de l'attaquant :
```javascript
// Injecter du JavaScript malveillant dans un champ
company_name = "<script>alert('Hacked!')</script>"
```

### ‚úÖ Pourquoi √ßa √âCHOUE :

**React √©chappe automatiquement** :
```tsx
// Dans Shop.tsx
<input 
  value={quoteForm.company_name}  // ‚Üê √âchapp√© automatiquement
  onChange={(e) => setQuoteForm({...quoteForm, company_name: e.target.value})}
/>

// Affichage dans Admin
<div>{quote.company_name}</div>  
// ‚Üê React convertit < et > en &lt; et &gt;
// R√©sultat affich√©: &lt;script&gt;alert('Hacked!')&lt;/script&gt;
```

**Protection React automatique** :
- ‚úÖ Tous les textes sont √©chapp√©s par d√©faut
- ‚úÖ `<script>` devient du texte pur, pas ex√©cut√©
- ‚úÖ Seul `dangerouslySetInnerHTML` peut ex√©cuter du HTML (non utilis√©)
- üõ°Ô∏è **XSS impossible**

---

## üéØ ATTAQUE 8: CSRF (Cross-Site Request Forgery)

### üî¥ Tentative de l'attaquant :
```html
<!-- Site malveillant: evil.com -->
<img src="https://votre-app.supabase.co/rest/v1/profiles?id=eq.xxx" 
     onerror="fetch('https://votre-app.supabase.co/rest/v1/profiles?id=eq.xxx&is_admin=true', {method: 'PATCH'})">
```

### ‚úÖ Pourquoi √ßa √âCHOUE :

**Protection 1: JWT requis**
```
Chaque requ√™te Supabase n√©cessite:
Authorization: Bearer <JWT_TOKEN>

Sans ce header ‚Üí 401 Unauthorized
```

**Protection 2: CORS (Cross-Origin Resource Sharing)**
```
Supabase v√©rifie l'origine de la requ√™te.
Si requ√™te vient de evil.com ‚Üí Bloqu√©e par le navigateur
```

**Protection 3: SameSite Cookie**
```javascript
// Les cookies Supabase sont configur√©s avec:
Set-Cookie: sb-access-token=xxx; SameSite=Lax

// evil.com ne peut PAS envoyer les cookies automatiquement
```

**R√©sultat** :
- ‚ùå Pas de JWT dans la requ√™te ‚Üí Rejet√©e
- ‚ùå CORS bloque les requ√™tes cross-origin
- ‚ùå Cookies not sent to evil.com requests
- üõ°Ô∏è **CSRF impossible**

---

## üéØ ATTAQUE 9: Brute Force sur les RLS Policies

### üî¥ Tentative de l'attaquant :
```javascript
// Essayer tous les UUID possibles
for (let i = 0; i < 1000000; i++) {
  await supabase
    .from('shop_quote_requests')
    .select('*')
    .eq('user_id', generateRandomUUID());
}
```

### ‚úÖ Pourquoi √ßa √âCHOUE :

**RLS Policy filtre AVANT le retour** :
```sql
-- La requ√™te de l'attaquant
SELECT * FROM shop_quote_requests WHERE user_id = 'random-uuid';

-- Ce que PostgreSQL ex√©cute
SELECT * FROM shop_quote_requests 
WHERE user_id = 'random-uuid'
AND (
  -- RLS Policy auto-ajout√©e
  user_id = auth.uid()  -- ‚Üê auth.uid() = son propre ID
  OR
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND is_admin = true)
);

-- R√©sultat: 0 lignes TOUJOURS (UUID ne matche jamais son ID)
```

**Protections suppl√©mentaires** :
- ‚úÖ **Rate Limiting Supabase** : Max requ√™tes/seconde
- ‚úÖ **UUID espace √©norme** : 2^122 possibilit√©s (impossible √† bruteforce)
- ‚úÖ **RLS filtre c√¥t√© serveur** : Pas de fuite de donn√©es
- üõ°Ô∏è **Brute force inutile**

---

## üéØ ATTAQUE 10: Social Engineering / Phishing

### üî¥ Tentative de l'attaquant :
```
1. Cr√©er un faux site identique
2. Envoyer email: "Votre compte a √©t√© suspendu, cliquez ici"
3. Voler login/password
4. Se connecter avec ces credentials
```

### ‚úÖ Pourquoi √ßa √âCHOUE (partiellement) :

**Si l'attaquant obtient les credentials** :
- ‚úÖ Il peut se connecter √† l'app
- ‚ùå **MAIS** il n'est toujours pas admin (`is_admin = false`)
- ‚ùå Pas d'acc√®s aux pages admin (AdminRoute bloque)
- ‚ùå Pas d'acc√®s aux donn√©es admin (RLS bloque)

**Protection maximale** :
```javascript
// RECOMMANDATION: Impl√©menter 2FA (Two-Factor Authentication)
// M√™me avec login/password, il faut un code SMS/Email
```

**Ce que l'attaquant peut faire** :
- ‚úÖ Voir les donn√©es du compte vol√© (dashboard, missions, etc.)
- ‚ùå Acc√©der aux pages admin
- ‚ùå Modifier is_admin
- ‚ùå Voir les donn√©es d'autres utilisateurs

---

## üìä MATRICE DE S√âCURIT√â - R√âSUM√â

| Vecteur d'attaque | Risque | Protection | Status |
|------------------|--------|------------|--------|
| Modification URL | ‚ùå Bas | AdminRoute + useAdmin() | ‚úÖ Prot√©g√© |
| LocalStorage hack | ‚ùå Bas | Requ√™tes serveur | ‚úÖ Prot√©g√© |
| React DevTools | ‚ö†Ô∏è Moyen | RLS Backend | ‚úÖ Prot√©g√© |
| HTTP Proxy | ‚ö†Ô∏è Moyen | JWT + RLS | ‚úÖ Prot√©g√© |
| SQL Injection | ‚ùå Bas | Prepared Statements | ‚úÖ Prot√©g√© |
| **is_admin self-edit** | üî¥ **√âLEV√â** | **‚ö†Ô∏è √Ä S√âCURISER** | **‚ùå VULN√âRABLE** |
| XSS | ‚ùå Bas | React auto-escape | ‚úÖ Prot√©g√© |
| CSRF | ‚ùå Bas | JWT + CORS + SameSite | ‚úÖ Prot√©g√© |
| Brute Force | ‚ùå Bas | RLS + Rate Limit | ‚úÖ Prot√©g√© |
| Social Engineering | ‚ö†Ô∏è Moyen | 2FA recommand√© | ‚ö†Ô∏è Partiel |

---

## ‚úÖ ACTIONS RECOMMAND√âES

### üî¥ URGENT - S√©curiser is_admin :

1. **Cr√©er le trigger de protection** (voir Solution 2 ci-dessus)
2. **Tester** : Essayer de modifier son propre `is_admin`
3. **V√©rifier** : Doit retourner une erreur

### ‚ö†Ô∏è MOYEN - Am√©liorer la s√©curit√© :

1. **Impl√©menter 2FA** (Two-Factor Authentication)
2. **Ajouter audit logging** (qui a modifi√© quoi et quand)
3. **Rate limiting** sur les endpoints sensibles
4. **Email notifications** quand is_admin change

### ‚ÑπÔ∏è OPTIONNEL - S√©curit√© avanc√©e :

1. **IP Whitelisting** pour l'admin
2. **Session timeout** courte pour les admins
3. **Suspicious activity detection**
4. **Honeypots** pour d√©tecter les attaques

---

## üéâ CONCLUSION

### Ce qui EST s√©curis√© ‚úÖ :
- ‚úÖ Pages admin (AdminRoute)
- ‚úÖ Donn√©es (RLS Policies)
- ‚úÖ Authentification (JWT)
- ‚úÖ Frontend (React auto-escape)
- ‚úÖ SQL (Prepared Statements)

### Ce qui DOIT √™tre s√©curis√© ‚ö†Ô∏è :
- üî¥ **Colonne `is_admin`** ‚Üí Trigger √† ajouter
- ‚ö†Ô∏è **2FA** ‚Üí √Ä impl√©menter
- ‚ö†Ô∏è **Audit logging** ‚Üí √Ä ajouter

### Niveau de s√©curit√© global :
**8/10** - Tr√®s bon, mais la protection `is_admin` est **CRITIQUE** √† impl√©menter !

---

**Fichier g√©n√©r√©**: `SECURITY_ATTACK_VECTORS.md`
**Date**: 14 octobre 2025
**Recommandation**: Impl√©menter le trigger `prevent_is_admin_self_modification()` **imm√©diatement** !
